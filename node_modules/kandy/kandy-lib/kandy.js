// Kandy.js
// Site: http://kandy.io
// Version: 2.7.0
// Copyright 2015 Genband
// ----------------------
(function webpackUniversalModuleDefinition(root, factory) {
	if(typeof exports === 'object' && typeof module === 'object')
		module.exports = factory();
	else if(typeof define === 'function' && define.amd)
		define([], factory);
	else if(typeof exports === 'object')
		exports["kandy"] = factory();
	else
		root["kandy"] = factory();
})(this, function() {
return /******/ (function(modules) { // webpackBootstrap
/******/ 	// The module cache
/******/ 	var installedModules = {};

/******/ 	// The require function
/******/ 	function __webpack_require__(moduleId) {

/******/ 		// Check if module is in cache
/******/ 		if(installedModules[moduleId])
/******/ 			return installedModules[moduleId].exports;

/******/ 		// Create a new module (and put it into the cache)
/******/ 		var module = installedModules[moduleId] = {
/******/ 			exports: {},
/******/ 			id: moduleId,
/******/ 			loaded: false
/******/ 		};

/******/ 		// Execute the module function
/******/ 		modules[moduleId].call(module.exports, module, module.exports, __webpack_require__);

/******/ 		// Flag the module as loaded
/******/ 		module.loaded = true;

/******/ 		// Return the exports of the module
/******/ 		return module.exports;
/******/ 	}


/******/ 	// expose the modules object (__webpack_modules__)
/******/ 	__webpack_require__.m = modules;

/******/ 	// expose the module cache
/******/ 	__webpack_require__.c = installedModules;

/******/ 	// __webpack_public_path__
/******/ 	__webpack_require__.p = "";

/******/ 	// Load entry module and return exports
/******/ 	return __webpack_require__(0);
/******/ })
/************************************************************************/
/******/ ([
/* 0 */
/***/ function(module, exports, __webpack_require__) {

	var fcs = __webpack_require__(1);
	var Promise = __webpack_require__(2);

	function getKandy() {
	    'use strict';

	    var kandyVersion = '2.7.0';

	    /*
	 * Utility namespace containing various functions used throughout Kandy.
	 *
	 * @class utils
	 * @static
	 */
	var utils = (function() {
	    var exports = {};

	    /*
	     * Function to create a Universally Unique ID.
	     *
	     * @method createUUIDv4
	     * @returns {String} s The resulting UUID.
	     */
	    exports.createUUIDv4 = function() {
	        var s = [],
	            itoh = '0123456789ABCDEF';

	        // Make array of random hex digits. The UUID only has 32 digits in it, but we
	        // allocate an extra items to make room for the '-'s we'll be inserting.
	        for (var i = 0; i < 36; i++) {
	            s[i] = Math.floor(Math.random() * 0x10);
	        }

	        // Conform to RFC-4122, section 4.4
	        s[14] = 4; // Set 4 high bits of time_high field to version
	        s[19] = (s[19] & 0x3) | 0x8; // Specify 2 high bits of clock sequence

	        // Convert to hex chars
	        for (i = 0; i < 36; i++) {
	            s[i] = itoh[s[i]];
	        }

	        // Insert '-'s
	        s[8] = s[13] = s[18] = s[23] = '-';

	        return s.join('');
	    };

	    /*
	     * Function to extend an object with passed in parameters.
	     *
	     * @method extend
	     * @return {Object} out The resulting object with extended values.
	     */
	    exports.extend = function(out) {
	        out = out || {};

	        for (var i = 1; i < arguments.length; i++) {
	            if (!arguments[i]) {
	                continue;
	            }

	            for (var key in arguments[i]) {
	                if (arguments[i].hasOwnProperty(key)) {
	                    out[key] = arguments[i][key];
	                }
	            }
	        }

	        return out;
	    };

	    /*
	     * Function to set default values of an object if they do not already exist.
	     *
	     * @method defaults
	     * @return {Object} out The resulting object with added default values.
	     */
	    exports.defaults = function(out) {
	        out = out || {};

	        for (var i = 1; i < arguments.length; i++) {
	            if (!arguments[i]) {
	                continue;
	            }

	            for (var key in arguments[i]) {
	                if (!out[key] && arguments[i].hasOwnProperty(key)) {
	                    out[key] = arguments[i][key];
	                }
	            }
	        }

	        return out;
	    };

	    /*
	     * Function to add URI parameters to a string.
	     *
	     * @method param
	     * @return {String} encodedString String composed of URI property/value pairs.
	     * TODO: Test.
	     */
	    exports.param = function(object) {
	        var encodedString = '', prop;

	        for (prop in object) {
	            if (object.hasOwnProperty(prop)) {
	                var value = object[prop];

	                if (value === undefined) {
	                    // Skip over values that are undefined
	                    continue;
	                }

	                if (value === null) {
	                    value = '';
	                }

	                if (typeof value !== 'string') {
	                    value = JSON.stringify(value);
	                }

	                if (encodedString.length > 0) {
	                    encodedString += '&';
	                }
	                encodedString += encodeURIComponent(prop) + '=' + encodeURIComponent(value);
	            }
	        }
	        return encodedString;
	    };

	    /*
	     * Function to check whether an object is a plain object.
	     *
	     * @method isPlainObject
	     * @param {any} value The value to check.
	     * @returns {Boolean} true if the value is a plain object. false otherwise.
	     */
	    exports.isPlainObject = function(value) {
	        return !!value && typeof value === 'object' && value.constructor === Object;
	    };

	    /*
	     * Extends a target object deeply.
	     *
	     * @method deepExtend
	     * @param {Object} target The target object that will be extended.
	     * @param {Object} ...objects The objects to extend target with.
	     * @returns {Object} Returns target.
	     */
	    exports.deepExtend = function(target) {
	        var args = Array.prototype.slice.call(arguments, 1);

	        args.forEach(function(obj) {
	            if (exports.isPlainObject(obj)){
	                Object.keys(obj).forEach(function(key) {
	                    var src = target[key];
	                    var val = obj[key];

	                    if (!exports.isPlainObject(val)) {
	                        target[key] = val;
	                    } else if (!exports.isPlainObject(src)) {
	                        target[key] = exports.deepExtend({}, val);
	                    } else {
	                        target[key] = exports.deepExtend(src, val);
	                    }
	                });
	            }
	        });

	        return target;
	    };

	    return exports;
	})();

	/*
	 * Request class provides functionality for creating and sending XML Http requests.
	 *
	 * @method request
	 */
	var request = (function(utils) {

	    var exports = function (options) {

	        options = utils.defaults(options, exports.defaultOptions);
	        options.headers = utils.defaults(options.headers, exports.defaultHeaders);

	        // Take the data parameters and append them to the URL.
	        var queryString = utils.param(options.params);
	        if (queryString.length > 0) {
	            if (options.url.indexOf('?') === -1) {
	                options.url += '?';
	            }
	            options.url += queryString;
	        }

	        var xhr = new XMLHttpRequest();
	        xhr.open(options.type, options.url, true);
	        xhr.withCredentials = options.withCredentials;

	        // Set the headers.
	        var headerKey;
	        for (headerKey in options.headers) {
	            if(options.headers.hasOwnProperty(headerKey)) {
	                xhr.setRequestHeader(headerKey, options.headers[headerKey]);
	            }
	        }

	        // Stringify data if not already a string.
	        if (options.data && typeof options.data !== 'string' ) {
	            options.data = JSON.stringify(options.data);
	        }

	        // Attach the call back
	        xhr.onreadystatechange = function() {
	            if (xhr.readyState === 4) {

	                // All the status codes considered a success.
	                var success = (xhr.status >= 200 && xhr.status < 300) || xhr.status === 304;

	                var response  = xhr.responseText;
	                if (options.dataType === 'json' && typeof response === 'string') {

	                    if (response.length) {
	                        response = JSON.parse(response);
	                    } else {
	                        response = {};
	                    }
	                }

	                // TODO: Promisify this.
	                if (success) {
	                    if (typeof options.success === 'function') {
	                        options.success({status: xhr.status, response: response});
	                    }
	                } else {
	                    if (typeof options.failure === 'function') {
	                        options.failure({status: xhr.status, statusText: xhr.statusText, response: response });
	                    }
	                }
	            } else if (xhr.readyState === 0) {
	                if (typeof options.failure === 'function') {
	                    options.failure({status: xhr.status, statusText: xhr.statusText, response: 'Call aborted.'});
	                }
	            }
	        };

	        xhr.send(options.data);
	    };

	    /*
	     * Default headers for a request.
	     */
	    exports.defaultHeaders = {
	        'Content-Type': 'application/json',
	        'Accept': 'application/json'
	    };

	    /*
	     * Default options for a request.
	     */
	    exports.defaultOptions = {
	        type: 'GET',
	        url: '',
	        withCredentials: false,
	        dataType: 'json'
	    };

	    return exports;

	})(utils);


	/*
	 * Event emitter module. Can be used as a standalone factory or as a mixin.
	 *
	 * @private
	 * @class emitter
	 * @example
	 * ``` javascript
	 * var eventEmitter = emitter(); // Create a new emitter.
	 * emitter(myEmittingObject.prototype); // Mixin to an existing object.
	 * ```
	 */
	var emitter = (function(utils) {
	    return function(prototype) {

	        var eventMap = [];
	        var strictMode = false;

	        /*
	         * Check if the event is a valid event type.
	         */
	        function checkEvent(type) {
	            if (strictMode && !eventMap[type]) {
	                throw new Error('Invalid event type: ' + type);
	            }
	        }

	        return utils.extend(prototype, {
	            /*
	             * Define an event type with the event emitter.
	             *
	             * @method define
	             * @param {String} type The name for the event type.
	             */
	            define: function(type) {
	                eventMap[type] = eventMap[type] || [];
	            },

	            /*
	             * Define an alias for an event type.
	             *
	             * @method alias
	             * @param {String} type The event type for which to add an alias.
	             * @param {String} alias The alias name for the event type.
	             * @throws {Error} Invalid event type
	             */
	            alias: function(type, alias) {
	                checkEvent(type);

	                eventMap[alias] = (eventMap[type] = eventMap[type] || []);
	            },

	            /*
	             * Add an event listener for the specified event type.
	             *
	             * @method on
	             * @param {String} type The event type for which to add the listener.
	             * @param {Function} listener The listener for the event type. The parameters
	             *                            of the listener depend on the event type.
	             * @throws {Error} Invalid event type
	             */
	            on: function(type, listener) {
	                checkEvent(type);

	                (eventMap[type] = eventMap[type] || []).push(listener);
	            },

	            /*
	             * Removes an event listener for the specified event type.
	             *
	             * @method off
	             * @param {String} type The event type for which to remote the listener.
	             * @param {Function} listener The listener to remove.
	             * @throws {Error} Invalid event type
	             */
	            off: function(type, listener) {
	                checkEvent(type);

	                var list = eventMap[type] || [];
	                var i = list.length;
	                while(i--) {
	                    if (listener === list[i]) {
	                        list.splice(i, 1);
	                    }
	                }
	            },

	            /*
	             * Emits an event of the specified type.
	             *
	             * @method emit
	             * @param {String} type The event type to emit.
	             * @param {any} [...args] The arguments to pass to the listeners of the event.
	             * @throws {Error} Invalid event type
	             */
	            emit: function(type) {
	                checkEvent(type);

	                var args = Array.prototype.slice.call(arguments, 1),
	                    list = eventMap[type] || [],
	                    i = 0;

	                for(; i < list.length; i++) {
	                    list[i].apply(undefined, args);
	                }
	            },

	            /*
	             * Sets the emitter in strict mode where it only allows events that have been defined or aliases.
	             *
	             * @method setStrictMode
	             * @param {Boolean} strict Whether to set strict mode for the emitter.
	             */
	            setStrictMode: function(strict) {
	                strictMode = strict;
	            }
	        });
	    };
	})(utils);

	/*
	 * The core namespace contains miscellaneous stand-alone functions. Core includes API information, logging functions, and event declarations.
	 *
	 * @class core
	 * @static
	 */

	/*
	 * Private copy of response codes.
	 */
	var responseCodes = {
	    OK: 0,
	    internalServerError: 1,
	    tokenExpired: 10,
	    permissionDenied: 11,
	    usageQuotaExceeded: 12,
	    insufficientFunds: 13,
	    validationFailed: 14,
	    missingParameter: 15,
	    invalidParameterValue: 16,
	    badParameterValue: 17,
	    unknownRequest: 18,
	    noData: 19,
	    alreadyExists: 50,
	    invalidIdentifier: 51,
	    invalidPassword: 52,
	    doesNotExist: 53,
	    invalidCountryCode: 54,
	    invalidCredentials: 55,
	    ajaxError: 5000,
	    wsError: 6000,
	    wsAlreadyOpened: 6001,
	    wsNotFound: 6002,
	    wsCreateError: 6003,
	    wsNotAuth: 6004
	};

	/**
	 * The kandy namespace is the overarching container for Kandy's methods and information.
	 *
	 * @module kandy
	 * @class kandy
	 * @static
	 */
	var api = {

	    /**
	     * Current version of Kandy.
	     *
	     * @property version
	     * @type String
	     * @readonly
	     */
	    version: (typeof kandyVersion !== 'undefined') ? kandyVersion : 'dev',

	    /*
	     * Map of response codes for kandy.
	     *
	     * @todo Document this property and make it public.
	     * @property responseCodes
	     */
	    responseCodes: JSON.parse(JSON.stringify(responseCodes)),

	    /*
	     * This is just a namespace for internal, undocumented functions for
	     * advanced users.
	     */
	    internal: {}
	};

	/*
	 * Initialize logger levels.
	 */
	var _nofunc = function(){};
	var _logger = {
	        'info': _nofunc,
	        'warn': _nofunc,
	        'error': _nofunc,
	        'debug': _nofunc
	    };

	/*
	 * Sets the log level for logging output.
	 *
	 * @method _setLogLevel
	 * @param {String} level Log level to be set, ie. error/warn/info/debug.
	 */
	function _setLogLevel(level){
	    /*eslint-disable no-console*/
	    var lError = false, lWarn = false, lInfo = false, lDebug = false;

	    if(window.console && console.warn && console.error && console.info){
	        if(level === 'debug'){
	            lError = lWarn = lInfo = lDebug = true;
	        }if(level === 'info'){
	            lError = lWarn = lInfo = true;
	        } else if(level === 'warn'){
	            lError = lWarn = true;
	        } else if(level === 'error'){
	            lError = true;
	        }

	        if(lDebug){
	            _logger.debug = window.console.log.bind(window.console, 'kandy debug: %s');
	        }

	        if(lInfo){
	            _logger.info = window.console.info.bind(window.console, 'kandy info: %s');
	        }

	        if(lWarn){
	            _logger.warn = window.console.warn.bind(window.console, 'kandy warn: %s');
	        }

	        if(lError){
	            _logger.error = window.console.error.bind(window.console, 'kandy error: %s');
	        }
	    }

	    /*eslint-enable no-console*/
	}

	/*
	 * Default log level to warn.
	 */
	_setLogLevel('warn');

	/*
	 * Configuration for KandyAPI.Phone.
	 */
	var _config = {
	    version: 0,
	    listeners: {},
	    kandyApiUrl: 'https://api.kandy.io/v1.2',
	    mediatorUrl: 'http://service.kandy.io:8080/kandywrapper-1.0-SNAPSHOT',
	    messageProvider: 'fring',
	    pstnOutNumber: '71',
	    sipOutNumber: '72',
	    allowAutoLogin: false,
	    kandyWSUrl: null,
	    fcsConfig: {
	        restPlatform: 'kandy', // 'spidr' or 'kandy'
	        kandyApiUrl: 'https://api.kandy.io/v1.1/users/gateway',
	        useInternalJquery: false
	    },
	    spidrApi: {
	        cors: false,
	        disableNotifications: null,
	        notificationType: fcs.notification.NotificationTypes.WEBSOCKET,
	        websocketProtocol: 'wss',
	        pluginMode: {
	            // Forces Firefox to use the plugin
	            mode: 'auto',
	            h264: true,
	            firefox: {
	                mode: 'webrtc'
	            }
	        },
	        codecsToReplace: []
	    },
	    spidrMedia: {
	      pluginLogLevel: 2
	    }
	};

	/*
	 * User Details gotten from login.
	 */
	var _userDetails = null;

	/*
	 * Auto Reconnection configuration.
	 */
	var _autoReconnect = true;

	/*
	 * Register for Calls configuration.
	 */
	var _registerForCalls = true;

	 /*
	  * This method is for setting up default values for an AJAX call.
	  * @method _kandyRequest
	  */
	var _kandyRequest = function (options) {

	    // set the default method as GET
	    if (options.type === undefined || !options.type) {
	        options.type = 'GET';
	    }

	    // Set the base url to talk to the correct version of kandy.
	    options.url = (options.kandyApiUrl || _config.kandyApiUrl) + options.url;

	    // Add an empty params option if there is none so we can add the key.
	    options.params = options.params || {};

	    // check if the url doesn't contain 'key' as param, then add userDetails.userAccessToken as 'key'
	    if (!options.params.key) {
	        options.params.key = _userDetails.userAccessToken;
	    }

	    // The REST API will expect a body if Content-Type is not set to 'text/html' during a DELETE operation.
	    if (options.type === 'DELETE' && !options.data) {
	        options.headers = options.headers || {};
	        options.headers['Content-Type'] = 'text/html';
	    }

	    var success = options.success;
	    var failure = options.failure;

	    // Map a different success function that also takes into account the response's status field.
	    // Note: Doing this will be more elegant once we have promise support.
	    options.success = function(result) {
	        if (result.response.status === responseCodes.OK) {
	            if (success) {
	                // Note: Here we just send the response back to the success handler to support backwards compatibility.
	                success(result.response);
	            }
	        } else {
	            if (failure) {
	                if(_config.kandyApiUrl.indexOf('v1.2') > -1) {
	                    // Use the old format if the application is using v1.2.
	                    failure(result.statusText, responseCodes.ajaxError);
	                } else {
	                    // Else use the v1.3 non-200 error response format.
	                    failure({ message: result.response.message, errorCode: result.response.status });
	                }
	            }
	        }
	    };

	    options.failure = function(result) {
	        // TODO: These error messages seem arbitrary and rather useless. Remove them?
	        if (result.status === 403 || result.status === 401) {
	            _logger.error('Unauthorized Error !!!');
	        } else if (result.status === 426) {
	            _logger.error('Kandy upgrade required!');
	        }

	        if (failure) {
	            if(_config.kandyApiUrl.indexOf('v1.2') > -1) {
	                // Use the old format if the application is using v1.2.
	                failure(result.statusText, responseCodes.ajaxError);
	            } else if(result.response.results) {
	                // Use the v1.3 non-200 error response format if it was returned.
	                failure({ message: result.response.results.error.message, errorCode: result.response.meta.status_code });
	            } else {
	                // Else return a generic message.
	                // This is needed for a few inconsistent scenarios, where nothing is returned.
	                failure({ message: 'Error', errorCode: result.status });
	            }

	        }
	    };

	    request(options);
	};

	 /*
	  * Promisified version of _kandyRequest
	  * @method _kandyRequestAsync
	  */
	var _kandyRequestAsync = function(options) {
	    return new Promise(function(resolve, reject) {
	        options.success = resolve;
	        options.failure = reject;

	        _kandyRequest(options);
	    });
	};

	/*
	 * This method initializes the logger.
	 * @method _initLogger
	 */
	var _initLogger = function (logger) {
	    try {
	        fcs.logManager.initLogging(logger || function (x, y, z) {
	            if (z.message === 'ERROR') {
	                window.console.log(z.message);
	            }
	            else {
	                window.console.log(z.message);
	            }
	        }, true);
	        _logger = fcs.logManager.getLogger('kandy_js');
	    } catch (e) {
	        // TODO: Shouldn't swallow exceptions silently
	    }
	};

	// This is needed by some advanced users.
	api.internal.initLogger = _initLogger;
	api.internal.kandyRequest = _kandyRequestAsync;

	/*global emitter*/

	var events = (function(api, emitter) {

	    var exports = emitter();

	    // TODO: Enable this whenever we have defined every event that we fire.
	    // exports.setStrictMode(true);

	    /**
	     * Add an event listener for a specific Kandy event.
	     *
	     * @method on
	     * @for kandy
	     * @param {String} type The event type for which to register an event listener.
	     * @param {Function} listener The listener function that will be called when the event is emitted with the parameters
	     *                   of the event.
	     * @param {any} [listener....arguments] The arguments corresponding to the event being emitted.
	     */
	    api.on = exports.on.bind(exports);

	    /**
	     * Remove an event listener for a specific Kandy event.
	     *
	     * @method off
	     * @param {String} type The event type for which to remove the listener.
	     * @param {Function} listener The listener function to remove from the list of listeners.
	     */
	    api.off = exports.off.bind(exports);

	    /**
	     * Fired when an outgoing call is initiated.
	     *
	     * @event callinitiated
	     * @param {Call} outgoingCall Current active call.
	     * @param {String} number The Kandy user being called.
	     */
	    exports.define('callinitiated');

	    /**
	     * Fired when an attempt to initiate an outgoing call fails.
	     *
	     * @event callinitiatefailed
	     * @param {String} reasonText The reason for the failure or empty string.
	     */
	    exports.define('callinitiatefailed');

	    /**
	     * Fired when an incoming call is received.
	     *
	     * @event callincoming
	     * @param {Call} call Current active call.
	     */
	    exports.define('callincoming');

	    /**
	     * Fired when an outgoing or incoming call has ended.
	     *
	     * @event callended
	     * @param {Call} call The call object that was ended.
	     * @param {Object} data The data about the event.
	     * @param {Object} data.reason Information about the reason for the call end event.
	     * @param {Number} data.reason.code Status code corresponding to the call end reason. See callEndReasons under kandy.call for more information.
	     * @param {String} data.reason.text The human-readable text describing the call end reason, for debugging purposes.
	     */
	    exports.define('callended');

	    /**
	     * Fired when a call fails to end.
	     *
	     * @event callendfailed
	     * @param {Call} call Current active call.
	     * @param {String} errorCode Error code of the reason for the failure.
	     */
	    exports.define('callendfailed');

	    /**
	     * Fired when a call is answered.
	     *
	     * @event callanswered
	     * @param {Call} call Current active call.
	     */
	    exports.define('callanswered');

	    /**
	     * Fired when answering an incoming call fails.
	     *
	     * @event callanswerfailed
	     * @param {Call} call Current active call.
	     */
	    exports.define('callanswerfailed');

	    /**
	     * Fired when a call is established or a call parameter changes.
	     *
	     * @event oncall
	     * @deprecated Use a `callestablished` and/or `callstatechanged` instead.
	     * @param {Call} call Current active call.
	     */
	    exports.define('oncall');

	    /**
	     * Fired when a call has been established.
	     *
	     * @event callestablished
	     * @param {Call} call Current active call.
	     */
	    exports.define('callestablished');

	    /**
	     * Fired during a call when the state of the call changes. For example whether
	     * the other side is no longer sending video.
	     *
	     * @event callstatechanged
	     * @param {Call} call Current active call.
	     */
	    exports.define('callstatechanged');

	    /**
	     * Fired when an error occurs when initiating media.
	     *
	     * @event media
	     * @param {Object} errorInfo Information about the media error.
	     */
	    exports.define('media');

	    /*
	     * Fired when a presence notification is received.
	     *
	     * @event presencenotification
	     * @deprecated This type of presence notification was removed.
	     * @param {String} username Username of presence event
	     * @param {String} state Presence state
	     * @param {String} description Presence description
	     * @param {String} activity Presence activity
	     */
	    exports.define('presencenotification');

	    /**
	     * Fired when the user logs in.
	     *
	     * @event loginsuccess
	     * @param {User} user The logged on user object
	     */
	    exports.define('loginsuccess');

	    /**
	     * Fired when login failed.
	     *
	     * @event loginfailed
	     * @param {string} message Error message for loginfailed.
	     */
	    exports.define('loginfailed');

	    /**
	     * Fired when an incoming call is rejected.
	     *
	     * @event callrejected
	     * @param {Call} call Current active call.
	     */
	    exports.define('callrejected');

	    /**
	     * Fired when an incoming call rejection fails.
	     *
	     * @event callrejectfailed
	     * @param {Call} call Current active call.
	     */
	    exports.define('callrejectfailed');

	    /**
	     * Fired when an incoming call is ignored.
	     *
	     * @event callignored
	     * @param {Call} call Current active call.
	     */
	    exports.define('callignored');

	    /**
	     * Fired when an incoming call ignore fails.
	     *
	     * @event callignorefailed
	     * @param {Call} call Current active call.
	     */
	    exports.define('callignorefailed');

	    /**
	     * Fired when the remote party puts the call on hold.
	     *
	     * @event callhold
	     * @param {Call} call Current active call.
	     */
	    exports.define('callhold');

	    /**
	     * Fired when a call is transferred to a third-party.
	     *
	     * @event calltransferred
	     * @param {Call} call Call that was transferred.
	     */
	    exports.define('calltransferred');

	    /**
	     * Fired when a call transfer fails.
	     *
	     * @event calltransferfailed
	     * @param {Call} call Call that was attempted to be transferred.
	     */
	    exports.define('calltransferfailed');

	    /**
	     * @event remotehold
	     * @deprecated Use the 'callhold' event instead.
	     * @param {Call} call Current active call.
	     */
	    exports.alias('callhold', 'remotehold');

	    /**
	     * Fired when the remote party releases hold the on call.
	     *
	     * @event callunhold
	     * @param {Call} call Current active call.
	     */
	    exports.define('callunhold');

	    /**
	     * @event remoteunhold
	     * @deprecated Use the 'callunhold' event instead.
	     * @param {Call} call Current active call.
	     */
	    exports.alias('callunhold', 'remoteunhold');

	    /**
	     * Fired when a user stops a screensharing session using the browser provided controls or by calling
	     * `kandy.call.stopScreenSharing`.
	     *
	     * @event callscreenstopped
	     * @param {Call} call Call for which the screen sharing was stopped.
	     */
	    exports.define('callscreenstopped');

	    /**
	     * Fired when the connection to Kandy server dies.
	     *
	     * @event onconnectionlost
	     */
	    exports.define('onconnectionlost');

	    /**
	     * Fired when a new message is received.
	     *
	     * @event message
	     * @param {Object} message The chat message to be handled.
	     */
	    exports.define('message');

	    /**
	     * Fired when new messages are available.
	     *
	     * @event messagesavailable
	     * @deprecated Use event 'message' instead. Note that this is not an alias. It is fired in slightly different
	     *             circumstances than the 'message' event.
	     */
	    exports.define('messagesavailable');

	    /**
	     * Fired when a conference invitation is received.
	     *
	     * @event conferenceInvite
	     * @param {Object} event The event object.
	     * @param {String} event.type The type of event. This is the same as the event name.
	     * @param {String} event.UUID the unique identifier for the event.
	     * @param {String} event.timestamp A timestamp of when the event was generated.
	     * @param {String} event.sender The Kandy full user ID for the user who started this event.
	     * @param {String} event.conferenceId The unique id of the conference.
	     * @param {String} event.ipAccess The IP number you can use to call into the conference.
	     * @param {String} event.pstnAccess The PSTN phone number to call to join the conference audio.
	     * @param {String} event.pinCode The pin code needed to join the conference audio from PSTN.
	     */
	    exports.define('conferenceInvite');

	    /**
	     * Fired when a participant has joined the conference.
	     *
	     * @event participantJoinedConference
	     * @param {Object} event The event object.
	     * @param {String} event.type The type of event. This is the same as the event name.
	     * @param {String} event.UUID the unique identifier for the event.
	     * @param {String} event.timestamp A timestamp of when the event was generated.
	     * @param {String} event.sender The Kandy full user ID for the user who started this event.
	     * @param {String} event.participantId The participant ID of the participant.
	     * @param {String} event.conferenceId The unique id of the conference.
	     */
	    exports.define('participantJoinedConference');

	    /**
	     * Fired when a participant leaves the conference.
	     *
	     * @event participantLeftConference
	     * @param {Object} event The event object.
	     * @param {String} event.type The type of event. This is the same as the event name.
	     * @param {String} event.UUID the unique identifier for the event.
	     * @param {String} event.timestamp A timestamp of when the event was generated.
	     * @param {String} event.sender The Kandy full user ID for the user who started this event.
	     * @param {String} event.participantId The participant ID of the participant.
	     * @param {String} event.conferenceId The unique id of the conference.
	     */
	    exports.define('participantLeftConference');

	    /**
	     * Fired when a participant's nickname has changed.
	     *
	     * @event participantNameChanged
	     * @param {Object} event The event object.
	     * @param {String} event.type The type of event. This is the same as the event name.
	     * @param {String} event.UUID the unique identifier for the event.
	     * @param {String} event.timestamp A timestamp of when the event was generated.
	     * @param {String} event.sender The Kandy full user ID for the user who started this event.
	     * @param {String} event.participantId The participant ID of the participant.
	     * @param {String} event.newParticipantName The new name of the participant.
	     * @param {String} event.conferenceId The unique id of the conference.
	     */
	    exports.define('participantNameChanged');

	    /**
	     * Fired when a participant is muted.
	     *
	     * @event participantMuted
	     * @param {Object} event The event object.
	     * @param {String} event.type The type of event. This is the same as the event name.
	     * @param {String} event.UUID the unique identifier for the event.
	     * @param {String} event.timestamp A timestamp of when the event was generated.
	     * @param {String} event.sender The Kandy full user ID for the user who started this event.
	     * @param {String} event.participantId The participant ID of the participant.
	     * @param {String} event.conferenceId The unique id of the conference.
	     */
	    exports.define('participantMuted');

	    /**
	     * Fired when a participant is unmuted.
	     *
	     * @event participantUnmuted
	     * @param {Object} event The event object.
	     * @param {String} event.type The type of event. This is the same as the event name.
	     * @param {String} event.UUID the unique identifier for the event.
	     * @param {String} event.timestamp A timestamp of when the event was generated.
	     * @param {String} event.sender The Kandy full user ID for the user who started this event.
	     * @param {String} event.participantId The participant ID of the participant.
	     * @param {String} event.conferenceId The unique id of the conference.
	     */
	    exports.define('participantUnmuted');

	    /**
	     * Fired when a participant's video is started.
	     *
	     * @event participantVideoStarted
	     * @param {Object} event The event object.
	     * @param {String} event.type The type of event. This is the same as the event name.
	     * @param {String} event.UUID the unique identifier for the event.
	     * @param {String} event.timestamp A timestamp of when the event was generated.
	     * @param {String} event.sender The Kandy full user ID for the user who started this event.
	     * @param {String} event.participantId The participant ID of the participant.
	     * @param {String} event.conferenceId The unique id of the conference.
	     */
	    exports.define('participantVideoStarted');

	    /**
	     * Fired when a participant's video is stopped.
	     *
	     * @event participantVideoStopped
	     * @param {Object} event The event object.
	     * @param {String} event.type The type of event. This is the same as the event name.
	     * @param {String} event.UUID the unique identifier for the event.
	     * @param {String} event.timestamp A timestamp of when the event was generated.
	     * @param {String} event.sender The Kandy full user ID for the user who started this event.
	     * @param {String} event.participantId The participant ID of the participant.
	     * @param {String} event.conferenceId The unique id of the conference.
	     */
	    exports.define('participantVideoStopped');

	    /**
	     * Fired when a participant is put on hold.
	     *
	     * @event participantOnHold
	     * @param {Object} event The event object.
	     * @param {String} event.type The type of event. This is the same as the event name.
	     * @param {String} event.UUID the unique identifier for the event.
	     * @param {String} event.timestamp A timestamp of when the event was generated.
	     * @param {String} event.sender The Kandy full user ID for the user who started this event.
	     * @param {String} event.participantId The participant ID of the participant.
	     * @param {String} event.conferenceId The unique id of the conference.
	     */
	    exports.define('participantOnHold');

	    /**
	     * Fired when a participant is taken off hold.
	     *
	     * @event participantOffHold
	     * @param {Object} event The event object.
	     * @param {String} event.type The type of event. This is the same as the event name.
	     * @param {String} event.UUID the unique identifier for the event.
	     * @param {String} event.timestamp A timestamp of when the event was generated.
	     * @param {String} event.sender The Kandy full user ID for the user who started this event.
	     * @param {String} event.participantId The participant ID of the participant.
	     * @param {String} event.conferenceId The unique id of the conference.
	     */
	    exports.define('participantOffHold');

	    /**
	     * Fired when a message was acknowledged to be received by the other party.
	     *
	     * @event chatRemoteAck
	     * @param {Message} message The chat ack message.
	     */
	    exports.define('chatRemoteAck');

	    /**
	     * Fired when a message is received in a group. All group members except the sender receive the event message.
	     *
	     * @event chatGroupMessage
	     * @param {Message} message The received message.
	     */
	    exports.define('chatGroupMessage');

	    /**
	     * Fired when a user is added to a group. All group members, including the newly added member, receive the event.
	     *
	     * @event chatGroupInvite
	     * @param {Message} message The group invite message.
	     */
	    exports.define('chatGroupInvite');

	    /**
	     * Fired when a user (or multiple users) is removed from a group. All group members receive the event.
	     *
	     * @event chatGroupBoot
	     * @param {Message} message The group boot message.
	     */
	    exports.define('chatGroupBoot');

	    /**
	     * Fired when a user leaves a group. All group members receive the event.
	     *
	     * @event chatGroupLeave
	     * @param {Message} message The group leave message
	     */
	    exports.define('chatGroupLeave');

	    /**
	     * Fired when a group is updated. All group members receive the event.
	     *
	     * @event chatGroupUpdate
	     * @param {Message} message The group update message
	     */
	    exports.define('chatGroupUpdate');

	    /**
	     * Fired when a group is deleted. All group members receive the event.
	     *
	     * @event chatGroupDelete
	     * @param {Message} message The group delete message
	     */
	    exports.define('chatGroupDelete');

	    return exports;

	})(api, emitter);

	/*
	 * Websocket class containing all functions and properties related to the websocket.
	 *
	 * @class websocket
	 * @static
	 */

	/*
	 * Registered WebSocket events.
	 */
	var _wsEvents = {};

	/*
	 * Registered WebSocket handlers for responses.
	 */
	var _wsResponses = {};

	/*
	 * WebSocket object.
	 */
	var _ws = null;

	/*
	 * Timeout for ping mechanism.
	 */
	var _wsPingTimeout;

	/*
	 * Timeout for reconnect mechanism.
	 */
	var _connectionLostTimeout;

	/*
	 * Count for failed reconnect attempts.
	 */
	var _reconnectCount = 0;

	/*
	 * Indicator for if online and offline events has been added to the window.
	 */
	var _onlineEventAttached = false;


	/*
	 * Function to test whether the websocket is opened or not.
	 *
	 * @method isWebSocketOpened
	 * @return {Boolean} opened Indication of if the WebSocket is open.
	 */
	function isWebSocketOpened() {
	    var opened = false;

	    if (_ws) {
	        opened = (_ws.readyState === 1);
	    }

	    return opened;
	}


	/*
	 * Function to send a ping to the websocket.
	 *
	 * @method sendWSPing
	 */
	function sendWSPing() {
	    if (isWebSocketOpened())
	    {
	        _wsPingTimeout = setTimeout(sendWSPing, 30000);

	        var json = {
	           'message_type': 'ping'
	        };
	        try {
	            _ws.send(JSON.stringify(json));
	        } catch (e) {
	            window.console.error('Exception in sendWSPing: ' + e.message);
	        }
	    }
	}

	/*
	 * Function to reconnect to the websocket.
	 *
	 * @method reconnect
	 */
	function reconnect() {
	    window.console.log('reconnecting');

	    openWebSocket(function () { // eslint-disable-line no-use-before-define
	        window.console.log('reconnect success');
	        _reconnectCount = 0;
	        events.emit('onconnectionrestored');
	    },
	            function () {
	                _reconnectCount++;
	                window.console.log('failed to reconnect');
	                autoReconnect(); // eslint-disable-line no-use-before-define
	            });
	}

	/*
	 * Function to set auto-reconnect timer.
	 *
	 * @method autoReconnect
	 */
	function autoReconnect() {
	    var timeout = (_reconnectCount > 10) ? ((_reconnectCount > 100) ? 60000 : 30000) : 10000;
	    _connectionLostTimeout = setTimeout(reconnect, timeout);
	}

	/*
	 * Function to close the Web Socket.
	 *
	 * @method closeWebSocket
	 */
	function closeWebSocket() {
	    clearTimeout(_wsPingTimeout);
	    _wsPingTimeout = null;
	    if (isWebSocketOpened()) {
	        _ws.close();
	    }
	}

	/*
	 * Function to remove listeners on a Web Socket
	 *
	 * @method cleanupWebSocket
	 */
	function cleanupWebSocket() {
	    _ws.onclose = null;
	    _ws.onopen = null;
	    _ws.onerror = null;
	    _ws.onmessage = null;
	}

	/*
	 * Event function triggered when the window goes online. Sets reconnect timeout.
	 *
	 * @method onBrowserOnline
	 */
	function onBrowserOnline() {
	    window.console.log('browser going online');
	    clearTimeout(_connectionLostTimeout);
	    _connectionLostTimeout = setTimeout(reconnect, 500);
	}

	/*
	 * Event function triggered when the window goes offline. Closes the websocket.
	 *
	 * @method onBrowserOffline
	 */
	function onBrowserOffline() {
	    window.console.log('browser going offline');
	    clearTimeout(_wsPingTimeout);

	    // We need to manually call `onclose` because it's not called when we do
	    // _ws.close(). It's only called when the server accepts to close the WS.
	    if (_ws && _ws.onclose) {
	        _ws.onclose();

	        // We still need to call close(); so that isWebSocketOpened() behaves
	        // correctly. We make sure to cleanup the websocket before we close it
	        // just to be sure not to call `onclose` more than once.
	        cleanupWebSocket();
	        _ws.close();
	    }
	}

	/*
	 * Function to generate a URL for the websocket using the data channel configurations.
	 *
	 * @method buildWebSocketUrlFromDataChannelConfig
	 * @param {Object} dataChannelConfig Configuration of the data channel.
	 * @return {String} wsURL Websocket URL.
	 */
	function buildWebSocketUrlFromDataChannelConfig(dataChannelConfig) {
	    var host = dataChannelConfig.data_server_host,
	            port = dataChannelConfig.data_server_port,
	            isSecure = dataChannelConfig.is_secure;

	    //only keep the url because of an issue with REST api 1.1 and 1.2
	    var hostMatches = host.match('^(?:https?:\/\/)?(?:www\.)?([^\/]+)');
	    var portString = port ? (':' + port) : '';

	    return (isSecure ? 'wss' : 'ws') + '://' + hostMatches[1] + portString;
	}

	/*
	 * Get the data channel configuration used to connect to the websocket.
	 *
	 * @method getDataChannelConfiguration
	 * @async
	 * @param {Function} success Callback function that will be called when the retrieval is completed successfully.
	 * @param {Function} failure Callback function that will be called whenever an error occurs.
	 */
	function getDataChannelConfiguration(success, failure) {
	    _kandyRequest({
	        url: '/users/configurations/data_channel',
	        success: function (response) {
	            if (success) {
	                success(response.result);
	            }
	        },
	        failure: failure
	    });
	}

	/*
	 * Function to send data through the Websocket Channel.
	 *
	 * @method sendWebSocketData
	 * @param {String} data The data to be sent.
	 * @param {Object} [success] Callback function that will be called when the data is sent successfully.
	 * @param {Object} [failure] Callback function that will be called whenever an error occurs.
	 */
	function sendWebSocketData(data, success, failure) {
	    if (isWebSocketOpened()) {
	        if ((success || failure) && (data.id === undefined)) {
	            var id = utils.createUUIDv4();
	            data.id = id;
	            _wsResponses[id] = {success: success, failure: failure};
	        }

	        try {
	            _ws.send(JSON.stringify(data));
	        } catch (e) {
	            window.console.log('Exception in sendWebSocketData: ' + e.message);
	        }

	    } else {
	        failure();
	    }
	}

	/*
	 * Function to register listeners to Web Socket events.
	 *
	 * @method registerWebSocketListeners
	 * @param {Object} listeners
	 */
	function registerWebSocketListeners(listeners) {
	    var listner;
	    if (listeners) {
	        for (var listener in listeners) {
	            if (listeners.hasOwnProperty(listener)) {
	                if (_wsEvents[listener] === undefined) {
	                    _wsEvents[listener] = [];
	                }
	                _wsEvents[listener].push(listeners[listener]);
	            }
	        }
	    }
	}

	/*
	 * Function to open the websocket channel.
	 *
	 * @method openWebSocket
	 * @param {Object} [success] Callback function that will be called when the websocket has been opened successfully.
	 * @param {Object} [failure] Callback function that will be called whenever an error occurs.
	 */
	function openWebSocket(success, failure) {
	    var handshareId;

	    if (isWebSocketOpened()) {
	        closeWebSocket();
	        return;
	    }

	    getDataChannelConfiguration(
	            function (result) {
	                _config.kandyWSUrl = buildWebSocketUrlFromDataChannelConfig(result) + '?client_sw_type=js&client_sw_version=' + api.version + '&user_access_token=';

	                try {
	                    _logger.debug('Opening websocket, UAT = ' + _userDetails.userAccessToken);

	                    // Remove listeners before losing a reference to the current socket
	                    if (_ws) {
	                        cleanupWebSocket();
	                    }
	                    _ws = new WebSocket(_config.kandyWSUrl + encodeURIComponent(_userDetails.userAccessToken));
	                } catch (wsError) {
	                    if (failure) {
	                        failure('Error opening websocket', responseCodes.wsCreateError);
	                    }
	                    return;
	                }

	                if (_ws !== null && _ws.readyState !== 2 && _ws.readyState !== 3) {

	                    _ws.onopen = function (evt) {
	                        if (window.addEventListener && !_onlineEventAttached) {
	                            // Set listeners for connection status
	                            fcs.notification.setOnConnectionEstablished(function () {
	                                _logger.info('Connection established');
	                                events.emit('onconnectionestablished', 'spider');
	                                onBrowserOnline();
	                            });

	                            fcs.notification.setOnConnectionLost(function () {
	                                _logger.info('Connection Lost');
	                                events.emit('onconnectionlost', 'spider');
	                                onBrowserOffline();
	                            });

	                            _onlineEventAttached = true;
	                        }
	                        success();
	                        sendWSPing();
	                    };

	                    _ws.onclose = function (evt) {
	                        if(_wsPingTimeout){
	                            if (_autoReconnect && !_connectionLostTimeout) {
	                                window.console.log('connection closed');
	                                clearTimeout(_wsPingTimeout);
	                                autoReconnect();
	                            }

	                            if (_reconnectCount === 0) {
	                                events.emit('onconnectionlost', evt);
	                            }
	                        }
	                    };

	                    _ws.onerror = function (evt) {
	                        events.emit('onconnectionerror', evt);
	                    };

	                    _ws.onmessage = function (evt) {
	                        var message = JSON.parse(evt.data), callbacks, responseCallbacks, callbackItter, callbackLength;
	                        if (message.message_type === 'response') {
	                            responseCallbacks = _wsResponses[message.id];
	                            if (responseCallbacks) {
	                                delete _wsResponses[message.id];
	                                if (message.status === 0) {
	                                    if (responseCallbacks.success) {
	                                        responseCallbacks.success();
	                                    }
	                                }
	                                else {
	                                    if (responseCallbacks.failure) {
	                                        responseCallbacks.failure(message.message, message.status);
	                                    }
	                                }
	                            }
	                        } else {
	                            if (_wsEvents.hasOwnProperty(message.message_type)) {
	                                callbacks = _wsEvents[message.message_type];

	                                if (callbacks && callbacks.length > 0) {
	                                    callbackLength = callbacks.length;
	                                    for (callbackItter = 0; callbackItter < callbackLength; callbackItter++) {
	                                        if (typeof callbacks[callbackItter] === 'function') {
	                                            callbacks[callbackItter](message);
	                                        }
	                                    }

	                                }
	                            }
	                        }
	                    };
	                } else {
	                    failure('Error opening websocket', responseCodes.wsCreateError);
	                }
	            },
	            failure
	            );
	}

	/**
	 * The kandy namespace contains functions for basic features of Kandy. This includes setting up Kandy, logging in/out,
	 * and getter functions.
	 *
	 * @class kandy
	 * @static
	 */

	/**
	 * Prepare Kandy for use; setup configurations and listeners.
	 *
	 * @method setup
	 * @param {Object} config Configuration object used to set up Kandy.
	 * @param {HTMLElement} config.remoteVideoContainer Element that will be used as the container to the video of the remote party in a video call.
	 * @param {HTMLElement} config.localVideoContainer Element that will be used as the container to the video of the local party in a video call.
	 * @param {Object} config.listeners List of event listeners.
	 * @param {Boolean} config.autoreconnect Whether Kandy should autoreconnect if connection is lost.
	 * @param {Boolean} config.registerforcalls Whether the user should be registered for calls.
	 * @param {String} config.loglevel Log level to be set, ie. error/warn/info/debug.
	 * @param {Object} config.screenSharing Screensharing options.
	 * @param {String} config.screenSharing.chromeExtensionId Chrome extension ID for the extension to use to enable
	 *                                                        screen sharing. See the screensharing tutorial for more
	 *                                                        information.
	 * @example
	 * ``` javascript
	 * kandy.setup({
	 *     remoteVideoContainer: document.getElementById('remote-video');
	 *     localVideoContainer: document.getElementById('local-video');
	 *     listeners: {
	 *         callincoming: onCallIncoming
	 *     },
	 *     autoreconnect: true,
	 *     registerforcalls: true,
	 *     loglevel: 'debug'
	 * });
	 *
	 * function onCallIncoming(call) {...}
	 * ```
	 */
	api.setup = function (config) {
	    config = config || {};
	    // setup default configuration
	    _config = utils.extend(_config, config);

	    if (_config.screenSharing) {
	        _config.spidrMedia.screenSharing = utils.extend(_config.spidrMedia.screenSharing, config.screenSharing);
	    }

	    // setup listeners
	    if (config.listeners) {
	        for (var key in config.listeners) {
	            if (config.listeners.hasOwnProperty(key)) {
	                events.on(key, config.listeners[key]);
	            }
	        }
	    }

	    if (config.hasOwnProperty('autoreconnect')) {
	        _autoReconnect = config.autoreconnect;
	    }

	    if (config.hasOwnProperty('registerforcalls')) {
	        _registerForCalls = config.registerforcalls;
	    }


	    if (config.hasOwnProperty('loglevel')) {
	        _setLogLevel(config.loglevel);
	    }

	    if(_registerForCalls && _setupCall){
	        _setupCall(config);
	    }

	    if(config.hasOwnProperty('exposeFcs')) {
	        api._fcs = fcs;
	    }
	};

	function _getUserAccessToken (domainApiKey, username, userPassword, success, failure, options) {
	    // if username has domain in it remove it
	    username = username.split('@')[0];

	    _kandyRequest({
	        url: '/domains/users/accesstokens',
	        params: {
	            key: domainApiKey,
	            'user_id': username,
	            'user_password': userPassword,
	            'client_sw_version': options && options.client_sw_version,
	            'client_sw_type': options && options.client_sw_type,
	            'kandy_device_id': options && options.kandy_device_id
	        },
	        success: function (response) {
	            if (success) {
	                success(response.result);
	            }
	        },
	        failure: failure
	    });
	}

	/**
	 * Retrieves a user access token for a specified user.
	 *
	 * @method getUserAccessToken
	 * @async
	 * @param {String} domainApiKey The API key for the domain.
	 * @param {String} userName The name of the user.
	 * @param {String} userPassword The password of the user.
	 * @param {Function} success The success callback. It receives one parameter.
	 * @param {String} success.user_access_token The user access token.
	 * @param {Function} failure The failure callback. It receives no parameters.
	 * @param {Object} options Client information.
	 * @param {String} options.client_sw_version Software version.
	 * @param {String} options.client_sw_type Software type, 'JS/android/ios'.
	 * @param {String} options.kandy_device_id Device ID.
	 */
	api.getUserAccessToken = _getUserAccessToken;

	/**
	 * Retrieves details about a user for a specified user access token.
	 *
	 * @method getLimitedUserDetails
	 * @async
	 * @param {String} userAccessToken
	 * @param {Function} success The success callback. It receives one parameter.
	 * @param {User} success.user A User object corresponding to the provided user access token.
	 * @param {Function} failure The failure callback. It receives one parameter.
	 * @param {String} failure.errorMessage The error message explaining what failed.
	 */
	api.getLimitedUserDetails = function (userAccessToken, success, failure) {
	    _kandyRequest({
	        url: '/users/details/limited',
	        params: {
	            key: userAccessToken
	        },
	        success: function (response) {
	            if (success) {
	                success(response.result.user);
	            }
	        },
	        failure: failure
	    });
	};

	/**
	 * Retrieves devices associated with a user access token.
	 *
	 * @method getDevices
	 * @async
	 * @param {String} userAccessToken User Access Token.
	 * @param {Function} success The success callback. It receives one parameter.
	 * @param {Device[]} success.devices An array of device objects.
	 * @param {Function} failure The failure callback. It receives one parameter.
	 * @param {String} failure.errorMessage The error message explaining what failed.
	 * @example
	 * Here is an example of the result object given to the success callback.
	 * ``` javascript
	 *  {
	 *      devices: [
	 *          {
	 *              id: "8E2C0E50D19A45FABCD9F70ABB93AF80",
	 *              nativeID: "55555555555555",
	 *              family: "portal",
	 *              name: "portal",
	 *              osVersion: "6.6.5",
	 *              clientVersion: "1"
	 *          },
	 *          ...
	 *      ]
	 *  }
	 * ```
	 */
	api.getDevices = function (userAccessToken, success, failure) {
	    _kandyRequest({
	        url: '/users/devices',
	        params: {
	            key: userAccessToken
	        },
	        success: function (response) {
	            if (success) {
	                success(response.result);
	            }
	        },
	        failure: failure
	    });
	};

	/**
	 * Get last seen timestamps for the users passed in.
	 *
	 * @method getLastSeen
	 * @async
	 * @param {Array} users Array of users.
	 * @param {Function} success The success callback. It receives one parameter.
	 * @param {Object} success.result The result object.
	 * @param {Number} success.result.server_timestamp The current server timestamp.
	 * @param {Array} success.result.users The array of users and their last seen times.
	 * @param {String} success.result.users.full_user_id The user's full user ID.
	 * @param {Number} success.result.users.last_seen The unix timestamp of the last time the user was seen.
	 * @param {Function} failure The failure callback. It receives one parameter.
	 * @param {String} failure.errorMessage The error message explaining what failed.
	 * @example
	 * Here is an example of the result object given to the success callback.
	 * ``` javascript
	 *  {
	 *      server_timestamp: 1442340323747,
	 *      users: [
	 *          {
	 *              full_user_id: "user1@test.kandy.io",
	 *              last_seen: 1442337579648
	 *          },
	 *          ...
	 *      ]
	 *  }
	 * ```
	 */
	api.getLastSeen = function (users, success, failure) {
	    _kandyRequest({
	        url: '/users/presence/last_seen',
	        params: {
	            users: users
	        },
	        success: function (response) {
	            if (success) {
	                success(response.result);
	            }
	        },
	        failure: failure
	    });
	};

	/**
	 * Logs the user into Kandy.
	 *
	 * @method login
	 * @async
	 * @param {String} domainApiKey The API key of the user's domain.
	 * @param {String} userName The name of the user.
	 * @param {String} userPassword The password for the user.
	 * @param {Function} success The success callback. It receives one parameter.
	 * @param {String} success.user_access_token The logged-on user's access token.
	 * @param {Function} failure The failure callback. It receives no parameters.
	 */
	api.login = function (domainApiKey, userName, password, success, failure) {

	    // Pass through two parameters to the failure callback.
	    // REST v1.2 can pass two; REST v1.3 only passes one.
	    var failureFunction = function (error, ajaxError) {
	        _userDetails = null;
	        if(failure && typeof failure === 'function'){
	            failure(error, ajaxError);
	        }
	    };

	    // TODO: Rename these to camel case
	    var options = {
	        'client_sw_version': api.version,
	        'client_sw_type': 'JS',
	        'kandy_device_id': null
	    };

	    _getUserAccessToken(domainApiKey, userName, password,
	            function (result) {
	                var userAccessToken = result.user_access_token;

	                api.getLimitedUserDetails(userAccessToken,
	                        function (userDetailResult) {
	                            _userDetails = userDetailResult;
	                            _userDetails.userAccessToken = userAccessToken;
	                            openWebSocket(
	                                    //openWebSocket Success
	                                    function () {
	                                        _userDetails.devices = [];
	                                        api.getDevices(userAccessToken,
	                                            function (data) {
	                                                _userDetails.devices = data.devices;

	                                                if(_registerForCalls && _logInToSpidr){
	                                                    _logInToSpidr(function(){
	                                                            if(success){
	                                                                success(result);
	                                                            }
	                                                        },
	                                                        failureFunction,
	                                                        password
	                                                    );
	                                                } else {
	                                                    if(success){
	                                                        success(result);
	                                                    }
	                                                }
	                                            },
	                                            failureFunction
	                                        );
	                                    },
	                                    failureFunction
	                                    );
	                        },
	                        failureFunction
	                        );
	            },
	            failureFunction,
	            options
	            );

	};

	/**
	 * Gets the details for the current user.
	 *
	 * @method getUserDetails
	 * @return {Object} details User details object. This will return an empty object if the user is not logged in.
	 * @example
	 * ``` javascript
	 * {
	 *   fullUserId: "mistygreen@example.kandy.io",
	 *   domainName: "example.kandy.io",
	 *   userAccessToken: "UAT1bce9b65086c5de282f3fe28418dd347",
	 *   email: "mistygreen@example.kandy.io",
	 *   firstName: "Misty",
	 *   lastName: "Green",
	 *   userId: "mistygreen",
	 *   devices: [
	 *     clientVersion: "1",
	 *     family: "portal",
	 *     id: "49DE0134636142E585B0CC9F9BD7945F",
	 *     name: "portal",
	 *     nativeID: "55555555555555",
	 *     osVersion: "6.6.6"
	 *   ]
	 * }
	 * ```
	 */
	api.getUserDetails = function() {
	    if (!_userDetails) {
	        return {};
	    }

	    // This renames properties and excludes the password
	    return {
	        fullUserId: _userDetails.full_user_id,
	        domainName: _userDetails.domain_name,
	        userAccessToken: _userDetails.userAccessToken,
	        email: _userDetails.user_email,
	        firstName: _userDetails.user_first_name,
	        lastName: _userDetails.user_last_name,
	        userId: _userDetails.user_id,
	        devices: _userDetails.devices
	    };
	};

	/**
	 * Logs the user in with user access token (for single sign-on).
	 *
	 * @method loginSSO
	 * @async
	 * @param {String} userAccessToken User access token
	 * @param {Function} success The success callback. It receives one parameter.
	 * @param {Object} success.result The result object.
	 * @param {String} success.result.user_id The logged-on user's username.
	 * @param {String} success.result.full_user_id The logged-on username(username@domain).
	 * @param {String} success.result.user_access_token The logged-on user's user_access_token.
	 * @param {String} success.result.user_password The logged-on user's user_password.
	 * @param {String} success.result.domain_name The logged-on user's domain name.
	 * @param {Function} failure The failure callback. It receives no parameters.
	 * @param {String} password The user's password.
	 */
	api.loginSSO = function (userAccessToken, success, failure, password) {

	    var failureFunction = function () {
	        _userDetails = null;
	        if(failure && typeof failure === 'function'){
	            failure();
	        }
	    };

	    api.getLimitedUserDetails(userAccessToken,
	        function (result) {
	            _userDetails = result;
	            _userDetails.userAccessToken = userAccessToken;
	            openWebSocket(
	                    function () {
	                        _userDetails.devices = [];
	                        api.getDevices(userAccessToken,
	                            function (data) {
	                                _userDetails.devices = data.devices;

	                                if(_registerForCalls && _logInToSpidr){
	                                    _logInToSpidr(function(){
	                                            if(success){
	                                                success(result);
	                                            }
	                                        },
	                                        failureFunction,
	                                        password
	                                    );
	                                } else {
	                                    if(success){
	                                        success(result);
	                                    }
	                                }
	                            },
	                            failureFunction
	                        );
	                    },
	                    failureFunction);
	        },
	        failureFunction
	    );


	};

	/**
	 * Logs the user out of Kandy.

	 * @method logout
	 * @param {Function} success The success callback. It receives no parameters.
	 */
	api.logout = function (success) {
	    closeWebSocket();
	    _logOutOfSpidr(success);
	};

	/*
	 * Reconnect the user to the previously connected websocket.
	 *
	 * @method reconnect
	 * @param {Function} success The success callback. It receives no parameters.
	 * @param {Function} failure The failure callback. It receives no parameters.
	 * @deprecated
	 */
	api.reconnect = function (success, failure) {
	    _logger.warn('Deprecated method KandyAPI.reconnet.');
	    openWebSocket(success, failure);
	};

	/**
	 * The Session namespace provides functionality for using sessions. It allows for creation and management of a session,
	 * retrieval of information about sessions, user management for a session, and sending data over the session.
	 *
	 * @class session
	 * @namespace kandy
	 * @static
	 */
	api.Session = api.session = (function () {
	    var me = {};

	    /*
	     * Initialize the listeners object.
	     */
	    var _listeners = {
	    };

	    /*
	     * Forwards messages to the appropriate session handler.
	     *
	     * @method _messageHandler
	     */
	    var _messageHandler = function (message) {
	        var simpleType, sessionListeners, sessionListener, listenerCount, listenerItter = 0;

	        if (message.message_type === 'sessionNotification') {
	            message = message.payload;
	        }

	        _logger.debug('Session message recvd: ' + message.message_type);
	        simpleType = message.message_type.replace(/^session/, 'on');
	        sessionListeners = _listeners[message.session_id];

	        if (sessionListeners) {
	            var listnerCount = sessionListeners.length;

	            for (listenerItter; listenerItter < listnerCount; listenerItter++) {
	                sessionListener = sessionListeners[listenerItter];
	                if (sessionListener && sessionListener.hasOwnProperty(simpleType)) {
	                    try {
	                        sessionListener[simpleType](message);
	                    } catch (e) {
	                        _logger.error('could not execute listener: ' + e);
	                    }
	                }
	            }
	        }
	    };

	    /*
	     * Register session related listeners with the websocket.
	     */
	    registerWebSocketListeners({
	        'sessionData': _messageHandler,
	        'sessionNotification': _messageHandler
	    });


	    /**
	     * Registers listeners for events.
	     *
	     * @method setListeners
	     * @param {String} sessionId Id of the session to listen on.
	     * @param {Object} listeners Set of listeners be to set up.
	     * @param {Function} listeners.onData Fired when a participant sends data with sendData().
	     * @param {Function} listeners.onActive Fired when a session is activated.
	     * @param {Function} listeners.onUserJoinRequest Fired when a participant sends a join request for a session.
	     * @param {Function} listeners.onUserJoin Fired when a participant joins a session.
	     * @param {Function} listeners.onJoinApprove Fired when a participant's join request has been approved.
	     * @param {Function} listeners.onJoinReject Fired when a participant's join request has been rejected.
	     * @param {Function} listeners.onUserLeave Fired when a participant leaves a session.
	     * @param {Function} listeners.onUserBoot Fired when a participant is booted by an admin.
	     * @param {Function} listeners.onBoot Fired when a participant is booted by an admin.
	     * @param {Function} listeners.onInactive Fired when a session is inactivated.
	     * @param {Function} listeners.onTermination Fired when a session is terminated.
	     * @example
	     * ``` javascript
	     *     var sessionId = "b39ba65691af47bba43c6e19b6d334d3";
	     *     kandy.session.setListeners(sessionId, {
	     *         onData: function(data) {...}
	     *     });
	     * ```
	     */
	    me.setListeners = function (sessionId, listeners) {

	        if (_listeners[sessionId] === undefined) {
	            _listeners[sessionId] = [];
	        }

	        _listeners[sessionId].push(listeners);
	    };

	    /**
	     * Fired when a participant sends data with sendData(). This is received by
	     * all participants except the sender. The only exception is that if a
	     * particular user is given to sendData() then only that participant will
	     * receive it.
	     *
	     * @event onData
	     * @param {Object} data Data object containing message details.
	     * @param {String} data.id Unique id for the message.
	     * @param {String} data.session_id Id of the session from which the message came.
	     * @param {String} data.message_type Type of the message
	     * @param {String} data.source The full user id of the participant who sent the message.
	     * @param {Object} data.payload The payload of the message.
	     * @example
	     * Here is an example of a data message
	     * ``` javascript
	     *     {
	     *         id: "D262619D-DD81-4549-BAEA-368B8DBFCDF5",
	     *         session_id: "b39ba65691af47bba43c6e19b6d334d3",
	     *         message_type: "sessionData",
	     *         source: "robinsummers@jltest.kandy.io",
	     *         payload: {...}
	     *     }
	     * ```
	     */

	    /**
	     * Fired when a session is activated. This is received by all participants.
	     *
	     * @event onActive
	     * @param {Object} data Data object containing message details.
	     * @param {String} data.message_type Type of the message
	     * @param {String} data.session_id Id of the session from which the message came.
	     * @example
	     * Here is an example of a data message
	     * ``` javascript
	     *  {
	     *      message_type: "sessionActive",
	     *      session_id: "b39ba65691af47bba43c6e19b6d334d3"
	     *  }
	     * ```
	     */

	    /**
	     * Fired when a participant sends a join request for a session. Only administrators
	     * of the session will receive this event.
	     *
	     * @event onUserJoinRequest
	     * @param {Object} data Data object containing message details.
	     * @param {String} data.message_type Type of the message
	     * @param {String} data.session_id Id of the session from which the message came.
	     * @param {String} data.full_user_id The full user id for the participant.
	     * @example
	     * Here is an example of a data message
	     * ``` javascript
	     *  {
	     *      message_type: "sessionUserJoinRequest",
	     *      session_id: "b39ba65691af47bba43c6e19b6d334d3",
	     *      full_user_id: "username1@test.kandy.io"
	     *  }
	     * ```
	     */

	    /**
	     * Fired when a participant joins a session. This is received by all participants.
	     *
	     * @event onUserJoin
	     * @param {Object} data Data object containing message details.
	     * @param {String} data.message_type Type of the message
	     * @param {String} data.session_id Id of the session from which the message came.
	     * @param {String} data.full_user_id The full user id for the participant.
	     * @example
	     * Here is an example of a data message
	     * ``` javascript
	     *  {
	     *      message_type: "sessionUserJoin",
	     *      session_id: "b39ba65691af47bba43c6e19b6d334d3",
	     *      full_user_id: "username1@test.kandy.io"
	     *  }
	     * ```
	     */

	    /**
	     * Fired when a participant's join request has been approved. This is received
	     * by the participant who made the request.
	     *
	     * @event onJoinApprove
	     * @param {Object} data Data object containing message details.
	     * @param {String} data.message_type Type of the message
	     * @param {String} data.session_id Id of the session from which the message came.
	     * @example
	     * Here is an example of a data message
	     * ``` javascript
	     *  {
	     *      message_type: "sessionJoinApprove",
	     *      session_id: "b39ba65691af47bba43c6e19b6d334d3"
	     *  }
	     * ```
	     */

	    /**
	     * Fired when a participant's join request has been rejected. This is received
	     * by the participant who made the request.
	     *
	     * @event onJoinReject
	     * @param {Object} data Data object containing message details.
	     * @param {String} data.message_type Type of the message
	     * @param {String} data.session_id Id of the session from which the message came.
	     * @param {String} data.reject_reason The reason given by the admin who rejected the request.
	     * @example
	     * Here is an example of a data message
	     * ``` javascript
	     *  {
	     *      message_type: "sessionJoinApprove",
	     *      session_id: "b39ba65691af47bba43c6e19b6d334d3",
	     *      reject_reason: "A well thought out reason"
	     *  }
	     * ```
	     */

	    /**
	     * Fired when a participant leaves a session. This is received by all of
	     * the participants in the session.
	     *
	     * @event onUserLeave
	     * @param {Object} data Data object containing message details.
	     * @param {String} data.message_type Type of the message
	     * @param {String} data.session_id Id of the session from which the message came.
	     * @param {String} data.reject_reason The reason given by the admin who rejected the request.
	     * @param {String} data.full_user_id The full user id for the participant.
	     * @example
	     * Here is an example of a data message
	     * ``` javascript
	     *  {
	     *      message_type: "sessionJoinApprove",
	     *      session_id: "b39ba65691af47bba43c6e19b6d334d3",
	     *      full_user_id: "username1@test.kandy.io",
	     *      leave_reason: "A well thought out reason"
	     *  }
	     * ```
	     */

	    /**
	     * Fired when a participant is booted by an admin. This is received
	     * all participants except the participant that was booted.
	     *
	     * @event onUserBoot
	     * @param {Object} data Data object containing message details.
	     * @param {String} data.message_type Type of the message
	     * @param {String} data.session_id Id of the session from which the message came.
	     * @param {String} data.reject_reason The reason given by the admin who rejected the request.
	     * @param {String} data.full_user_id The full user id for the participant.
	     * @example
	     * Here is an example of a data message
	     * ``` javascript
	     *  {
	     *      message_type: "sessionUserBoot",
	     *      session_id: "b39ba65691af47bba43c6e19b6d334d3",
	     *      full_user_id: "username1@test.kandy.io",
	     *      leave_reason: "A well thought out reason"
	     *  }
	     * ```
	     */

	    /**
	     * Fired when a participant is booted by an admin. This is only received
	     * by booted participant.
	     *
	     * @event onBoot
	     * @param {Object} data Data object containing message details.
	     * @param {String} data.message_type Type of the message
	     * @param {String} data.session_id Id of the session from which the message came.
	     * @param {String} data.reject_reason The reason given by the admin who rejected the request.
	     * @example
	     * Here is an example of a data message
	     * ``` javascript
	     *  {
	     *      message_type: "sessionBoot",
	     *      session_id: "b39ba65691af47bba43c6e19b6d334d3",
	     *      boot_reason: "A well thought out reason"
	     *  }
	     * ```
	     */

	    /**
	     * Fired when a session is inactivated. This is received by all participants.
	     *
	     * @event onInactive
	     * @param {Object} data Data object containing message details.
	     * @param {String} data.message_type Type of the message
	     * @param {String} data.session_id Id of the session from which the message came.
	     * @param {String} data.reject_reason The reason given by the admin who rejected the request.
	     * @example
	     * Here is an example of a data message
	     * ``` javascript
	     *  {
	     *      message_type: "sessionInactive",
	     *      session_id: "b39ba65691af47bba43c6e19b6d334d3"
	     *  }
	     * ```
	     */

	    /**
	     * Fired when a session is terminated. This is received by all participants.
	     *
	     * @event onTermination
	     * @param {Object} data Data object containing message details.
	     * @param {String} data.message_type Type of the message
	     * @param {String} data.session_id Id of the session from which the message came.
	     * @example
	     * Here is an example of a data message
	     * ``` javascript
	     *  {
	     *      message_type: "sessionTermination",
	     *      session_id: "b39ba65691af47bba43c6e19b6d334d3"
	     *  }
	     * ```
	     */

	    /**
	     * Creates a session using specified configurations. The user that creates a session is the
	     * session administrator. A newly created session is inactive by default.
	     *
	     * @method create
	     * @param {Object} sessionConfig Configuration object used for creating the session.
	     * @param {String} sessionConfig.session_type Type of session to be created. Session type is not restricted in its value; it can be defined as need be.
	     * @param {String} sessionConfig.session_name Name of the session to be created.
	     * @param {String} sessionConfig.session_description Description of the session to be created.
	     * @param {String} sessionConfig.user_nickname Nickname of the user creating the session.
	     * @param {String} sessionConfig.user_first_name First name of the user creating the session.
	     * @param {String} sessionConfig.user_last_name Last name of the user creating the session.
	     * @param {String} sessionConfig.user_phone_number Phone number of the user creating the session.
	     * @param {String} sessionConfig.user_email Email of the user creating the session.
	     * @param {Function} success The success callback. It receives one parameter.
	     * @param {Object} success.result The result object.
	     * @param {String} success.result.session_id The session ID of the created session.
	     * @param {Function} failure The failure callback. It receives one parameter.
	     * @param {String} failure.errorMessage The error message explaining what failed.
	     */
	    me.create = function (sessionConfig, success, failure) {
	        _kandyRequest({
	            type: 'POST',
	            url: '/users/sessions/session',
	            data: sessionConfig,
	            success: function (response) {
	                if (success) {
	                    success(response.result);
	                }
	            },
	            failure: failure
	        });
	    };

	    /**
	     * Activates an existing session, allowing for data to be sent to all users.
	     * Only the session administrator can activate the session.
	     *
	     * @method activate
	     * @param {String} sessionId Id of the session to be activated.
	     * @param {Function} success The success callback. It receives no parameters.
	     * @param {Function} failure The failure callback. It receives one parameter.
	     * @param {String} failure.errorMessage The error message explaining what failed.
	     */
	    me.activate = function (sessionId, success, failure) {
	        _kandyRequest({
	            type: 'POST',
	            url: '/users/sessions/session/id/start',
	            data: {
	                'session_id': sessionId
	            },
	            success: function (response) {
	                if (success) {
	                    success();
	                }
	            },
	            failure: failure
	        });
	    };

	    /**
	     * Inactivates an existing session, preventing data being sent to all users.
	     * Only the session administrator can inactivate the session.
	     *
	     * @method inactivate
	     * @param {String} sessionId Id of the session to be activated.
	     * @param {Function} success The success callback. It receives no parameters.
	     * @param {Function} failure The failure callback. It receives one parameter.
	     * @param {String} failure.errorMessage The error message explaining what failed.
	     */
	    me.inactivate = function (sessionId, success, failure) {
	        _kandyRequest({
	            type: 'POST',
	            url: '/users/sessions/session/id/stop',
	            data: {
	                'session_id': sessionId
	            },
	            success: function (response) {
	                if (success) {
	                    success();
	                }
	            },
	            failure: failure
	        });
	    };

	    /**
	     * Sends data to session users. Requires the session to be active.
	     *
	     * @method sendData
	     * @param {String} sessionId Id of session to send data through.
	     * @param {Object} data Data to be sent to the session users.
	     * @param {function} [success] success Function called when the data is sent successfully.
	     * @param {function} [failure] failure Function called when an error occurs while sending data.
	     * @param {String} [destination] Full user id for the destination (if none provided, sends to all users).
	     */
	    me.sendData = function (sessionId, data, success, failure, destination) {
	        sendWebSocketData({
	            'message_type': 'sessionData',
	            'session_id': sessionId,
	            destination: destination,
	            payload: data
	        }, success, failure);
	    };

	    /**
	     * Terminates an existing session. Only the session administrator can terminate the session.
	     *
	     * @method terminate
	     * @param {String} sessionId Id of session to delete.
	     * @param {Function} success The success callback. It receives no parameters.
	     * @param {Function} failure The failure callback. It receives one parameter.
	     * @param {String} failure.errorMessage The error message explaining what failed.
	     */
	    me.terminate = function (sessionId, success, failure) {
	        _kandyRequest({
	            type: 'DELETE',
	            url: '/users/sessions/session/id',
	            data: {
	                'session_id': sessionId
	            },
	            success: function (response) {
	                if (success) {
	                    success();
	                }
	            },
	            failure: failure
	        });
	    };

	    /**
	     * Gets session details for a given session Id.
	     *
	     * @method getSessionInfoById
	     * @param {String} sessionId Id of session for which to get info.
	     * @param {Function} success The success callback. It receives one parameter.
	     * @param {Object} success.result Information about the session.
	     * @param {String} success.result.session_id The session ID.
	     * @param {String} success.result.session_name The name of the session.
	     * @param {String} success.result.session_status The status of the session.
	     * @param {String} success.result.session_type The type of the session.
	     * @param {String} success.result.session_description The description of the session.
	     * @param {String} success.result.admin_full_user_id The full user ID of the admin of the session.
	     * @param {Number} success.result.creation_timestamp The time at which the session was created.
	     * @param {String} success.result.domain_name The domain name of the session.
	     * @param {Number} success.result.expiry_timestamp The expiry time of the session.
	     * @param {Array} success.result.participants The list of participants in the session.
	     * @param {Array} success.result.participants.full_user_id The full user ID of the participant.
	     * @param {Array} success.result.participants.profile The profile of the participant.
	     * @param {Array} success.result.participants.status The status of the participant.
	     * @param {Array} success.result.participants.type The type of the participant.
	     * @param {Array} success.result.participants.status The status of the participant.
	     * @param {Array} success.result.participants.user_email The email of the participant.
	     * @param {Array} success.result.participants.user_first_name The first name of the participant.
	     * @param {Array} success.result.participants.user_last_name The last name of the participant.
	     * @param {Array} success.result.participants.user_nickname The nickname of the participant.
	     * @param {Array} success.result.participants.user_phone_number The phone number of the participant.
	     * @param {Function} failure The failure callback. It receives one parameter.
	     * @param {String} failure.errorMessage The error message explaining what failed.
	     * @example
	     * Here is an example of the result.
	     * ``` javascript
	     *  {
	     *      session_id: "70efdb80a067439481f7dbfb99619a78",
	     *      session_name: "Session Name",
	     *      session_status: "inactive",
	     *      session_type: "Sesstion Type",
	     *      session_description: "A description of the session",
	     *      admin_full_user_id: "user1@test.kandy.io",
	     *      creation_timestamp: 1440598570170,
	     *      domain_name: "test.kandy.io",
	     *      expiry_timestamp: 981003600000,
	     *      participants: [
	     *          {
	     *              full_user_id: "user1@test.kandy.io",
	     *              profile: "registered",
	     *              status: "approved",
	     *              type: "admin",
	     *              user_email: "user1@test.kandy.io",
	     *              user_first_name: "User",
	     *              user_last_name: "One",
	     *              user_nickname: "Onesie",
	     *              user_phone_number: "1111111111"
	     *          },
	     *          ...
	     *      ]
	     *  }
	     * ```
	     */
	    me.getInfoById = function (sessionId, success, failure) {
	        _kandyRequest({
	            url: '/users/sessions/session/id',
	            params: {
	                'session_id': sessionId
	            },
	            success: function (response) {
	                if (success) {
	                    success(response.result);
	                }
	            },
	            failure: failure
	        });
	    };

	    /**
	     * Gets session details with a given a session name.
	     *
	     * @method getSessionInfoByName
	     * @param {String} sessionName Name of session for which to get info.
	     * @param {Function} success The success callback. It receives one parameter.
	     * @param {Object} success.result Information about the session.
	     * @param {String} success.result.session_id The session ID.
	     * @param {String} success.result.session_name The name of the session.
	     * @param {String} success.result.session_status The status of the session.
	     * @param {String} success.result.session_type The type of the session.
	     * @param {String} success.result.session_description The description of the session.
	     * @param {String} success.result.admin_full_user_id The full user ID of the admin of the session.
	     * @param {Number} success.result.creation_timestamp The time at which the session was created.
	     * @param {String} success.result.domain_name The domain name of the session.
	     * @param {Number} success.result.expiry_timestamp The expiry time of the session.
	     * @param {Array} success.result.participants The list of participants in the session.
	     * @param {Array} success.result.participants.full_user_id The full user ID of the participant.
	     * @param {Array} success.result.participants.profile The profile of the participant.
	     * @param {Array} success.result.participants.status The status of the participant.
	     * @param {Array} success.result.participants.type The type of the participant.
	     * @param {Array} success.result.participants.status The status of the participant.
	     * @param {Array} success.result.participants.user_email The email of the participant.
	     * @param {Array} success.result.participants.user_first_name The first name of the participant.
	     * @param {Array} success.result.participants.user_last_name The last name of the participant.
	     * @param {Array} success.result.participants.user_nickname The nickname of the participant.
	     * @param {Array} success.result.participants.user_phone_number The phone number of the participant.
	     * @param {Function} failure The failure callback. It receives one parameter.
	     * @param {String} failure.errorMessage The error message explaining what failed.
	     * @example
	     * Here is an example of the result.
	     * ``` javascript
	     *  {
	     *      session_id: "70efdb80a067439481f7dbfb99619a78",
	     *      session_name: "Session Name",
	     *      session_status: "inactive",
	     *      session_type: "Sesstion Type",
	     *      session_description: "A description of the session",
	     *      admin_full_user_id: "user1@test.kandy.io",
	     *      creation_timestamp: 1440598570170,
	     *      domain_name: "test.kandy.io",
	     *      expiry_timestamp: 981003600000,
	     *      participants: [
	     *          {
	     *              full_user_id: "user1@test.kandy.io",
	     *              profile: "registered",
	     *              status: "approved",
	     *              type: "admin",
	     *              user_email: "user1@test.kandy.io",
	     *              user_first_name: "User",
	     *              user_last_name: "One",
	     *              user_nickname: "Onesie",
	     *              user_phone_number: "1111111111"
	     *          },
	     *          ...
	     *      ]
	     *  }
	     * ```
	     */
	    me.getInfoByName = function (sessionName, success, failure) {
	        _kandyRequest({
	            url: '/users/sessions/session/name',
	            params: {
	                'session_name': sessionName
	            },
	            success: function (response) {
	                if (success) {
	                    success(response.result);
	                }
	            },
	            failure: failure
	        });
	    };

	    /**
	     * Gets a list of all open sessions.
	     *
	     * @method getOpenSessions
	     * @param {Function} success The success callback. It receives one parameter.
	     * @param {Object} success.result Information about the session.
	     * @param {Array} success.result.sessions The list of sessions.
	     * @param {String} success.result.sessions.session_id The session ID.
	     * @param {String} success.result.sessions.session_name The name of the session.
	     * @param {String} success.result.sessions.session_status The status of the session.
	     * @param {String} success.result.sessions.session_type The type of the session.
	     * @param {String} success.result.sessions.session_description The description of the session.
	     * @param {String} success.result.sessions.admin_full_user_id The full user ID of the admin of the session.
	     * @param {Number} success.result.sessions.creation_timestamp The time at which the session was created.
	     * @param {String} success.result.sessions.domain_name The domain name of the session.
	     * @param {Number} success.result.sessions.expiry_timestamp The expiry time of the session.
	     * @param {Array} success.result.sessions.participants The list of participants in the session.
	     * @param {Array} success.result.sessions.participants.full_user_id The full user ID of the participant.
	     * @param {Array} success.result.sessions.participants.profile The profile of the participant.
	     * @param {Array} success.result.sessions.participants.status The status of the participant.
	     * @param {Array} success.result.sessions.participants.type The type of the participant.
	     * @param {Array} success.result.sessions.participants.status The status of the participant.
	     * @param {Array} success.result.sessions.participants.user_email The email of the participant.
	     * @param {Array} success.result.sessions.participants.user_first_name The first name of the participant.
	     * @param {Array} success.result.sessions.participants.user_last_name The last name of the participant.
	     * @param {Array} success.result.sessions.participants.user_nickname The nickname of the participant.
	     * @param {Array} success.result.sessions.participants.user_phone_number The phone number of the participant.
	     * @param {Function} failure The failure callback. It receives one parameter.
	     * @param {String} failure.errorMessage The error message explaining what failed.
	     * @example
	     * Here is an example of the result.
	     * ``` javascript
	     *  {
	     *      sessions: [
	     *          {
	     *              session_id: "70efdb80a067439481f7dbfb99619a78",
	     *              session_name: "Session Name",
	     *              session_status: "inactive",
	     *              session_type: "Sesstion Type",
	     *              session_description: "A description of the session",
	     *              admin_full_user_id: "user1@test.kandy.io",
	     *              creation_timestamp: 1440598570170,
	     *              domain_name: "test.kandy.io",
	     *              expiry_timestamp: 981003600000,
	     *              participants: [
	     *                  {
	     *                      full_user_id: "user1@test.kandy.io",
	     *                      profile: "registered",
	     *                      status: "approved",
	     *                      type: "admin",
	     *                      user_email: "user1@test.kandy.io",
	     *                      user_first_name: "User",
	     *                      user_last_name: "One",
	     *                      user_nickname: "Onesie",
	     *                      user_phone_number: "1111111111"
	     *                  },
	     *                  ...
	     *              ]
	     *          }
	     *      ]
	     * }
	     * ```
	     */
	    me.getOpenSessions = function (success, failure) {
	        _kandyRequest({
	            url: '/users/sessions',
	            success: function (response) {
	                if (success) {
	                    success(response.result);
	                }
	            },
	            failure: failure
	        });
	    };

	    /**
	     * Gets a list of open sessions with a given session type.
	     *
	     * @method getOpenSessionsByType
	     * @param {String} sessionType Type of session for which to search.
	     * @param {Function} success The success callback. It receives one parameter.
	     * @param {Object} success.result Information about the session.
	     * @param {Array} success.result.sessions The list of sessions.
	     * @param {String} success.result.sessions.session_id The session ID.
	     * @param {String} success.result.sessions.session_name The name of the session.
	     * @param {String} success.result.sessions.session_status The status of the session.
	     * @param {String} success.result.sessions.session_type The type of the session.
	     * @param {String} success.result.sessions.session_description The description of the session.
	     * @param {String} success.result.sessions.admin_full_user_id The full user ID of the admin of the session.
	     * @param {Number} success.result.sessions.creation_timestamp The time at which the session was created.
	     * @param {String} success.result.sessions.domain_name The domain name of the session.
	     * @param {Number} success.result.sessions.expiry_timestamp The expiry time of the session.
	     * @param {Array} success.result.sessions.participants The list of participants in the session.
	     * @param {Array} success.result.sessions.participants.full_user_id The full user ID of the participant.
	     * @param {Array} success.result.sessions.participants.profile The profile of the participant.
	     * @param {Array} success.result.sessions.participants.status The status of the participant.
	     * @param {Array} success.result.sessions.participants.type The type of the participant.
	     * @param {Array} success.result.sessions.participants.status The status of the participant.
	     * @param {Array} success.result.sessions.participants.user_email The email of the participant.
	     * @param {Array} success.result.sessions.participants.user_first_name The first name of the participant.
	     * @param {Array} success.result.sessions.participants.user_last_name The last name of the participant.
	     * @param {Array} success.result.sessions.participants.user_nickname The nickname of the participant.
	     * @param {Array} success.result.sessions.participants.user_phone_number The phone number of the participant.
	     * @param {Function} failure The failure callback. It receives one parameter.
	     * @param {String} failure.errorMessage The error message explaining what failed.
	     * @example
	     * Here is an example of the result.
	     * ``` javascript
	     *  {
	     *      sessions: [
	     *          {
	     *              session_id: "70efdb80a067439481f7dbfb99619a78",
	     *              session_name: "Session Name",
	     *              session_status: "inactive",
	     *              session_type: "Sesstion Type",
	     *              session_description: "A description of the session",
	     *              admin_full_user_id: "user1@test.kandy.io",
	     *              creation_timestamp: 1440598570170,
	     *              domain_name: "test.kandy.io",
	     *              expiry_timestamp: 981003600000,
	     *              participants: [
	     *                  {
	     *                      full_user_id: "user1@test.kandy.io",
	     *                      profile: "registered",
	     *                      status: "approved",
	     *                      type: "admin",
	     *                      user_email: "user1@test.kandy.io",
	     *                      user_first_name: "User",
	     *                      user_last_name: "One",
	     *                      user_nickname: "Onesie",
	     *                      user_phone_number: "1111111111"
	     *                  },
	     *                  ...
	     *              ]
	     *          }
	     *      ]
	     * }
	     * ```
	     */
	    me.getOpenSessionsByType = function (sessionType, success, failure) {
	        _kandyRequest({
	            url: '/users/sessions/type',
	            params: {
	                'session_type': sessionType
	            },
	            success: function (response) {
	                if (success) {
	                    success(response.result);
	                }
	            },
	            failure: failure
	        });
	    };

	    /**
	     * Gets a list of sessions created by the current user.
	     *
	     * @method getOpenSessionsCreatedByUser
	     * @param {Function} success The success callback. It receives one parameter.
	     * @param {Object} success.result Information about the session.
	     * @param {Array} success.result.sessions The list of sessions.
	     * @param {String} success.result.sessions.session_id The session ID.
	     * @param {String} success.result.sessions.session_name The name of the session.
	     * @param {String} success.result.sessions.session_status The status of the session.
	     * @param {String} success.result.sessions.session_type The type of the session.
	     * @param {String} success.result.sessions.session_description The description of the session.
	     * @param {String} success.result.sessions.admin_full_user_id The full user ID of the admin of the session.
	     * @param {Number} success.result.sessions.creation_timestamp The time at which the session was created.
	     * @param {String} success.result.sessions.domain_name The domain name of the session.
	     * @param {Number} success.result.sessions.expiry_timestamp The expiry time of the session.
	     * @param {Array} success.result.sessions.participants The list of participants in the session.
	     * @param {Array} success.result.sessions.participants.full_user_id The full user ID of the participant.
	     * @param {Array} success.result.sessions.participants.profile The profile of the participant.
	     * @param {Array} success.result.sessions.participants.status The status of the participant.
	     * @param {Array} success.result.sessions.participants.type The type of the participant.
	     * @param {Array} success.result.sessions.participants.status The status of the participant.
	     * @param {Array} success.result.sessions.participants.user_email The email of the participant.
	     * @param {Array} success.result.sessions.participants.user_first_name The first name of the participant.
	     * @param {Array} success.result.sessions.participants.user_last_name The last name of the participant.
	     * @param {Array} success.result.sessions.participants.user_nickname The nickname of the participant.
	     * @param {Array} success.result.sessions.participants.user_phone_number The phone number of the participant.
	     * @param {Function} failure The failure callback. It receives one parameter.
	     * @param {String} failure.errorMessage The error message explaining what failed.
	     * @example
	     * Here is an example of the result.
	     * ``` javascript
	     *  {
	     *      sessions: [
	     *          {
	     *              session_id: "70efdb80a067439481f7dbfb99619a78",
	     *              session_name: "Session Name",
	     *              session_status: "inactive",
	     *              session_type: "Sesstion Type",
	     *              session_description: "A description of the session",
	     *              admin_full_user_id: "user1@test.kandy.io",
	     *              creation_timestamp: 1440598570170,
	     *              domain_name: "test.kandy.io",
	     *              expiry_timestamp: 981003600000,
	     *              participants: [
	     *                  {
	     *                      full_user_id: "user1@test.kandy.io",
	     *                      profile: "registered",
	     *                      status: "approved",
	     *                      type: "admin",
	     *                      user_email: "user1@test.kandy.io",
	     *                      user_first_name: "User",
	     *                      user_last_name: "One",
	     *                      user_nickname: "Onesie",
	     *                      user_phone_number: "1111111111"
	     *                  },
	     *                  ...
	     *              ]
	     *          }
	     *      ]
	     * }
	     * ```
	     */
	    me.getOpenSessionsCreatedByUser = function (success, failure) {
	        _kandyRequest({
	            url: '/users/sessions/user',
	            success: function (response) {
	                if (success) {
	                    success(response.result);
	                }
	            },
	            failure: failure
	        });
	    };

	    /**
	     * Requests permission from the session administrator to join a session with a given Id.
	     *
	     * @method join
	     * @param {String} sessionId Id of the session to requeset to join.
	     * @param {Object} userInfo Extra, optional, user info that will be visisble in session information.
	     * @param {String} userInfo.user_email The user's email.
	     * @param {String} userInfo.user_first_name The user's first name.
	     * @param {String} userInfo.user_last_name The user's last name.
	     * @param {String} userInfo.user_nickname The user's nickname.
	     * @param {String} userInfo.user_phone_number The user's phone number.
	     * @param {Function} success The success callback. It receives no parameters.
	     * @param {Function} failure The failure callback. It receives one parameter.
	     * @param {String} failure.errorMessage The error message explaining what failed.
	     */
	    me.join = function (sessionId, userInfo, success, failure) {
	        var params = userInfo || {};
	        params.session_id = sessionId;

	        _kandyRequest({
	            type: 'POST',
	            url: '/users/sessions/session/id/participants/participant',
	            data: params,
	            success: function (response) {
	                if (success) {
	                    success(response.result);
	                }
	            },
	            failure: failure
	        });
	    };

	    /**
	     * Removes the current user from a session.
	     *
	     * @method leave
	     * @param {String} sessionId Id of the session to leave.
	     * @param {String} leaveReason Reason why we are leaving the session.
	     * @param {Function} success The success callback. It receives no parameters.
	     * @param {Function} failure The failure callback. It receives one parameter.
	     * @param {String} failure.errorMessage The error message explaining what failed.
	     */
	    me.leave = function (sessionId, leaveReason, success, failure) {
	        _kandyRequest({
	            type: 'DELETE',
	            url: '/users/sessions/session/id/participants/participant',
	            data: {
	                'session_id': sessionId,
	                'leave_reason': leaveReason
	            },
	            success: function (response) {
	                if (success) {
	                    success();
	                }
	            },
	            failure: failure
	        });
	    };

	    /**
	     * Accepts a join request for a session. Only the session administrator can accept join requests.
	     *
	     * @method acceptJoinRequest
	     * @param {String} sessionId Id of session the user is requesting to join.
	     * @param {String} fullUserId Full user Id of the user sending the join request.
	     * @param {Function} success The success callback. It receives no parameters.
	     * @param {Function} failure The failure callback. It receives one parameter.
	     * @param {String} failure.errorMessage The error message explaining what failed.
	     */
	    me.acceptJoinRequest = function (sessionId, fullUserId, success, failure) {

	        _kandyRequest({
	            type: 'POST',
	            url: '/users/sessions/session/id/admin/participants/participant/join',
	            data: {
	                'session_id': sessionId,
	                'full_user_id': fullUserId
	            },
	            success: function (response) {
	                if (success) {
	                    success();
	                }
	            },
	            failure: failure
	        });
	    };

	    /**
	     * Rejects a join request for a session. Only the session administrator can reject join requests.
	     *
	     * @method rejectJoinRequest
	     * @param {String} sessionId Session Id of the join request.
	     * @param {String} Full user Id of the user sending the join request.
	     * @param {String} rejectReason Reason for rejecting the join request.
	     * @param {Function} success The success callback. It receives no parameters.
	     * @param {Function} failure The failure callback. It receives one parameter.
	     * @param {String} failure.errorMessage The error message explaining what failed.
	     */
	    me.rejectJoinRequest = function (sessionId, fullUserId, rejectReason, success, failure) {
	        _kandyRequest({
	            type: 'DELETE',
	            url: '/users/sessions/session/id/admin/participants/participant/join',
	            data: {
	                'session_id': sessionId,
	                'full_user_id': fullUserId,
	                'reject_reason': rejectReason
	            },
	            success: function (response) {
	                if (success) {
	                    success();
	                }
	            },
	            failure: failure
	        });
	    };

	    /**
	     * Removes a user from the session. Only the session administrator can boot a user.
	     *
	     * @method bootUser
	     * @param {String} sessionId Session Id of the session the user should be removed from.
	     * @param {String} fullUserId Full user Id of the user to be removed.
	     * @param {String} bootReason Reason for removing the user.
	     * @param {Function} success The success callback. It receives no parameters.
	     * @param {Function} failure The failure callback. It receives one parameter.
	     * @param {String} failure.errorMessage The error message explaining what failed.
	     */
	    me.bootUser = function (sessionId, fullUserId, bootReason, success, failure) {

	        _kandyRequest({
	            type: 'DELETE',
	            url: '/users/sessions/session/id/admin/participants/participant',
	            data: {
	                'session_id': sessionId,
	                'full_user_id': fullUserId,
	                'boot_reason': bootReason
	            },
	            success: function (response) {
	                if (success) {
	                    success();
	                }
	            },
	            failure: failure
	        });
	    };

	    return me;
	}());

	/* eslint-disable no-use-before-define */
	// Override the above rule, since that would be refactoring in this case.

	/**
	 * CoBrowsing is used to share a webpage from one user to multiple users. Allows for a user to start and stop sending their webpage, and for users (called Agents herein) to start and stop receiving another user's webpage. CoBrowsing requires the use of sessions for sending the webpage.
	 *
	 * @class coBrowsing
	 * @namespace kandy
	 * @static
	 */
	api.coBrowsing = api.CoBrowse = (function() {
	    // local scope reference
	    var me = {};

	    // flag to indacate if CoBrowseing is started
	    var coBrowseStarted = false;

	    // flag to lock scrolling
	    var scrollLock = false;

	    // flag to pervent loop scroll events
	    var emitScrollEvent = true;

	    // flag to pervent input update loop
	    var emitFormChange = true;

	    // MutationObserver holder
	    var mutationObserver;

	    // set lowest element defualt flags
	    var lowestElement = -1,
	        lowestElementId = '',
	        lowestElementTree = '';

	    // inline css cahce
	    var inlineCSSCache = '';

	    // agent iframe reference holders
	    var sessionId, coBrowsingContainer, coBrowsingDiv, iframe, iframeWindow, iframeDocument;

	    // base64 default cursor image
	    var defaultCursor = 'data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAAeCAMAAAAbzM5ZAAABNVBMVEUAvuf///8AvucAvucAvucAvucAvucAvucAvucAvucAvucAvucAvucAvucAvucAvucAvucAvucAvucAvucAvucAvucAvucAvucAvucAvucAvucAvucAvucAvucAvucAvucAvucAvucAvucAvucAvucAvucAvucAvucAvucAvucAvucAvucAvucAvucAvucAvucAvucAvucAvucAvucAvucBveYCuuECuuIDuN8Ett0FtdsGstcHsNUIr9MJrdEKqs0Kq80Kq84LqMoMpsgPocEQnr0RnbwSm7kWkq0XkasYj6kaiqIdhJoeg5kgf5MhfJAkdogkd4kldYcmcoMqa3oraXYsaHQwYGoxXmc0WGA1VVw1Vl06TFA7Sk07Sk48R0o8SEo+Q0Q+REU/QUE/QkNAQEBAQEFG5UD4AAAANHRSTlMAAAIEBggKHCMnKS0uNTk7PEBCSUpLU1dcX2tsbnFzdXeAhYuSk5aho63Fz9XZ29/l6uv9gq4ZTAAAAQBJREFUeAFdzmcjQmEAR/EngwzZkSSyR0aOvUe2DMoW8u/7fwRuV7r3OS9/r44xJhhpMG6Bv4wZBhbCfgwCQNSHETjbBRJeHILMRxqYsFCfJ8BUsx9VvASSLX6Urpcg1WahsstAl4V6WAN6LdTzFhC1UK8HQMJCucMWusOtFpaGBy0s5NLQ7sO3zAZAtReLe1Ca+sfHgpSB2YG68tLX3T456X0FGp35OFzcbgPHkk5hxMEQ5V6kJ1is+kUzDjA/BueSDqHPQROKj/aYJljNS/cwV0K3abiRvjehvoJh2CkqfwQdFTQpyF6tAzUejOHWH/BgbRJgptv59GhsMtEZcPoBmRFquUFm5kkAAAAASUVORK5CYII=';


	    /* ****************************************************************************************************************
	     * functions related to data handling starts here
	     * ****************************************************************************************************************/

	    /*
	     * Process an event form the user on the agent side
	     *
	     * @method agentEventRecieved
	     * @param {Object} message
	     */
	    var agentEventRecieved = function(message) {
	        // if cobrowsing isn't listen to any messages
	        if (coBrowseStarted === false) {
	            return;
	        }

	        // switch through the messages that could have been reserved
	        switch (message.payload.type) {
	            case 'screenUpdate':
	                // display the html update to the agent
	                renderScreen(message.payload.data);
	                break;
	            case 'userMousePosition':
	                // display the client mouse movement to the agent
	                displayUserMouseMove(message.payload.data);
	                break;
	            case 'userWindowScroll':
	                // move the agent viewport to match the clients scroll position
	                displayUserScroll(message.payload.data);
	                break;
	            case 'userWindowResize':
	                // resize the agent viewport to match the clients
	                resizeViewport(message.payload.data);
	                break;
	            case 'closeCoBrowse':
	                // resize the agent viewport to match the clients
	                me.stopBrowsingAgent();
	                break;
	        }
	    };

	    /*
	     * Process an event form the agent on the user side
	     *
	     * @method userEventRecieved
	     * @param {Object} message
	     */
	    var userEventRecieved = function(message) {
	        // if cobrowsing isn't listen to any messages
	        if (coBrowseStarted === false) {
	            return;
	        }

	        // switch through the messages that could have been reserved
	        switch (message.payload.type) {
	            case 'agentWindowScroll':
	                // dispaly the current scroll position from the agent
	                getAgentWindowScroll(message.payload.data);
	                break;
	            case 'agentMouseMove':
	                // dispaly the agent mouse movement to the viewer
	                getAgentMouseMove(message.payload.data);
	                break;
	            case 'agentClick':
	                // trigger a click from the agent
	                triggerAgentClick(message.payload.data);
	                break;
	            case 'agentInputChange':
	                // load a input change from the agent
	                showAgentInputChange(message.payload.data);
	                break;
	            case 'requestFullPage':
	                // send full page to new agent
	                sendScreen('HTML', message.full_user_id);
	                break;
	        }
	    };

	    /*
	     * Send data through the WebSocket Channel
	     *
	     * @method eventEmit
	     * @param {String} [type] The message type
	     * @param {Mixed} [data] The message to be sent
	     * @param {String} [destination] full user id for the destination
	     */
	    var eventEmit = function(type, data, destination) {
	        // if cobrowsing isn't started don't send any messages
	        if (coBrowseStarted === false) {
	            return;
	        }

	        // send Kandy session message
	        api.session.sendData(
	            sessionId, {
	                type: type,
	                data: data
	            },
	            null,
	            null,
	            destination
	        );
	    };


	    /* ****************************************************************************************************************
	     * functions related to agent screen starts here
	     * ****************************************************************************************************************/

	    /*
	     * Render the complete html or a partial update from the users screen
	     *
	     * @method renderScreen
	     * @param {Object} [msg] contains full or partial HTML and other update information
	     */
	    var renderScreen = function(msg) {
	        // set the iframe content window if its undefined
	        if (typeof iframe === 'undefined' || iframe === null) {
	            iframeSetup();
	        }

	        // cleanup the reseved html
	        var oDOM = cleanHtml(msg.html);

	        // if rendering the whole page or the <head> make sure there is a proper <base> tag
	        if ((msg.element === 'HTML' || msg.element === 'HEAD') && typeof msg.baseURI === 'string' && !oDOM.head.getElementsByTagName('base')[0]) {
	            // create a new <base> tag
	            var newBaseTag = document.createElement('base');
	            newBaseTag.href = msg.baseURI;

	            // add it to the top of the <head> tag
	            if (oDOM.head.firstChild) {
	                oDOM.head.insertBefore(newBaseTag, oDOM.head.firstChild);
	            } else {
	                oDOM.head.appendChild(newBaseTag);
	            }
	        }

	        // render the html into the iframe
	        if (msg.element === 'HTML') {
	            // set the iframe size
	            iframe.width = msg.screenx + 'px';
	            iframe.height = msg.screeny + 'px';

	            // set the scroll lock to false to pervent content load scroll
	            scrollLock = true;

	            // if rendering the full page get the whole dom
	            var content = serializeXmlNode(oDOM);

	            // open the iframe on write the html content to the frame
	            iframeDocument.open();
	            iframeDocument.write(content);
	            iframeDocument.close();

	            // check if the iframe is ready if not add a listener for when it is
	            if (iframeDocument.readyState === 'complete') {
	                // set the scroll lock to false to allow scrolling
	                scrollLock = false;

	                // scroll the iframe to match the users window
	                iframeWindow.scroll(msg.scrollx, msg.scrolly);
	            } else {
	                // set a onreadystatechange handler to set the user's scroll position
	                iframeDocument.onreadystatechange = function() {
	                    if (iframeDocument.readyState === 'complete') {
	                        // set the scroll emit flag to false to pervent the users window from scrolling
	                        emitScrollEvent = false;

	                        // set the scroll lock to false to allow scrolling
	                        scrollLock = false;

	                        // scroll the iframe to match the users window
	                        iframeWindow.scroll(msg.scrollx, msg.scrolly);
	                    }
	                };
	            }

	            // reset the iframe event listeners
	            agentAddEventListeners();
	        } else if (msg.element === 'HEAD') {
	            // replace the <head> tag
	            iframeDocument.documentElement.replaceChild(oDOM.head.cloneNode(true), iframeDocument.head);
	        } else if (msg.element === 'BODY') {
	            // replace the <body> tag
	            iframeDocument.documentElement.replaceChild(oDOM.body.cloneNode(true), iframeDocument.body);
	        } else {
	            // strip the # from the id
	            var id = msg.element.substr(1);

	            // get the node to be replaced
	            var node = iframeDocument.getElementById(id);

	            // replace the node
	            node.parentNode.replaceChild(oDOM.getElementById(id).cloneNode(true), node);
	        }

	        // add the inline style tag if the css has changed
	        if (typeof msg.css === 'string') {
	            // remove existing styles
	            var styleTags = iframeDocument.getElementsByTagName('style');
	            for (var s = 0; s < styleTags.length; s++) {
	                styleTags[s].parentNode.removeChild(styleTags[s]);
	            }

	            // create <style> tag
	            var newStyleTag = document.createElement('style');
	            newStyleTag.type = 'text/css';

	            // add the css to the <style> tag
	            newStyleTag.appendChild(document.createTextNode(msg.css));

	            // append the <style> tag to the head
	            iframeDocument.head.appendChild(newStyleTag);
	        }

	        _logger.debug(Math.floor(Date.now() / 1000) + ' Changed ' + msg.element); // [DEBUG]
	    };

	    /*
	     * Remove the iframe event listeners
	     *
	     * @method agentRemoveEventListeners
	     */
	    var agentRemoveEventListeners = function() {
	        // set reference to the iframe content window
	        if (typeof iframeWindow === 'undefined') {
	            return;
	        }

	        // clear all of the iframe event listeners
	        iframeWindow.removeEventListener('mousemove', agentSendMouseMove);
	        iframeWindow.removeEventListener('scroll', agentSendScroll);
	        iframeWindow.removeEventListener('click', agentSendClick);
	        iframeWindow.removeEventListener('input', agentInputChange);
	    };

	    /*
	     * Adds the iframe event listeners
	     *
	     * @method agentAddEventListeners
	     */
	    var agentAddEventListeners = function() {
	        // make sure there isn't currently any cobrowsing event listeners binded
	        agentRemoveEventListeners();

	        // listen for mouse movement in the iframe
	        iframeWindow.addEventListener('mousemove', agentSendMouseMove);

	        // listen for scrolling in the iframe
	        iframeWindow.addEventListener('scroll', agentSendScroll);

	        // listen for any clicks in the iframe
	        iframeWindow.addEventListener('click', agentSendClick);

	        // listen for any input changes
	        iframeWindow.addEventListener('input', agentInputChange);
	    };

	    /*
	     * Respond to an agent click in the agent iframe
	     *
	     * @method agentSendClick
	     * @param {Event} click event
	     */
	    var agentSendClick = function(e) {
	        // pervent default click action
	        e.preventDefault();

	        // send click notification as long the id isn't empty
	        if (e.target.id !== null && e.target.id !== '') {
	            eventEmit('agentClick', e.target.id);
	        }
	    };

	    /*
	     * Send the agents mouse position to the user
	     *
	     * @method agentSendMouseMove
	     * @param {Event} mouse movement event
	     */
	    var agentSendMouseMove = function(e) {
	        // send mouse movement notification
	        eventEmit('agentMouseMove', {
	            x: e.clientX,
	            y: e.clientY
	        });
	    };

	    /*
	     * Send the agents scroll position to the user
	     *
	     * @method agentSendScroll
	     * @param {Event} scroll event
	     */
	    var agentSendScroll = function(e) {
	        // send scroll notification if it didn't come from the user
	        if (emitScrollEvent && !scrollLock) {
	            eventEmit('agentWindowScroll', {
	                x: (e.target.documentElement.scrollLeft !== 0) ? e.target.documentElement.scrollLeft : e.target.body.scrollLeft,
	                y: (e.target.documentElement.scrollTop !== 0) ? e.target.documentElement.scrollTop : e.target.body.scrollTop
	            });
	        }

	        // set the scroll emit flag back to true
	        emitScrollEvent = true;
	    };

	    /*
	     * Moved the agents cursor on the users screen
	     *
	     * @method displayUserMouseMove
	     * @param {Object} [msg] contains the x and y coordinates of the agents cursor
	     */
	    var displayUserMouseMove = function(msg) {
	        // if the cobrowsing div isn't setup yet return
	        if (typeof coBrowsingDiv === 'undefined') {
	            return;
	        }

	        var cursor = document.getElementById('coBrowsingCursor-' + sessionId);
	        // check to make sure the cursor is on the page, if its not add it
	        if (cursor === null) {
	            // create cursor node
	            cursor = document.createElement('img');
	            cursor.id = 'coBrowsingCursor-' + sessionId;
	            cursor.src = defaultCursor;
	            cursor.style.position = 'absolute';
	            cursor.style.zIndex = '2147483647';

	            // append cursor to the cobrowsing div
	            coBrowsingDiv.appendChild(cursor);
	        }


	        // move the mouse cursor
	        cursor.style.left = msg.x + 'px';
	        cursor.style.top = msg.y + 'px';

	    };

	    /*
	     * Scroll the users window to match the agents
	     *
	     * @method displayUserScroll
	     * @param {Object} [msg] contains the x and y coordinates of the viewport scroll position
	     */
	    var displayUserScroll = function(msg) {
	        // if the cobrowsing div isn't setup yet return
	        if (typeof coBrowsingDiv === 'undefined') {
	            return;
	        }

	        // the the emit flag to false to pervent sending the scroll event back to the agent
	        emitScrollEvent = false;

	        // scroll the window the same place as the agent
	        iframeWindow.scroll(msg.x, msg.y);
	    };

	    /*
	     * Resize the agents viewport
	     *
	     * @method resizeViewport
	     * @param {Object} [msg] contains the x and y window sizes
	     */
	    var resizeViewport = function(msg) {
	        // resize the the iframe size
	        iframe.width = msg.x + 'px';
	        iframe.height = msg.y + 'px';
	    };

	    /*
	     * Gets any input changes the agent makes and send it to the user
	     *
	     * @method agentInputChange
	     */
	    var agentInputChange = function(e) {
	        // set the element reference
	        var element = e.target;

	        // set the holder for changed data
	        var data = {
	            id: element.id,
	            type: element.nodeName
	        };

	        // switch between input types
	        switch (element.nodeName) {
	            case 'INPUT':
	                // check for a password field
	                switch (element.type) {
	                    case 'password':
	                        // if the field is a password hide the value
	                        for (var value = ''; value.length < element.value.length;) {
	                            value += '*';
	                        }

	                        data.value = value;
	                        break;
	                    default:
	                        // set the value from the input field
	                        data.value = element.value;
	                        break;
	                }
	                break;
	            case 'SELECT':
	                // set a holder for the changed options
	                data.options = {};

	                // loop though each option
	                for (var o = element.options.length - 1; o >= 0; o--) {
	                    // check if the option is selected
	                    if (element.options[o].selected) {
	                        // set the selected flag
	                        data.options[o] = element.options[o].selected;
	                    }
	                }
	                break;
	            case 'TEXTAREA':
	                // set the value from the textaera value
	                data.value = element.value;
	                break;
	        }

	        // send input change to the user
	        eventEmit('agentInputChange', data);
	    };

	    /*
	     * Adds the agents iframe to the cobrowsing container and setups the iframe references
	     *
	     * @method iframeSetup
	     */
	    var iframeSetup = function() {
	        // clear the cobrowsing container div and insert holder div
	        coBrowsingContainer.innerHTML = '<div id="coBrowsingDiv-' + sessionId + '" style="position: relative;"></div>';
	        coBrowsingDiv = document.getElementById('coBrowsingDiv-' + sessionId);

	        // clear the cobrowsing div and insert the iframe
	        coBrowsingDiv.innerHTML = '<iframe id="coBrowsingIframe-' + sessionId + '" sandbox="allow-same-origin allow-scripts" src="javascript:;" style="border: none;"></iframe>';

	        // set references to the iframe
	        iframe = document.getElementById('coBrowsingIframe-' + sessionId);
	        iframeWindow = iframe.contentWindow;
	        iframeDocument = iframeWindow.document;
	    };

	    /**
	     * Starts listening for a user sending their webpage in the session. Displays the webpage in the specified container when received.
	     *
	     * @method startBrowsingAgent
	     * @param {String} session The session ID.
	     * @param {HTMLElement} container Element reference to be used for the agent's view.
	     */
	    me.startBrowsingAgent = function(session, container) {
	        // set the session id
	        sessionId = session;

	        // set the cobrowsing container
	        coBrowsingContainer = container;

	        // set the started flag
	        coBrowseStarted = true;

	        // register Kandy session listeners
	        api.session.setListeners(sessionId, {
	            'onData': agentEventRecieved
	        });

	        // request full page
	        eventEmit('requestFullPage', true);
	    };

	    /**
	     * Stops listening for a webpage in the session. Clears the container used for viewing.
	     *
	     * @method stopBrowsingAgent
	     */
	    me.stopBrowsingAgent = function() {
	        // remove agent event listeners
	        agentRemoveEventListeners();

	        // clear references to the iframe and cobrowsing div
	        coBrowsingDiv = iframe = iframeWindow = iframeDocument = null;

	        // empty the cobrowsing container
	        while (coBrowsingContainer.firstChild) {
	            coBrowsingContainer.removeChild(coBrowsingContainer.firstChild);
	        }

	        // clear the references to the session and cobrowsing container
	        sessionId = coBrowsingContainer = null;

	        // set the started flag
	        coBrowseStarted = false;
	    };

	    /* ****************************************************************************************************************
	     * functions related to the users starts here
	     * ****************************************************************************************************************/

	    /*
	     * Trigger a click event from an agent
	     *
	     * @method triggerAgentClick
	     * @param {String} [msg] contains the id of the element clicked
	     */
	    var triggerAgentClick = function(msg) {
	        // trigger a click from the agent
	        document.getElementById(msg).click();
	    };

	    /*
	     * Sets the position of the agents cursor in the users window
	     *
	     * @method getAgentMouseMove
	     * @param {Object} [msg] contains the x and y coordinates of the agents cursor
	     */
	    var getAgentMouseMove = function(msg) {

	        var cursor = document.getElementById('coBrowsingCursor-' + sessionId);
	        // check to make sure the cursor is on the page, if its not add it
	        if (cursor === null) {
	            // create cursor node
	            cursor = document.createElement('img');
	            cursor.id = 'coBrowsingCursor-' + sessionId;
	            cursor.src = defaultCursor;
	            cursor.style.position = 'fixed';
	            cursor.style.zIndex = '2147483647';

	            // append cursor to the document body
	            document.body.appendChild(cursor);
	        }

	        // move the mouse cursor
	        cursor.style.left = msg.x + 'px';
	        cursor.style.top = msg.y + 'px';

	    };

	    /*
	     * Sets the window scroll position to match the agents
	     *
	     * @method getAgentWindowScroll
	     * @param {Object} [msg] contains the x and y coordinates of the scroll position
	     */
	    var getAgentWindowScroll = function(msg) {
	        // the the emit flag to false to pervent sending the scroll event back to the agent
	        emitScrollEvent = false;

	        // scroll the window the same place as the agent
	        window.scroll(msg.x, msg.y);
	    };

	    /*
	     * Send the users mouse position to the agent
	     *
	     * @method userMouseMove
	     * @param {Event} mouse movement event
	     */
	    var userMouseMove = function(e) {
	        // send mouse movement notification
	        eventEmit('userMousePosition', {
	            x: e.clientX,
	            y: e.clientY
	        });
	    };

	    /*
	     * Send the users scroll position to the agent
	     *
	     * @method userScrollPosition
	     * @param {Event} scroll event
	     */
	    var userScrollPosition = function(e) {
	        // send scroll notification if it didn't come from the agent
	        if (emitScrollEvent) {
	            eventEmit('userWindowScroll', {
	                x: (e.target.documentElement.scrollLeft !== 0) ? e.target.documentElement.scrollLeft : e.target.body.scrollLeft,
	                y: (e.target.documentElement.scrollTop !== 0) ? e.target.documentElement.scrollTop : e.target.body.scrollTop
	            });
	        }

	        // set the scroll emit flag back to true
	        emitScrollEvent = true;
	    };

	    /*
	     * Send the users new window size to the agent
	     *
	     * @method userWindowResize
	     * @param {Event} window event object
	     */
	    var userWindowResize = function(e) {
	        eventEmit('userWindowResize', {
	            x: window.innerWidth || document.documentElement.clientWidth || document.body.clientWidth,
	            y: window.innerHeight || document.documentElement.clientHeight || document.body.clientHeight
	        });
	    };

	    /*
	     * Displays any input changes that the agent makes
	     *
	     * @method showAgentInputChange
	     */
	    var showAgentInputChange = function(msg) {
	        // set the element reference
	        var element = document.getElementById(msg.id);

	        // set form emit to false to pervent loop updates
	        emitFormChange = false;

	        // switch between input types
	        switch (msg.type) {
	            case 'INPUT':
	                // set the value from the input field
	                element.value = msg.value;
	                break;
	            case 'SELECT':
	                // loop though each option
	                for (var o = element.options.length - 1; o >= 0; o--) {
	                    // check if the option is selected
	                    element.options[o].selected = (msg.options[o]);
	                }
	                break;
	            case 'TEXTAREA':
	                // set the value from the textaera value
	                element.value = msg.value;
	                break;
	        }
	    };

	    /*
	     * Send the full or partial screen elements to the agent
	     *
	     * @method sendScreen
	     * @param {String} [element] the element of that needs to be updated
	     */
	    var sendScreen = function(element, user) {
	        // set the element thats being updated or HTML for the whole page
	        var getElement = (typeof element === 'string') ? element : 'HTML';

	        // get the html content
	        var contentHtml;
	        if (getElement === 'HTML') {
	            // get the full page and doctype
	            contentHtml = serializeXmlNode(document.doctype) + document.documentElement.outerHTML;

	            // output the full html document
	            contentHtml = serializeXmlNode(cleanHtml(contentHtml));
	        } else if (getElement === 'HEAD') {
	            // get just the <head> tag
	            contentHtml = cleanHtml(document.head.outerHTML).head.outerHTML;
	        } else if (getElement === 'BODY') {
	            // get just the <body> tag
	            contentHtml = cleanHtml(document.body.outerHTML).body.outerHTML;
	        } else {
	            // get the element id
	            var id = getElement.substr(1);

	            // get the element and clean the html
	            contentHtml = cleanHtml(document.getElementById(id).outerHTML).getElementById(id).outerHTML;
	        }

	        // setup the message to agent
	        var message = {
	            element: getElement,
	            html: contentHtml
	        };

	        // get all on page <style> blocks and loop through each to add it to a single css variable
	        var inlineCSS = '',
	            styleTags = document.getElementsByTagName('style');
	        for (var s = 0; s < styleTags.length; s++) {
	            inlineCSS += styleTags[s].innerHTML;
	        }

	        // if the current css doesn't match what we have in the cache send it to be updated
	        if (inlineCSS !== inlineCSSCache || getElement === 'HTML') {
	            message.css = inlineCSSCache = inlineCSS;
	            _logger.debug('New CSS');
	        }

	        // send extra info if sending the whole page
	        if (getElement === 'HTML') {
	            // send the window height and width
	            message.screenx = window.innerWidth || document.documentElement.clientWidth || document.body.clientWidth;
	            message.screeny = window.innerHeight || document.documentElement.clientHeight || document.body.clientHeight;

	            // send the scroll position
	            message.scrollx = (document.documentElement.scrollLeft !== 0) ? document.documentElement.scrollLeft : document.body.scrollLeft;
	            message.scrolly = (document.documentElement.scrollTop !== 0) ? document.documentElement.scrollTop : document.body.scrollTop;
	        }

	        // get the base URI if sending the whole page or the <head>
	        if (getElement === 'HTML' || getElement === 'HEAD') {
	            message.baseURI = document.baseURI;
	        }

	        // send the changes to the agent
	        eventEmit('screenUpdate', message, user);

	        _logger.debug(Math.floor(Date.now() / 1000) + ' Screen Sent ' + getElement); // [DEBUG]
	    };

	    /*
	     * Removes the user event listeners
	     *
	     * @method userRemoveEventListeners
	     */
	    var userRemoveEventListeners = function() {
	        // clear all of the document event listeners
	        document.removeEventListener('mousemove', userMouseMove);
	        document.removeEventListener('scroll', userScrollPosition);

	        // clear the window document event listeners
	        window.removeEventListener('resize', userWindowResize);
	        window.removeEventListener('input', saveFormData);
	        window.removeEventListener('change', radioCheckboxChange);
	    };

	    /*
	     * Adds the user event listeners
	     *
	     * @method userAddEventListeners
	     */
	    var userAddEventListeners = function() {
	        // make sure there isn't currently any cobrowsing event listeners binded
	        userRemoveEventListeners();

	        // listen for mouse movement in the iframe
	        document.addEventListener('mousemove', userMouseMove);

	        // listen for scrolling in the iframe
	        document.addEventListener('scroll', userScrollPosition);

	        // listen for window resize events
	        window.addEventListener('resize', userWindowResize);

	        // listen for form changes
	        window.addEventListener('input', saveFormData);
	        window.addEventListener('change', radioCheckboxChange);
	    };

	    /*
	     * The mutation observer handler function that is called when there is a group of mutations
	     *
	     * @method mutationHandler
	     * @param {Object} [mutations] contains all of the mutations that have happened
	     * @param {Object} [observer] contains a reference to the mutation observer
	     */
	    var mutationHandler = function(mutations, observer) {
	        // test each mutation to understand the updated dom
	        mutations.forEach(function(mutation) {
	            // set defualt options
	            var element, treePosition = 0,
	                id = '',
	                idTree = [];

	            // check to make sure the mutation wasn't the agents cursor being added to the screen
	            if (typeof mutation.addedNodes[0] !== 'undefined' && mutation.addedNodes[0].id === 'coBrowsingCursor-' + sessionId) {
	                return;
	            }

	            // set the element to the current mutation
	            if (mutation.type === 'characterData' || (mutation.type === 'attributes' && mutation.attributeName === 'id')) {
	                // if the mutation type is characterData get the element the characterData change was in || or if the id was changed force get the parent node
	                element = mutation.target.parentNode;
	            } else {
	                element = mutation.target;
	            }

	            // while there is a parent item
	            while (element.parentNode) {
	                // if the element isn't empty
	                if (element.id !== '' || element.tagName === 'HTML' || element.tagName === 'HEAD' || element.tagName === 'BODY') {
	                    var thisID;
	                    // set the element tag or id
	                    if (element.tagName === 'HTML' || element.tagName === 'HEAD' || element.tagName === 'BODY') {
	                        thisID = element.tagName;
	                    } else {
	                        thisID = '#' + element.id;
	                    }

	                    // set the id of the first id in the mutation
	                    if (id === '') {
	                        id = thisID;
	                    }

	                    // push the id onto the tree
	                    idTree.push(thisID);
	                }

	                // count the parent number
	                if (id !== '') {
	                    treePosition++;
	                }

	                // set the parent element for the next iteration
	                element = element.parentNode;
	            }

	            // if no id is set do a full page refresh
	            if (id === '') {
	                lowestElementId = 'HTML';
	                return false;
	            }

	            // verify the change isn't the cursor moving
	            if (id === '#coBrowsingCursor-' + sessionId) {
	                return false;
	            }

	            // flip the id tree for easy walking
	            idTree = idTree.reverse();

	            // check if the modifyed element is the highest in the dom tree
	            if (lowestElement === -1) {
	                _logger.debug('First element: ' + id + ' (' + treePosition + ')'); // [DEBUG]

	                // set the first element
	                lowestElement = treePosition;
	                lowestElementId = id;
	                lowestElementTree = idTree;
	            } else if (idTree.indexOf(lowestElementId) === -1) {
	                // if the modified element is not under the current highest element negotiate the highest common dom element
	                _logger.debug(id + ' (' + treePosition + ') not under ' + lowestElementId); // [DEBUG]

	                // set the default common element
	                var lastCommonElement = 'HTML';

	                // walk through the element id tree to find the last common element
	                lowestElementTree.forEach(function(value) {
	                    if (idTree.indexOf(value) !== -1) {
	                        lastCommonElement = value;
	                    } else {
	                        return false;
	                    }
	                });

	                // set the new lowest common element
	                lowestElement = lowestElementTree.indexOf(lastCommonElement) + 1;
	                lowestElementId = lastCommonElement;
	                lowestElementTree = lowestElementTree.slice(0, lowestElement);

	                _logger.debug('Renegotiated top to: ' + lowestElementId + ' (' + lowestElement + ')'); // [DEBUG]
	            }
	        });

	        // make sure every element has a unique id and get changed count
	        var idChanged = assignUniqueIds();

	        // save any form changes to the DOM and get the changed count
	        var formChanged = saveFormData();

	        // if the number of elements changed isn't 0 hold the screen update
	        if (idChanged !== 0 || formChanged !== 0) {
	            _logger.debug('Updated skipped, ids:' + idChanged + ' forms:' + formChanged); // [DEBUG]
	            return;
	        }

	        // if full page refresh is set, do a full page refresh otherwise a partial page update
	        if (lowestElementId === 'HTML') {
	            _logger.debug('Doing a full page refresh'); // [DEBUG]

	            // do full page refresh
	            sendScreen();
	        } else if (lowestElementId !== '') {
	            _logger.debug('Doing a partial page update on: ' + lowestElementId); // [DEBUG]

	            // send a partial page update
	            sendScreen(lowestElementId);
	        }

	        // clear the lowest element
	        lowestElement = -1;
	        lowestElementId = '';
	        lowestElementTree = '';
	    };

	    /**
	     * Starts sending current webpage to the session.
	     *
	     * @method startBrowsingUser
	     * @param {String} session The session ID.
	     */
	    me.startBrowsingUser = function(session) {
	        // set the session id
	        sessionId = session;

	        // set the started flag
	        coBrowseStarted = true;

	        // register Kandy session listeners
	        api.session.setListeners(sessionId, {
	            'onData': userEventRecieved
	        });

	        // assign unique ids to all elements on the page to allow for agent interaction
	        assignUniqueIds();

	        // save form data to the dom before starting the cobrowsing session
	        saveFormData();

	        // sends the screen to any connected agents
	        sendScreen();

	        // add the document listeners for user side changes
	        userAddEventListeners();

	        // setup the mutation observer to watch for dom changes
	        mutationObserver = new MutationObserver(mutationHandler);

	        // define the elements that should be observed by the observer
	        mutationObserver.observe(document.body, {
	            childList: true,
	            attributes: true,
	            characterData: true,
	            subtree: true
	        });
	    };

	    /**
	     * Stops sending webpage to the session.
	     *
	     * @method stopBrowsingUser
	     */
	    me.stopBrowsingUser = function() {
	        // stop lissning the mutationObserver
	        mutationObserver.disconnect();

	        // remove document and window listeners
	        userRemoveEventListeners();

	        // inform connected agents that the screenshare has been stopped
	        eventEmit('closeCoBrowse', true);

	        // remove agents cursor
	        var cursor = document.getElementById('coBrowsingCursor-' + sessionId);
	        if (cursor !== null) {
	            cursor.remove();
	        }

	        // set the started flag
	        coBrowseStarted = false;
	    };

	    /* ****************************************************************************************************************
	     * utility functions starts here
	     * ****************************************************************************************************************/

	    /*
	     * Clean and strip the HTML for transmission and display
	     *
	     * @method cleanHtml
	     * @param {String} html
	     * @returns {Object} HTMLDocument object
	     */
	    var cleanHtml = function(html) {
	        // set the tags to be removed
	        var removeTags = ['SCRIPT', 'STYLE'];

	        // regex search string for on* attributes like onload, onclick, etc.
	        var onSearch = new RegExp('^on', 'i');

	        // regex search string for attribute level javascript
	        var jsSearch = new RegExp('^javascript:', 'i');

	        // array of nodes that needs to be removed
	        var deleteNodeList = [];

	        // create a new dom object from a html string
	        var oDOM = new DOMParser().parseFromString(html, 'text/html');

	        // get all of the tags
	        var elements = oDOM.getElementsByTagName('*');


	        // for each element
	        for (var i = 0; i < elements.length; i++) {
	            // set the current element
	            var element = elements[i];

	            // check if the element should be removed
	            if (removeTags.indexOf(element.nodeName) !== -1) {
	                // adds the element onto the node removal list
	                deleteNodeList.push(element);

	                continue;
	            }

	            // check each attribute that the element has
	            for (var a = 0; a < element.attributes.length; a++) {
	                // set the current attribute
	                var attr = element.attributes[a];

	                // check if the attribute is a on* attribute
	                if (onSearch.test(attr.name)) {
	                    element.removeAttribute(attr.name);
	                    continue;
	                }

	                // check if the attribute has javascript
	                if (jsSearch.test(attr.value)) {
	                    attr.value = '';
	                }
	            }
	        }

	        // fix for IE not allowing optional parameters
	        var fliter = null;

	        // create a tree walker to find all html comments
	        var treeWalker = document.createTreeWalker(oDOM, NodeFilter.SHOW_COMMENT, fliter, false);

	        // stores each comment node that needs to be removed
	        while (treeWalker.nextNode()) {
	            deleteNodeList.push(treeWalker.currentNode);
	        }

	        // remove all of the illegal nodes
	        deleteNodeList.forEach(function(node) {
	            node.parentNode.removeChild(node);
	        });

	        // remove the agent cursor
	        var cursor = oDOM.getElementById('coBrowsingCursor-' + sessionId);
	        cursor && cursor.parentNode && cursor.parentNode.removeChild(cursor);

	        return oDOM;
	    };

	    /*
	     * Serialize the XML node to a string
	     *
	     * @method serializeXmlNode
	     * @param {Object} document node
	     * @returns {String} the html from the XML node
	     */
	    var serializeXmlNode = function(xmlNode) {
	        if (typeof xmlNode === 'object' && xmlNode !== null) {
	            if (typeof window.XMLSerializer !== 'undefined') {
	                return (new window.XMLSerializer()).serializeToString(xmlNode);
	            } else if (typeof xmlNode.xml !== 'undefined') {
	                return xmlNode.xml;
	            }
	        }

	        return '';
	    };

	    /*
	     * Saves the current form data to the DOM
	     *
	     * @method saveFormData
	     * @returns {Number} count of the number of elements that where changed
	     */
	    var saveFormData = function() {
	        // check to make sure a form save is needed
	        if (!emitFormChange) {
	            emitFormChange = true;
	            return;
	        }

	        // count for the number of changed elements
	        var changedCount = 0;

	        // get all <input> tags
	        var inputs = document.getElementsByTagName('input');

	        var element;

	        // process each <input> tag
	        for (var i = 0; i < inputs.length; i++) {
	            // set the element reference
	            element = inputs[i];

	            // switch the input type
	            switch (element.type) {
	                case 'password':
	                    // if the field is a password hide the value
	                    for (var value = ''; value.length < element.value.length;) {
	                        value += '*';
	                    }

	                    // load the new hidden value into the dom
	                    if (element.defaultValue !== value) {
	                        element.defaultValue = value;
	                        changedCount++;
	                    }
	                    break;
	                case 'checkbox':
	                case 'radio':
	                    // set the checked value
	                    if (element.defaultChecked !== element.checked) {
	                        element.defaultChecked = element.checked;
	                        changedCount++;
	                    }
	                    break;
	                case 'reset':
	                case 'submit':
	                case 'button':
	                    // don't change button values
	                    break;
	                default:
	                    // set the value in the dom
	                    if (element.defaultValue !== element.value) {
	                        element.defaultValue = element.value;
	                        changedCount++;
	                    }
	                    break;
	            }
	        }

	        // get all <select> tags
	        var selects = document.getElementsByTagName('select');

	        // process each <select> tag
	        for (i = 0; i < selects.length; i++) {
	            // set the element reference
	            element = selects[i];

	            // loop though each option
	            for (var o = element.options.length - 1; o >= 0; o--) {
	                // set the selected flag
	                if (element.options[o].defaultSelected !== element.options[o].selected) {
	                    element.options[o].defaultSelected = element.options[o].selected;
	                    changedCount++;
	                }
	            }
	        }

	        // get all <textarea> tags
	        var textareas = document.getElementsByTagName('textarea');

	        // process each <textarea> tag
	        for (i = 0; i < textareas.length; i++) {
	            // save the value into the dom
	            if (textareas[i].defaultValue !== textareas[i].value) {
	                textareas[i].defaultValue = textareas[i].value;
	                changedCount++;
	            }
	        }

	        return changedCount;
	    };

	    /*
	     * Saves changes to radio buttons and checkboxs to the DOM
	     *
	     * @method radioCheckboxChange
	     */
	    var radioCheckboxChange = function(e) {
	        // only trigger a form save if the element is a radio button or an checkbox
	        if (e.target.nodeName === 'INPUT' && (e.target.type === 'radio' || e.target.type === 'checkbox')) {
	            // save the form data to dom
	            saveFormData();
	        }
	    };

	    /*
	     * Adds a unique id to elements on the page that don't already have one to allow for agent interaction
	     *
	     * @method assignUniqueIds
	     * @returns {Number} number of elements that needed ids added
	     */
	    var assignUniqueIds = function() {
	        // set the base id name
	        var idName = 'uid-ui-';

	        // set the start unique id count
	        var uniqueId = 0;

	        // get all of the tags without an id or an emtpy id
	        var elements = document.querySelectorAll('body *:not([id]), body *[id=""]');

	        // process each element without a vaild id
	        for (var l = 0; l < elements.length; l++) {
	            // if there is an element with the id increase the unique id count
	            while (document.getElementById(idName + uniqueId) !== null) {
	                uniqueId++;
	            }

	            // add the unique id and increase the unique id count
	            elements[l].id = idName + uniqueId;
	            uniqueId++;
	        }

	        return elements.length;
	    };

	    return me;
	}());

	/**
	 * Kandy messaging is used to send and receive messages. Messages can be regular chat messages, SMS, files, audio, video, or images. Using messaging you can also manage messaging groups.
	 *
	 * @class messaging
	 * @namespace kandy
	 * @static
	 */
	api.messaging = (function () {

	    /*
	     * @property {Object} _imContentTypes Holds IM content types.
	     */
	    var _imContentTypes = {
	        TEXT: 'text',
	        VIDEO: 'video',
	        AUDIO: 'audio',
	        IMAGE: 'image',
	        FILE: 'file',
	        LOCATION: 'location',
	        CONTACT: 'contact'
	    };

	    var me = {};

	    function _sendIM(destination, contentType, msg, success, failure, isGroup, messageOptions) {
	        messageOptions = messageOptions || {};

	        // Create the message object.
	        var uuid = (messageOptions && messageOptions.uuid) || utils.createUUIDv4();
	        var message = {
	            message: {
	                contentType: contentType,
	                UUID: uuid,
	                message: msg,
	                additional_data: messageOptions.additionalData
	            }
	        };

	        // Select the correct url and params depending on whether this is a group IM or not.
	        var url;
	        var params;
	        if(isGroup){
	            utils.extend(message.message, {
	                'group_id': destination
	            });
	            url = '/users/chatgroups/chatgroup/messages';
	            //message.messageType = "groupChat";
	        } else {
	            message.message.destination = destination;
	            message.messageType = 'chat';
	            url = '/devices/messages';
	            params = {
	                'device_id': _userDetails.devices[0].id
	            };
	        }

	        _kandyRequest({
	            type: 'POST',
	            url: url,
	            params: params,
	            data: message,
	            success: function (response) {
	                if (success) {
	                    success(message.message);
	                }
	            },
	            failure: failure
	        });
	        return uuid;
	    }

	    /*
	     * Sends a File message to another Kandy user
	     *
	     * @method _sendImWithAttachment
	     * async
	     * @param {String} destination Destination of message recipient
	     * @param {Object} attachment Attachement to be sent
	     * @param {String} contentType Content Type of file.
	     * @param {Function} success The success callback. It receives no parameters.
	     * @param {Function} failure The failure callback. It receives one parameter.
	     * @param {String} failure.errorMessage The error message explaining what failed.
	     * @return {Function} abort A function you can call to cancel the upload.
	     */
	    function _sendImWithAttachment(destination, attachment, contentType, success, failure, isGroup, messageOptions) {
	        if (_config.messageProvider === 'fring') {

	            var uuid = utils.createUUIDv4();
	            messageOptions = messageOptions || {};
	            messageOptions.uuid = uuid;

	            // Upload file and if we get a success send the IM
	            return me.uploadFile(
	                attachment,
	                function (fileUuid) {
	                    var message = {
	                        mimeType: attachment.type,
	                        'file_length_bytes': attachment.size,
	                        'content_uuid': fileUuid,
	                        'content_name': attachment.name,
	                        'contact_display_name': messageOptions.contact_display_name
	                    };

	                    return _sendIM(destination, contentType, message, success, failure, isGroup, messageOptions);
	                },
	                failure
	            );
	        } else {
	            _logger.error('NOT SUPPORTED');
	            if(failure){
	                failure();
	            }
	        }
	    }

	    function _sendImWithLocation(destination, location, success, failure, isGroup, messageOptions) {
	        // Creating an alias for backwards compatibility
	        if (location.location_latitude && location.location_longitude) {
	            location.latitude = location.location_latitude;
	            location.longitude = location.location_longitude;
	        }

	        return _sendIM(destination, _imContentTypes.LOCATION, {
	            mimeType: 'location/utm',
	            'media_map_zoom': 10,
	            'location_latitude': location.latitude,
	            'locationLatitude': location.latitude,
	            'location_longitude': location.longitude,
	            'locationLongitude': location.longitude
	        }, success, failure, isGroup, messageOptions);

	    }

	    function _sendJSON(user, object, success, failure, isGroup, messageOptions) {
	        return _sendIM(user, _imContentTypes.TEXT, {
	            mimeType: 'application/json',
	            json: JSON.stringify(object)
	        }, success, failure, isGroup, messageOptions);
	    }

	    /**
	     * Sends an SMS message.
	     *
	     * @method sendSMS
	     * @async
	     * @param {String} number Phone number to which SMS message will be sent. Make sure to preceed the phone number with the appropriate country code.
	     * @param {String} sender A description of the sender (could be name or phone number).
	     * @param {String} text Text of message to send.
	     * @param {Function} success The success callback. It receives no parameters.
	     * @param {Function} failure The failure callback. It receives one parameter.
	     * @param {String} failure.errorMessage The error message explaining what failed.
	     */
	    me.sendSMS = function (number, sender, text, success, failure) {
	        _kandyRequest({
	            type: 'POST',
	            url: '/devices/smss',
	            params: {
	                'device_id': _userDetails.devices[0].id
	            },
	            data: {
	                message: {
	                    source: sender,
	                    destination: number,
	                    message: {text: text}
	                }
	            },

	            // TODO: Shouldn't we map to return result here?
	            success: success,
	            failure: failure
	        });
	    };

	    /**
	     * Sends an instant message to another Kandy user.
	     *
	     * @method sendIm
	     * @async
	     * @param {String} fullUserId Username of the intended recipient.
	     * @param {String} message Message to send.
	     * @param {Function} success The success callback. It receives one parameter.
	     * @param {Message} success.message The message that was sent.
	     * @param {Function} failure The failure callback. It receives one parameter.
	     * @param {String} failure.errorMessage The error message explaining what failed.
	     * @param {Object} options Object of options for the message.
	     * @param {Object} options.additionalData Object with arbitrary metadata about the IM.
	     * @return {String} uuid Unique string identifier for the sent message.
	     * @example
	     * Here is an example of a result given to the success function.
	     * ``` javascript
	     *  {
	     *      "UUID": "E72F1D02-5ED7-4E36-9938-78460ABD286B",
	     *      "contentType": "text",
	     *      "destination": "user1@test.kandy.io"
	     *      "message": {
	     *          "mimeType": "text/plain",
	     *          "text": "this is the text to send"
	     *      },
	     *      "additionalData" {
	     *          ...
	     *      }
	     *  }
	     * ```
	     */
	    me.sendIm = function(fullUserId, message, success, failure, options) {
	        if (_config.messageProvider === 'fring') {
	            return _sendIM(fullUserId, _imContentTypes.TEXT, { 'mimeType': 'text/plain', 'text': message }, success, failure, false, options);
	        } else if (_config.messageProvider === 'spidr') {
	            var im = new fcs.im.Message();
	            im.primaryContact = fullUserId;
	            im.type = 'A2';
	            im.msgText = message;
	            im.charset = 'UTF-8';

	            fcs.im.send(im, success, failure);
	            return 0;
	        }
	    };

	    /**
	     * Forwards a message to another Kandy user.
	     *
	     * @method forwardMessage
	     * @async
	     * @param {String} destination The destination, can be a userId or a groupID.
	     * @param {Message} message Message to send.
	     * @param {Function} success The success callback. It receives one parameter.
	     * @param {Message} success.message The message that was sent.
	     * @param {Function} failure The failure callback. It receives one parameter.
	     * @param {String} failure.errorMessage The error message explaining what failed.
	     * @return {String} uuid Unique string identifier for the sent message.
	     * @example
	     * Here is an example of a result given to the success function.
	     * ``` javascript
	     *  {
	     *      "UUID": "E72F1D02-5ED7-4E36-9938-78460ABD286B",
	     *      "contentType": "text",
	     *      "destination": "user1@test.kandy.io"
	     *      "message": {
	     *          "mimeType": "text/plain",
	     *          "text": "this is the text to send"
	     *      },
	     *      "additionalData" {
	     *          ...
	     *      }
	     *  }
	     * ```
	     */
	    me.forwardMessage = function(destination, message, success, failure) {
	        var messageOptions = {
	            additionalData: message.additionalData
	        };

	        //Group ID's can't contain the @ symbol, if @ is present dest = user.
	        var isGroup;
	        if (destination.indexOf('@')) {
	            isGroup = false;
	        } else {
	            isGroup = true;
	        }

	        return _sendIM(destination, message.contentType, message.message, success, failure, isGroup, messageOptions);
	    };

	    /**
	     * Sends arbitrary JSON object via instant message.
	     *
	     * @method sendJSON
	     * @async
	     * @param {String} fullUserId Full user Id of the intended recipient.
	     * @param {Object} object Arbitrary JSON object to send.
	     * @param {Function} success The success callback. It receives one parameter.
	     * @param {Message} success.message The message that was sent.
	     * @param {Function} failure The failure callback. It receives no parameters.
	     * @param {Object} options Object of options for the message.
	     * @param {Object} options.additionalData Object with arbitrary metadata about the IM.
	     * @return {String} uuid Unique string identifier for the sent message.
	     * @example
	     * Here is an example of a result given to the success function.
	     * ``` javascript
	     *  {
	     *      "UUID": "E72F1D02-5ED7-4E36-9938-78460ABD286B",
	     *      "contentType": "text",
	     *      "destination": "user1@test.kandy.io"
	     *      "message": {
	     *          mimeType: "application/json",
	     *          json: "{"key":"value"}"
	     *      },
	     *      "additionalData" {
	     *          ...
	     *      }
	     *  }
	     * ```
	     */
	    me.sendJSON = function (fullUserId, object, success, failure, options) {
	        return _sendJSON(fullUserId, object, success, failure, false, options);
	    };

	    /**
	     * Sends a File via instant message.
	     *
	     * @method sendImWithFile
	     * @async
	     * @param {String} fullUserId Full user Id of the intended recipient.
	     * @param {File} file File object to send.
	     * @param {Function} success The success callback. It receives one parameter.
	     * @param {Message} success.message The message that was sent.
	     * @param {Function} failure The failure callback. It receives no parameters.
	     * @param {Object} options Object of options for the message.
	     * @param {Object} options.additionalData Object with arbitrary metadata about the IM.
	     * @return {Function} abort A function you can call to cancel the upload.
	     * @example
	     * Here is an example of a result given to the success function.
	     * ``` javascript
	     *  {
	     *      "UUID": "E72F1D02-5ED7-4E36-9938-78460ABD286B",
	     *      "contentType": "file",
	     *      "destination": "user1@test.kandy.io"
	     *      "message": {
	     *          mimeType: "application/pdf",
	     *          content_name: "file.pdf",
	     *          content_uuid: "738814CB-1019-4482-9200-56CB3FA033D9"
	     *      },
	     *      "additionalData" {
	     *          ...
	     *      }
	     *  }
	     * ```
	     */
	    me.sendImWithFile = function (fullUserId, file, success, failure, options) {
	        return _sendImWithAttachment(fullUserId, file, _imContentTypes.FILE, success, failure, false, options);
	    };

	    /**
	     * Sends an image file via instant message.
	     *
	     * @method sendImWithImage
	     * @async
	     * @param {String} fullUserId Full user Id of the intended recipient.
	     * @param {File} file Image file to be sent
	     * @param {Function} success The success callback. It receives one parameter.
	     * @param {Message} success.message The message that was sent.
	     * @param {Function} failure The failure callback. It receives no parameters.
	     * @param {Object} options Object of options for the message.
	     * @param {Object} options.additionalData Object with arbitrary metadata about the IM.
	     * @return {Function} abort A function you can call to cancel the upload.
	     * @example
	     * Here is an example of a result given to the success function.
	     * ``` javascript
	     *  {
	     *      "UUID": "E72F1D02-5ED7-4E36-9938-78460ABD286B",
	     *      "contentType": "image",
	     *      "destination": "user1@test.kandy.io"
	     *      "message": {
	     *          content_name: "image.jpg",
	     *          content_uuid: "738814CB-1019-4482-9200-56CB3FA033D9",
	     *          mimeType: "image/jpeg"
	     *      },
	     *      "additionalData" {
	     *          ...
	     *      }
	     *  }
	     * ```
	     */
	    me.sendImWithImage = function (fullUserId, file, success, failure, options) {
	        return _sendImWithAttachment(fullUserId, file, _imContentTypes.IMAGE, success, failure, false, options);
	    };

	    /**
	     * Sends an audio file via instant message.
	     *
	     * @method sendImWithAudio
	     * @async
	     * @param {String} fullUserId Full user Id of the intended recipient.
	     * @param {File} file Audio file to be sent
	     * @param {Function} success The success callback. It receives one parameter.
	     * @param {Message} success.message The message that was sent.
	     * @param {Function} failure The failure callback. It receives no parameters.
	     * @param {Object} options Object of options for the message.
	     * @param {Object} options.additionalData Object with arbitrary metadata about the IM.
	     * @return {Function} abort A function you can call to cancel the upload.
	     * @example
	     * Here is an example of a result given to the success function.
	     * ``` javascript
	     *  {
	     *      "UUID": "E72F1D02-5ED7-4E36-9938-78460ABD286B",
	     *      "contentType": "audio",
	     *      "destination": "user1@test.kandy.io"
	     *      "message": {
	     *          content_name: "audio_file.mp3",
	     *          content_uuid: "738814CB-1019-4482-9200-56CB3FA033D9",
	     *          mimeType: "audio/mp3"
	     *      },
	     *      "additionalData" {
	     *          ...
	     *      }
	     *  }
	     * ```
	     */
	    me.sendImWithAudio = function (fullUserId, file, success, failure, options) {
	        return _sendImWithAttachment(fullUserId, file, _imContentTypes.AUDIO, success, failure, false, options);
	    };

	    /**
	     * Sends an video file via instant message.
	     *
	     * @method sendImWithVideo
	     * @async
	     * @param {String} fullUserId Full user Id of the intended recipient.
	     * @param {Object} file Video file to be sent
	     * @param {Function} success The success callback. It receives one parameter.
	     * @param {Message} success.message The message that was sent.
	     * @param {Function} failure The failure callback. It receives no parameters.
	     * @param {Object} options Object of options for the message.
	     * @param {Object} options.additionalData Object with arbitrary metadata about the IM.
	     * @return {Function} abort A function you can call to cancel the upload.
	     * @example
	     * Here is an example of a result given to the success function.
	     * ``` javascript
	     *  {
	     *      "UUID": "E72F1D02-5ED7-4E36-9938-78460ABD286B",
	     *      "contentType": "video",
	     *      "destination": "user1@test.kandy.io"
	     *      "message": {
	     *          content_name: "video_file.avi",
	     *          content_uuid: "738814CB-1019-4482-9200-56CB3FA033D9",
	     *          mimeType: "video/avi"
	     *      },
	     *      "additionalData" {
	     *          ...
	     *      }
	     *  }
	     * ```
	     */
	    me.sendImWithVideo = function (fullUserId, file, success, failure, options) {
	        return _sendImWithAttachment(fullUserId, file, _imContentTypes.VIDEO, success, failure, false, options);
	    };

	    /**
	     * Sends a contact object via instant message.
	     *
	     * @method sendImWithContact
	     * @async
	     * @param {String} fullUserId Full user Id of the intended recipient.
	     * @param {File} vCard Contact object to be sent
	     * @param {Function} success The success callback. It receives one parameter.
	     * @param {Message} success.message The message that was sent.
	     * @param {Function} failure The failure callback. It receives no parameters.
	     * @param {Object} options Object of options for the message.
	     * @param {Object} options.additionalData Object with arbitrary metadata about the IM.
	     * @param {Object} options.contact_display_name Contact name sent alongside vCard file.
	     * @return {Function} abort A function you can call to cancel the upload.
	     * @example
	     * Here is an example of a result given to the success function.
	     * ``` javascript
	     *  {
	     *      "UUID": "E72F1D02-5ED7-4E36-9938-78460ABD286B",
	     *      "contentType": "contact",
	     *      "destination": "user1@test.kandy.io"
	     *      "message": {
	     *          contact_display_name: "Example Contact Name",
	     *          content_name: "contact_file.vcf",
	     *          content_uuid: "738814CB-1019-4482-9200-56CB3FA033D9",
	     *          mimeType: "text-vcard"
	     *      },
	     *      "additionalData" {
	     *          ...
	     *      }
	     *  }
	     * ```
	     */
	    me.sendImWithContact = function (fullUserId, vCard, success, failure, options) {
	        // It used to be that instead of 'options', this function accepted
	        // a 'displayName'. We will unofficially support that case with this
	        // workaround.
	        if (typeof options === 'string') {
	            var displayName = options;
	            options = {'contact_display_name': displayName};
	        }

	        return _sendImWithAttachment(fullUserId, vCard, _imContentTypes.CONTACT, success, failure, false, options);
	    };

	    /**
	     * Sends a location object via instant message.
	     *
	     * @method sendImWithLocation
	     * @async
	     * @param {String} fullUserId Full user Id of the intended recipient.
	     * @param {Object} location Location object to be sent
	     * @param {String} location.longitude Location's longitude
	     * @param {String} location.latitude Location's latitude
	     * @param {Function} success The success callback. It receives one parameter.
	     * @param {Message} success.message The message that was sent.
	     * @param {Function} failure The failure callback. It receives no parameters.
	     * @param {Object} options Object of options for the message.
	     * @param {Object} options.additionalData Object with arbitrary metadata about the IM.
	     * @return {String} uuid Unique string identifier for the sent message.
	     * @example
	     * Here is an example of a result given to the success function.
	     * ``` javascript
	     *  {
	     *      "UUID": "E72F1D02-5ED7-4E36-9938-78460ABD286B",
	     *      "contentType": "location",
	     *      "destination": "user1@test.kandy.io
	     *      "message": {
	     *          locationLongitude: "45.298834",
	     *          locationLatitude: "-75.913328",
	     *          mimeType: "location/utm"
	     *      },
	     *      "additionalData" {
	     *          ...
	     *      }
	     *  }
	     * ```
	     */
	    me.sendImWithLocation = function (fullUserId, location, success, failure, options) {
	        return _sendImWithLocation(fullUserId, location, success, failure, false, options);
	    };

	    /*
	     * Uploads file to be used in Rich IM messaging
	     *
	     * @method uploadFile
	     * @async
	     * @param {File} file File to be sent
	     * @param {Function} success The success callback. It receives one parameter.
	     * @param {String} success.uuid The UUID of the uploaded file.
	     * @param {Function} failure The failure callback. It receives two parameters.
	     * @param {string} failure.message Error Message.
	     * @param {string} failure.statusCode Error status code.
	     * @return {Function} abort A function you can call to cancel the upload.
	     */
	    me.uploadFile = function (file, success, failure) {
	        // Generate a UUID
	        var uuid = utils.createUUIDv4();

	        // Create a new FormData object.
	        var formData = new FormData();

	        // Add the file to the request.
	        formData.append('file', file, file.name);

	        // Set up the request.
	        var xhr = new XMLHttpRequest();

	        var url = _config.kandyApiUrl + '/devices/content?key=' + _userDetails.userAccessToken + '&content_uuid=' + encodeURIComponent(uuid) + '&device_id=' + _userDetails.devices[0].id + '&content_type=' + encodeURIComponent(file.type);

	        // Open the connection.
	        xhr.open('POST', url, true);

	        // Set up a handler for when the request finishes.
	        xhr.onreadystatechange = function () {
	            if (xhr.readyState === 4) { // 4 === done
	                if (xhr.status === 200) {
	                    var result = JSON.parse(xhr.responseText);

	                    if (result.status === responseCodes.OK) {
	                        // File(s) uploaded.
	                        if (success) {
	                            success(uuid);
	                        }
	                    } else if (failure) {
	                        failure(result.message, result.status);
	                    }

	                } else {
	                    if (failure) {
	                        failure('Request Error', '500');
	                    }
	                }
	            }
	        };

	        // Send the Data.
	        xhr.send(formData);

	        return function() {
	          xhr.abort();
	        };
	    };

	    /**
	     * Builds a url to retrieve a previously uploaded file.
	     *
	     * @method buildFileUrl
	     * @param {String} uuid UUID for file that you would receive in an instant message.
	     * @return {String} url Url pointing to the uploaded file.
	     */
	    me.buildFileUrl = function (uuid) {
	        return _config.kandyApiUrl + '/devices/content?key=' + _userDetails.userAccessToken + '&content_uuid=' + encodeURIComponent(uuid) + '&device_id=' + _userDetails.devices[0].id;
	    };

	    /**
	     * Builds a Url to retrieve a thumbnail of a previously uploaded image file.
	     *
	     * @method buildFileThumbnailUrl
	     * @param {String} uuid UUID for file that you would receive in an instant message.
	     * @param {String} size The size of the thumbnail. Values are "small", "medium" and "large". The Default is "large".
	     * @return {String} url Url pointing to the thumbnail of the uploaded image file.
	     */
	    me.buildFileThumbnailUrl = function (uuid, size) {
	        size = size || 'large';

	        return _config.kandyApiUrl + '/devices/content/thumbnail?key=' + _userDetails.userAccessToken + '&content_uuid=' + encodeURIComponent(uuid) + '&device_id=' + _userDetails.devices[0].id + '&thumbnail_size=' + size;
	    };

	    /**
	     * Retrieves IM messages that were missed while offline. Please listen for the "message" event to receive messages while online.
	     *
	     * @method getIm
	     * @deprecated Use `kandy.messaging.getConversations` and `kandy.messaging.getMessages` instead.
	     * @async
	     * @param {Function} success The success callback. It receives one parameter.
	     * @param {Message[]} success.messages An array of messages
	     * @param {Function} failure The failure callback. It receives one parameter.
	     * @param {String} failure.errorMessage The error message explaining what failed.
	     * @example
	     * Here is an example of a result given to the success function.
	     * ``` javascript
	     *  [
	     *      {
	     *          "messageType":"chat",
	     *          "sender":
	     *          {
	     *              "user_id":"972542205056",
	     *              "domain_name":"domain.com",
	     *              "full_user_id":"972542205056@domain.com"
	     *           },
	     *          "UUID":"acd2fa752c3c4edf97de8b0a48f622f0",
	     *          "timestamp":"1400510413",
	     *          "message":
	     *          {
	     *              "mimeType": "text/plain",
	     *              "text": "let's meet tonight"
	     *          }
	     *      }
	     *  ]
	     * ```
	     */
	    me.getIm = function (success, failure, autoClear) {

	        _logger.info('Consider using the message event instead of fetching messages');

	        if (autoClear === undefined) {
	            autoClear = true;
	        }

	        _kandyRequest({
	            url: '/devices/messages',
	            params: {
	                'device_id': _userDetails.devices[0].id
	            },
	            success: function (response) {
	                var incoming;
	                if (success) {

	                    if (response.result.messages.length) {
	                        // prepare id list for clearing
	                        var idList = response.result.messages.map(function (item) {
	                            return item.UUID;
	                        });

	                        // make sure UUIDs have hyphens
	                        response.result.messages = response.result.messages.map(function (msg) {
	                            if (msg.UUID.indexOf('-') === -1) {
	                                msg.UUID = [msg.UUID.substring(0, 8),
	                                    msg.UUID.substring(8, 12),
	                                    msg.UUID.substring(12, 16),
	                                    msg.UUID.substring(16, 20),
	                                    msg.UUID.substring(20, msg.UUID.length)
	                                ].join('-');
	                            }
	                            return msg;
	                        });
	                    }

	                    success(response.result);

	                    if (autoClear && response.result.messages.length) {
	                        me.clearIm(idList);
	                    }
	                }
	            },
	            failure: failure
	        });
	    };

	    /*
	     * Removes IM messages
	     *
	     * @method clearIm
	     * @deprecated Use kandy.messaging.deleteMessages instead.
	     * @async
	     * @param {Array} ids Id of IMs to remove.
	     * @param {Function} failure The failure callback.
	     * @return {Object} response An array of messages
	     */
	    me.clearIm = function (ids, success, failure) {
	        var i = 0;
	        for (; i < ids.length; i += 10) {
	            // TODO: Once we have promises we should handle the success and failure callbacks properly.
	            _kandyRequest({
	                type: 'DELETE',
	                url: '/devices/messages',
	                params: {
	                    messages: ids.slice(i, i + 10),
	                    'device_id': _userDetails.devices[0].id
	                },
	                failure: failure
	            });
	        }
	    };

	    /**
	     * Get a list of conversations for the current user.
	     *
	     * @method getConversations
	     * @param {Function} success The success callback. It receives one parameter.
	     * @param {Conversation[]} success.conversations An array of conversations.
	     * @param {Function} failure The failure callback. It receives one parameter.
	     * @param {String} failure.errorMessage The error message explaining what failed.
	     */
	    me.getConversations = function(success, failure) {
	        _kandyRequestAsync({
	            type: 'GET',
	            url: '/users/messages/conversations'
	        })
	        .then(function(response) {
	            return response.result.conversations;
	        })
	        .then(success, failure);
	    };

	    /**
	     * Deletes one or many conversations.
	     *
	     * @method deleteConversations
	     * @param {String[]} conversationIds A list of fully qualified usernames (e.g. user@domain.com) or group ids.
	     * @param {Function} success The success callback. It receives no parameters.
	     * @param {Function} failure The failure callback. It receives one parameter.
	     * @param {String} failure.errorMessage The error message explaining what failed.
	     */
	    me.deleteConversations = function(conversationIds, success, failure) {
	        _kandyRequestAsync({
	            type: 'DELETE',
	            url: '/users/messages/conversations/conversation',
	            params: {
	                conversations: conversationIds
	            }
	        })
	        .then(function(){
	            // Discard the result on success.
	        })
	        .then(success, failure);
	    };

	    /**
	     * Get a list of messages from a specific conversation.
	     *
	     * @method getMessages
	     * @param {String} conversationId The identification for the conversation to retrieve. This can
	     *                                either be a fully-qualified username or a group id for group conversations.
	     * @param {Object} options Filter options to restrict the number of messages retrieved.
	     * @param {Number} options.limit The maximum number of messages to retrieve.
	     * @param {Number} options.startSequence The sequence number from which to retrieve messages.
	     * @param {Number} options.startTimestamp The timestamp (in msec since the epoch) from which to retrieve messages.
	     * @param {String} options.order The order in which to retrieve the messages, can be `asc` for ascending or `desc` for
	     *                               descending.
	     * @param {Function} success The success callback. It receives one parameter.
	     * @param {Message[]} success.messages An array of messages.
	     * @param {Function} failure The failure callback. It receives one parameter.
	     * @param {String} failure.errorMessage The error message explaining what failed.
	     */
	    me.getMessages = function(conversationId, options, success, failure) {

	        // Set the defaults for options.
	        options = options || {};

	        // Convert the order parameter.
	        var order;
	        if (options.order === 'asc') {
	            order = 'forward';
	        } else if (options.order === 'desc') {
	            order = 'backward';
	        }

	        // Convert the rest of the parameters.
	        var params = {
	            'conversation_id': conversationId,
	            'conversation_type': conversationId.indexOf('@') === -1 ? 'group' : 'single',
	            'number_of_records': options.limit,
	            'message_sequence_number': options.startSequence,
	            'timestamp': options.startTimestamp,
	            'order': order
	        };

	        _kandyRequestAsync({
	            type: 'GET',
	            url: '/users/messages/conversations/conversation',
	            params: params
	        })
	        .then(function(response){
	            return response.result.messages;
	        })
	        .then(success, failure);
	    };

	    /**
	     * Deletes one or many messages.
	     *
	     * @method deleteMessages
	     * @param {String} conversationId A fully qualified username (e.g. user@domain.com) or group id.
	     * @param {String[]} messageIds A list of message ids (e.g. `Message.UUID`) to delete.
	     * @param {Function} success The success callback. It receives no parameters.
	     * @param {Function} failure The failure callback. It receives one parameter.
	     * @param {String} failure.errorMessage The error message explaining what failed.
	     */
	    me.deleteMessages = function(conversationId, messageIds, success, failure) {
	        _kandyRequestAsync({
	            type: 'DELETE',
	            url: '/users/messages/conversations/conversation/messages',
	            params: {
	                'conversation_id': conversationId,
	                messages: messageIds
	            }
	        })
	        .then(function () {
	            // Discard the result on success.
	        })
	        .then(success, failure);
	    };

	    /**
	     * Gets the list of groups of which the current user is a part.
	     *
	     * @method getGroups
	     * @async
	     * @param {Function} success The success callback. It receives one parameter.
	     * @param {Object} success.result Object containing list of groups.
	     * @param {Group[]} success.result.groups An array of Group objects.
	     * @param {Function} failure The failure callback. It receives one parameter.
	     * @param {String} failure.errorMessage The error message explaining what failed.
	     * @example
	     * Here is an example of a result given to the success function.
	     * ``` javascript
	     *     {
	     *         groups: [
	     *             Group objects
	     *         ]
	     *  }
	     * ```
	     */
	    me.getGroups = function (success, failure){
	        _kandyRequest({
	            url: '/users/chatgroups',
	            success: function (response) {
	                if (success) {
	                    success(response.result);
	                }
	            },
	            failure: failure
	        });
	    };

	    /**
	     * Creates a new group. The user that creates the group is designated as the group owner.
	     *
	     * @method createGroup
	     * @async
	     * @param {String} name The name of the group to create.
	     * @param {File} image The image file of the group to create.
	     * @param {Function} success The success callback. It receives one parameter.
	     * @param {Group} success.group Group object that was just created.
	     * @param {Function} failure The failure callback. It receives one parameter.
	     * @param {String} failure.errorMessage The error message explaining what failed.
	     * @return {Function} abort A function you can call to cancel the upload. Only returns this function if an image is provided.
	     */
	    me.createGroup = function (name, image, success, failure){
	        function createGroup(imageObject) {
	            var data = {
	                'group_name': name,
	                'group_image': imageObject
	            };

	            _kandyRequest({
	                type: 'POST',
	                data: data,
	                url: '/users/chatgroups',
	                success: function (response) {
	                    if (success) {
	                        success(response.result);
	                    }
	                },
	                failure: failure
	            });
	        }

	        if (!image) {
	            createGroup(null);
	            return;
	        }

	        return me.uploadFile(image,
	            function(uuid) {
	                createGroup({
	                    content_name: image.name || uuid,
	                    content_uuid: uuid,
	                    file_length_bytes: image.size
	                });
	            },
	            failure
	        );
	    };

	    /**
	     * Gets group with a given group id.
	     *
	     * @method getGroupById
	     * @async
	     * @param {String} groupId The group id to get group details.
	     * @param {Function} success The success callback. It receives one parameter.
	     * @param {Group} success.group The requested group object.
	     * @param {Function} failure The failure callback. It receives one parameter.
	     * @param {String} failure.errorMessage The error message explaining what failed.
	     */
	    me.getGroupById = function (groupId, success, failure){
	        _kandyRequest({
	            url: '/users/chatgroups/chatgroup',
	            params: {
	                'group_id': groupId
	            },
	            success: function (response) {
	                if (success) {
	                    success(response.result);
	                }
	            },
	            failure: failure
	        });
	    };

	    /**
	     * Delete a group with a given id. Only the group owner can delete a group.
	     *
	     * @method deleteGroup
	     * @async
	     * @param {String} groupId The id of the group.
	     * @param {Function} success The success callback. It receives no parameters.
	     * @param {Function} failure The failure callback. It receives one parameter.
	     * @param {String} failure.errorMessage The error message explaining what failed.
	     */
	    me.deleteGroup = function (groupId, success, failure){
	        _kandyRequest({
	            type: 'DELETE',
	            url: '/users/chatgroups/chatgroup',
	            params: {
	                'group_id': groupId
	            },
	            success: function (response) {
	                if (success) {
	                    success(response.result);
	                }
	            },
	            failure: failure
	        });
	    };

	    /**
	     * Update group with new information.
	     *
	     * @method updateGroup
	     * @async
	     * @param {String} groupId The id of the group.
	     * @param {String} name The name of the group.
	     * @param {File} image The image file of the group.
	     * @param {Function} success The success callback. It receives one parameter.
	     * @param {Group} success.group The updated group object.
	     * @param {Function} failure The failure callback. It receives one parameter.
	     * @param {String} failure.errorMessage The error message explaining what failed.
	     */
	    me.updateGroup = function (groupId, name, image, success, failure){
	        function updateGroup(imageObject) {
	            var data = {
	                'group_id': groupId,
	                'group_name': name,
	                'group_image': imageObject
	            };

	            _kandyRequest({
	                type: 'PUT',
	                data: data,
	                url: '/users/chatgroups/chatgroup',
	                success: function (response) {
	                    if (success) {
	                        success(response.result);
	                    }
	                },
	                failure: failure
	            });
	        }

	        if (!image) {
	            updateGroup(null);
	            return;
	        }

	        me.uploadFile(image,
	            function(uuid) {
	                updateGroup({
	                    content_name: image.name || uuid,
	                    content_uuid: uuid,
	                    file_length_bytes: image.size
	                });
	            },
	            failure
	        );
	    };

	    /**
	     * Add members to the group.
	     *
	     * @method addGroupMembers
	     * @async
	     * @param {String} groupId The id of the group.
	     * @param {Array} members The list of new members to add to the group.
	     * @param {Function} success The success callback. It receives one parameter.
	     * @param {Group} success.group The updated group object.
	     * @param {Function} failure The failure callback. It receives one parameter.
	     * @param {String} failure.errorMessage The error message explaining what failed.
	     * @example
	     * Here is an example of the members parameter.
	     * ``` javascript
	     *  [
	     *      'user1@test.kandy.io',
	     *      'user2@test.kandy.io'
	     *  ]
	     * ```
	     */
	    me.addGroupMembers = function (groupId, members, success, failure){
	        var data = {
	            members: members
	        };
	        _kandyRequest({
	            type: 'POST',
	            url: '/users/chatgroups/chatgroup/members',
	            params: {
	                'group_id': groupId
	            },
	            data: data,
	            success: function (response) {
	                if (success) {
	                    success(response.result);
	                }
	            },
	            failure: failure
	        });
	    };

	    /**
	     * Removes members from the group.
	     *
	     * @method removeGroupMembers
	     * @async
	     * @param {String} groupId The id of the group.
	     * @param {Array} members The list of members to remove from the group.
	     * @param {Function} success The success callback. It receives one parameter.
	     * @param {Group} success.group The updated group object.
	     * @param {Function} failure The failure callback. It receives one parameter.
	     * @param {String} failure.errorMessage The error message explaining what failed.
	     * @example
	     * Here is an example of the members parameter.
	     * ``` javascript
	     *  [
	     *      'user1@test.kandy.io',
	     *      'user2@test.kandy.io'
	     *  ]
	     * ```
	     */
	    me.removeGroupMembers = function (groupId, members, success, failure){
	        _kandyRequest({
	            type: 'DELETE',
	            url: '/users/chatgroups/chatgroup/members',
	            params: {
	                'group_id': groupId,
	                members: members
	            },
	            success: function (response) {
	                if (success) {
	                    success(response.result);
	                }
	            },
	            failure: failure
	        });
	    };

	    /**
	     * Leave a group with a given id. If the owner leaves the group, a group member is assigned as the new owner. If there are no group members when the owner leaves, the group is deleted.
	     *
	     * @method leaveGroup
	     * @async
	     * @param {String} groupId The id of the group.
	     * @param {Function} success The success callback. It receives no parameters.
	     * @param {Function} failure The failure callback. It receives one parameter.
	     * @param {String} failure.errorMessage The error message explaining what failed.
	     */
	    me.leaveGroup = function (groupId, success, failure){
	        _kandyRequest({
	            type: 'DELETE',
	            url: '/users/chatgroups/chatgroup/members/membership',
	            params: {
	                'group_id': groupId
	            },
	            success: function (response) {
	                if (success) {
	                    success(response.result);
	                }
	            },
	            failure: failure
	        });
	    };

	    /*
	     * Mute/unmute the group.
	     *
	     * @method muteUnmuteGroup
	     * @async
	     * @param {String} groupId The id of the group.
	     * @param {Function} success The success callback function.
	     * @param {Function} failure The error callback function.
	     * @param {Boolean} mute To set true/false for mute/unmute the group.
	     */
	    function muteUnmuteGroup(groupId, success, failure, mute){
	        _kandyRequest({
	            type: 'PUT',
	            url: '/users/chatgroups/chatgroup/mute',
	            params: {
	                mute: mute,
	                'group_id': groupId
	            },
	            success: function (response) {
	                if (success) {
	                    success(response.result);
	                }
	            },
	            failure: failure
	        });
	    }

	    /**
	     * Mute a group with a given id.
	     *
	     * @method muteGroup
	     * @async
	     * @param {String} groupId The id of the group.
	     * @param {Function} success The success callback. It receives one parameter.
	     * @param {Group} success.group The updated group object.
	     * @param {Function} failure The failure callback. It receives one parameter.
	     * @param {String} failure.errorMessage The error message explaining what failed.
	     */
	    me.muteGroup = function (groupId, success, failure){
	        muteUnmuteGroup(groupId, success, failure, true);
	    };

	    /**
	     * Unmute a group with a given id.
	     *
	     * @method unmuteGroup
	     * @async
	     * @param {String} groupId The id of the group.
	     * @param {Function} success The success callback. It receives one parameter.
	     * @param {Group} success.group The updated group object.
	     * @param {Function} failure The failure callback. It receives one parameter.
	     * @param {String} failure.errorMessage The error message explaining what failed.
	     */

	    me.unmuteGroup = function (groupId, success, failure){
	        muteUnmuteGroup(groupId, success, failure, false);
	    };

	    /*
	     * Mute/unmute members of the group.
	     *
	     * @method muteUnmuteGroup
	     * @async
	     * @param {String} groupId The id of the group.
	     * @param {Array} members The list of members to mute/unmute in the group.
	     * @param {Function} success The success callback. It receives no parameters.
	     * @param {Function} failure The failure callback. It receives no parameters.
	     * @param {Boolean} mute To set true/false for mute/unmute members of the group.
	     */
	    function muteUnmuteGroupMembers(groupId, members, success, failure, mute){

	        var data = {
	            members: members,
	            mute: mute,
	            'group_id': groupId
	        };

	        _kandyRequest({
	            type: 'PUT',
	            data: data,
	            url: '/users/chatgroups/chatgroup/members/mute',
	            success: function (response) {
	                if (success) {
	                    success(response.result);
	                }
	            },
	            failure: failure
	        });
	    }

	    /**
	     * Mutes group members.
	     *
	     * @method muteGroupMembers
	     * @async
	     * @param {String} groupId The id of the group.
	     * @param {Array} members The list of members to mute in the group.
	     * @param {Function} success The success callback. It receives one parameter.
	     * @param {Group} success.group The updated group object.
	     * @param {Function} failure The failure callback. It receives one parameter.
	     * @param {String} failure.errorMessage The error message explaining what failed.
	     * @example
	     * Here is an example of the members parameter.
	     * ``` javascript
	     *  [
	     *      'user1@test.kandy.io',
	     *      'user2@test.kandy.io'
	     *  ]
	     * ```
	     */
	    me.muteGroupMembers = me.muteGroupMember = function (groupId, members, success, failure){
	        muteUnmuteGroupMembers(groupId, members, success, failure, true);
	    };

	    /**
	     * Unmutes group members.
	     *
	     * @method unmuteGroupMembers
	     * @async
	     * @param {String} groupId The id of the group.
	     * @param {Array} members The list of members to unmute in the group.
	     * @param {Function} success The success callback. It receives one parameter.
	     * @param {Group} success.group The updated group object.
	     * @param {Function} failure The failure callback. It receives one parameter.
	     * @param {String} failure.errorMessage The error message explaining what failed.
	     * @example
	     * Here is an example of the members parameter.
	     * ``` javascript
	     *  [
	     *      'user1@test.kandy.io',
	     *      'user2@test.kandy.io'
	     *  ]
	     * ```
	     */
	    me.unmuteGroupMembers = me.unmuteGroupMember = function (groupId, members, success, failure){
	        muteUnmuteGroupMembers(groupId, members, success, failure, false);
	    };

	    /**
	     * Sends a message to all the members in the group.
	     *
	     * @method sendGroupIm
	     * @async
	     * @param {String} groupId The id of the group.
	     * @param {String} text The message to send.
	     * @param {Function} success The success callback. It receives one parameter.
	     * @param {Message} success.message The message that was sent.
	     * @param {Function} failure The failure callback. It receives one parameter.
	     * @param {String} failure.errorMessage The error message explaining what failed.
	     * @param {Object} options Object of options for the message.
	     * @param {Object} options.additionalData Object with arbitrary metadata about the IM.
	     * @return {Function} abort A function you can call to cancel the upload.
	     */
	    me.sendGroupIm = function (groupId, text, success, failure, options) {
	        return _sendIM(groupId, _imContentTypes.TEXT, { mimeType: 'text/plain', text: text }, success, failure, true, options);
	    };

	    /**
	     * Sends a file to all the members in the group.
	     *
	     * @method sendGroupImWithFile
	     * @async
	     * @param {String} groupId The id of the group.
	     * @param {File} file The file object to send.
	     * @param {Function} success The success callback. It receives one parameter.
	     * @param {Message} success.message The message that was sent.
	     * @param {Function} failure The failure callback. It receives one parameter.
	     * @param {String} failure.errorMessage The error message explaining what failed.
	     * @param {Object} options Object of options for the message.
	     * @param {Object} options.additionalData Object with arbitrary metadata about the IM.
	     * @return {Function} abort A function you can call to cancel the upload.
	     */
	    me.sendGroupImWithFile = function (groupId, file, success, failure, options) {
	        return _sendImWithAttachment(groupId, file, _imContentTypes.FILE, success, failure, true, options);
	    };

	    /**
	     * Sends an image to all the members in the group.
	     *
	     * @method sendGroupImWithImage
	     * @async
	     * @param {String} groupId The id of the group.
	     * @param {File} file The image file object to send.
	     * @param {Function} success The success callback. It receives one parameter.
	     * @param {Message} success.message The message that was sent.
	     * @param {Function} failure The failure callback. It receives one parameter.
	     * @param {String} failure.errorMessage The error message explaining what failed.
	     * @param {Object} options Object of options for the message.
	     * @param {Object} options.additionalData Object with arbitrary metadata about the IM.
	     * @return {Function} abort A function you can call to cancel the upload.
	     */
	    me.sendGroupImWithImage = function (groupId, file, success, failure, options) {
	        return _sendImWithAttachment(groupId, file, _imContentTypes.IMAGE, success, failure, true, options);
	    };

	    /**
	     * Sends an audio file to all the members in the group.
	     *
	     * @method sendGroupImWithAudio
	     * @async
	     * @param {String} groupId The id of the group.
	     * @param {File} file The audio file object to send.
	     * @param {Function} success The success callback. It receives one parameter.
	     * @param {Message} success.message The message that was sent.
	     * @param {Function} failure The failure callback. It receives one parameter.
	     * @param {String} failure.errorMessage The error message explaining what failed.
	     * @param {Object} options Object of options for the message.
	     * @param {Object} options.additionalData Object with arbitrary metadata about the IM.
	     * @return {Function} abort A function you can call to cancel the upload.
	     */
	    me.sendGroupImWithAudio = function (groupId, file, success, failure, options) {
	        return _sendImWithAttachment(groupId, file, _imContentTypes.AUDIO, success, failure, true, options);
	    };

	    /**
	     * Sends a contact file to all the members in the group.
	     *
	     * @method sendGroupImWithContact
	     * @async
	     * @param {String} groupId The id of the group.
	     * @param {File} vCard The contact file object to send.
	     * @param {Function} success The success callback. It receives one parameter.
	     * @param {Message} success.message The message that was sent.
	     * @param {Function} failure The failure callback. It receives one parameter.
	     * @param {String} failure.errorMessage The error message explaining what failed.
	     * @param {Object} options Object of options for the message.
	     * @param {Object} options.additionalData Object with arbitrary metadata about the IM.
	     * @return {Function} abort A function you can call to cancel the upload.
	     */
	    me.sendGroupImWithContact = function (groupId, vCard, success, failure, options) {
	        return _sendImWithAttachment(groupId, vCard, _imContentTypes.CONTACT, success, failure, true, options);
	    };

	    /**
	     * Sends a video file to all the members in the group.
	     *
	     * @method sendGroupImWithVideo
	     * @async
	     * @param {String} groupId The id of the group.
	     * @param {File} file The video file object to send.
	     * @param {Function} success The success callback. It receives one parameter.
	     * @param {Message} success.message The message that was sent.
	     * @param {Function} failure The failure callback. It receives one parameter.
	     * @param {String} failure.errorMessage The error message explaining what failed.
	     * @param {Object} options Object of options for the message.
	     * @param {Object} options.additionalData Object with arbitrary metadata about the IM.
	     * @return {Function} abort A function you can call to cancel the upload.
	     */
	    me.sendGroupImWithVideo = function (groupId, file, success, failure, options) {
	        return _sendImWithAttachment(groupId, file, _imContentTypes.VIDEO, success, failure, true, options);
	    };

	    /**
	     * Sends a JSON object to all the members in the group.
	     *
	     * @method sendGroupJSON
	     * @async
	     * @param {String} groupId The id of the group.
	     * @param {Object} object The JSON object to send.
	     * @param {Function} success The success callback. It receives one parameter.
	     * @param {Message} success.message The message that was sent.
	     * @param {Function} failure The failure callback. It receives one parameter.
	     * @param {String} failure.errorMessage The error message explaining what failed.
	     * @param {Object} options Object of options for the message.
	     * @param {Object} options.additionalData Object with arbitrary metadata about the IM.
	     * @return {String} uuid Unique string identifier for the sent message.
	     */
	    me.sendGroupJSON = function (groupId, object, success, failure, options) {
	        return _sendJSON(groupId, object, success, failure, true, options);
	    };

	    /**
	     * Sends a location object to all the members in the group.
	     *
	     * @method sendGroupImWithLocation
	     * @async
	     * @param {String} groupId The id of the group.
	     * @param {Object} location The location object to send.
	     * @param {String} location.longitude Location's longitude
	     * @param {String} location.latitude Location's latitude
	     * @param {Function} success The success callback. It receives one parameter.
	     * @param {Message} success.message The message that was sent.
	     * @param {Function} failure The failure callback. It receives one parameter.
	     * @param {String} failure.errorMessage The error message explaining what failed.
	     * @param {Object} options Object of options for the message.
	     * @param {Object} options.additionalData Object with arbitrary metadata about the IM.
	     * @return {String} uuid Unique string identifier for the sent message.
	     */
	    me.sendGroupImWithLocation = function (groupId, location, success, failure, options) {
	        return _sendImWithLocation(groupId, location, success, failure, true, options);
	    };

	    function _notificationHandler(message) {
	        var msg = message.message;
	        if(msg){
	            var msgType = msg.messageType;
	            if (msgType === 'chat') {
	                events.emit('message', msg);
	            } else if (msgType === 'groupChat') {
	                events.emit('chatGroupMessage', msg);
	            } else if (msgType === 'chatGroupInvite') {
	                events.emit('chatGroupInvite', msg);
	            } else if (msgType === 'chatGroupBoot') {
	                events.emit('chatGroupBoot', msg);
	            } else if (msgType === 'chatGroupLeave') {
	                events.emit('chatGroupLeave', msg);
	            } else if (msgType === 'chatGroupUpdate') {
	                events.emit('chatGroupUpdate', msg);
	            } else if (msgType === 'chatGroupDelete') {
	                events.emit('chatGroupDelete', msg);
	            } else if (msgType === 'chatRemoteAck') {
	                events.emit('chatRemoteAck', msg);
	            }
	        }
	    }

	    registerWebSocketListeners({
	        'notification': _notificationHandler
	    });

	    return me;
	}());

	/**
	 * Kandy call is used to make calls (audio and video) from Kandy users to other Kandy
	 * users, PSTN phones or SIP endpoints.
	 *
	 * @class call
	 * @namespace kandy
	 * @static
	 */

	var _logInToSpidr;
	var _logOutOfSpidr;
	var _setupCall;

	api.Phone = api.call = api.voice = (function () {
	    var me = {};

	    /*
	     * Domain API Key token.
	     */
	    var _domainApiKey = null;

	    /*
	     *  Holds call types.
	     */
	    var _callTypes = {
	        INCOMING_CALL: 1,
	        OUTGOING_CALL: 2
	    };

	    /*
	     * Types of presence.
	     */
	    var _presenceTypes = {
	        0: 'Available',
	        1: 'Unavailable',
	        2: 'Away',
	        3: 'Out To Lunch',
	        4: 'Busy',
	        5: 'On Vacation',
	        6: 'Be Right Back',
	        7: 'On The Phone',
	        8: 'Active',
	        9: 'Inactive',
	        10: 'Pending',
	        11: 'Offline'
	    };

	    var _pluginUrls = {
	        urlWin32bit: 'https://kandy-portal.s3.amazonaws.com/public/plugin/3.1.520/Kandy_Plugin_3.1.520.exe',
	        urlWin64bit: 'https://kandy-portal.s3.amazonaws.com/public/plugin/3.1.520/Kandy_Plugin_3.1.520_x86_64.exe',
	        urlMacUnix: 'https://kandy-portal.s3.amazonaws.com/public/plugin/3.1.520/Kandy_Plugin_3.1.520.pkg'
	    };

	    /*
	     * call objects.
	     */
	    var _calls = [];

	    var _mediaInitiated = false;

	    var _initMediaDone = false;

	    /*
	     * Information about the local, non-call video stream.
	     */
	    var localStream = null;

	    /*
	     * Local storage key
	     */
	    var __kandyUAT = 'kandyUAT';

	    // This should be lower camel case but we will leave it for backwards compat.
	    // There is a property mediaErrors below that is documented and more official.
	    me.MediaErrors = fcs.call.MediaErrors;

	    /*
	     * Starts infra-frame coding for compression
	     *
	     * @method _startIntraFrame
	     * @param {Object} call The call Object
	     */
	    function _startIntraFrame(call) {
	        if (!call.intraframe) {
	            call.intraframe = setInterval(function () {
	                call.sendIntraFrame();
	            }, 5000);
	        }
	    }

	    /*
	     * Stops infra-frame coding for compression
	     *
	     * @method _stopIntraFrame
	     * @param {Object} call The call Object
	     */
	    function _stopIntraFrame(call) {
	        if (call.intraframe) {
	            clearInterval(call.intraframe);
	            delete call.intraframe;
	        }
	    }

	    /*
	     * Handles call state changes
	     *
	     * @method _handleCallStateChange
	     * @param {Call} call The call object
	     * @param {State} state The state of the call
	     */
	    function _handleCallStateChange(call, state, payload) {
	        payload = payload || {};

	        switch(state) {
	            case fcs.call.States.IN_CALL:
	                if (call.canSendVideo()) {
	                    _startIntraFrame(call);
	                }

	                // This is kept for backwards compatibility.
	                events.emit('oncall', call);

	                if (call._remoteHold) {
	                    events.emit('callunhold');
	                    call._remoteHold = false;
	                }

	                if (!call._established) {
	                    events.emit('callestablished', call);
	                    call._established = true;
	                } else {
	                    events.emit('callstatechanged', call);
	                }

	                break;
	            case fcs.call.States.RENEGOTIATION:
	                events.emit('callstatechanged', call);
	                break;
	            case fcs.call.States.RINGING:
	                events.emit('ringing', call.getId());
	                break;
	            case fcs.call.States.ENDED:
	                if (call) {
	                    _stopIntraFrame(call);

	                    if (call.isAnonymous && call.isOutgoing) {
	                        me.logout();
	                    }

	                    delete _calls[call.getId()];
	                    events.emit('callended', call, payload);
	                }
	                break;
	            case fcs.call.States.ON_REMOTE_HOLD:
	                call._remoteHold = true;
	                events.emit('callhold', call);

	                break;
	            case fcs.call.States.TRANSFERRED:
	                events.emit('calltransferred', call);
	                break;
	            case fcs.call.States.TRANSFER_FAILURE:
	                events.emit('calltransferfailed', call);
	                break;
	        }
	    }

	    /*
	     * Handles presence notifications, fires the presencenotification event
	     *
	     * @method _handlePresenceNotification
	     * @param {Presence} presence The Presence object
	     */
	    function _handlePresenceNotification(presence) {
	        if (presence.state === null) {
	            _logger.info('State is empty.');
	            return;
	        }

	        if (presence.name === null) {
	            _logger.info('Name is empty.');
	            return;
	        }
	        events.emit('presencenotification', presence.name, presence.state, _presenceTypes[presence.state], presence.activity);
	    }


	    /*
	     * Checks if local storage is available
	     *
	     * @method _supportsLocalStorage
	     */
	    function _supportsLocalStorage() {
	        try {
	            return 'localStorage' in window && window.localStorage !== null;
	        } catch (e) {
	            return false;
	        }
	    }

	    /*
	     * Set access token in local storage
	     *
	     * @method _setUserInformationLocalStorage
	     * @param {String} password Password to set
	     */
	    function _setUserInformationLocalStorage(userAccessToken) {
	        localStorage[__kandyUAT] = userAccessToken;
	        return true;
	    }

	    /*
	     * Get access token from local storage
	     *
	     * @method _getUserInformationLocalStorage
	     */
	    function _getUserInformationLocalStorage() {
	        return localStorage[__kandyUAT];
	    }

	    /*
	     * Clears access token from local storage
	     *
	     * @method _clearAccessTokeLocalStorage
	     */
	    function _clearAccessTokeLocalStorage() {
	        localStorage.removeItem(__kandyUAT);
	        return true;
	    }

	    // TODO: Move configuration for different versions into a strategy pattern.

	    /*
	     * Maps the spider configs retrived from getSpiderConfiguration to fcs configs which can then be passed to fcs.setup
	     *
	     * @method _mapSpidrConfigToAPI
	     * @param {Object} spidrConfig Spider config from getSpiderConfiguration
	     */
	    function _mapSpidrConfigToAPI(spidrConfig) {

	        // In newer version (2.2.1+) we don't do any parsing of the parameters and pass them through directly if the server
	        // configuration also supports it.
	        if (spidrConfig.fcsApi) {
	            return spidrConfig.fcsApi;
	        }

	        return {
	            notificationType: fcs.notification.NotificationTypes.WEBSOCKET,
	            restUrl: spidrConfig.REST_server_address,
	            restPort: spidrConfig.REST_server_port,
	            websocketIP: spidrConfig.webSocket_server_address,
	            websocketPort: spidrConfig.webSocket_server_port,
	            websocketProtocol: (spidrConfig.webSocket_secure !== false ? 'wss' : 'ws'),
	            protocol: spidrConfig.REST_protocol,
	            serverProvidedTurnCredentials: spidrConfig.serverProvidedTurnCredentials
	        };
	    }

	    /*
	     * Maps the spider configs retrived from getSpiderConfiguration to spidrEnv config which can then be passed to fcs.call.initMedia
	     *
	     * @method _mapSpidrConfigToMedia
	     * @param {Object} spidrConfig Spider config from getSpiderConfiguration
	     */
	    function _mapSpidrConfigToMedia(spidrConfig) {

	        // In newer version (2.2.1+) we don't do any parsing of the parameters and pass them through directly if the server
	        // configuration also supports it.
	        if (spidrConfig.fcsMedia) {
	            return spidrConfig.fcsMedia;
	        }

	        if (spidrConfig.ICE_servers) {
	            utils.extend(spidrConfig,
	                {
	                    'ICE_server_address': spidrConfig.ICE_servers[0],
	                    'ICE_server_port': ''
	                }
	            );
	        }

	        return {
	            iceserver: spidrConfig.ICE_server_address,
	            iceserverPort: spidrConfig.ICE_server_port,
	            webrtcdtls: spidrConfig.use_DTLS
	        };
	    }

	    /*
	     * merges _config with spidr config retrived from getSpidrConfiguration
	     *
	     * @method _mergeConfigWithSpidrConfiguration
	     * @param {Object} spidrConfig Spider config from getSpiderConfiguration
	     */
	    function _mergeConfigWithSpidrConfiguration(spidrConfig) {

	        // merge with configs from KandyAPI.Phone.setup
	        _config.spidrApi = utils.defaults(_mapSpidrConfigToAPI(spidrConfig), _config.spidrApi);

	        // apply default SPiDR configuration
	        _config.spidrMedia = utils.defaults(_mapSpidrConfigToMedia(spidrConfig), _config.spidrMedia);

	        // If kandy.setup is called with screensharing config, we assign
	        // to this spidrApi config
	        if (_config.screenSharing) {
	            _config.spidrApi.screenSharing = _config.screenSharing;
	        }

	        if (_config.screenSharingChromeExtensionId) {
	            _config.spidrMedia.screenSharingChromeExtensionId = _config.screenSharingChromeExtensionId;
	        }
	    }

	    /*
	     * Processes versioned configuration. This mechanism is in place to allow changes to domain configuration
	     * for new versions of Kandy.js without impacting old versions.
	     */
	    function _processSpiderConfigurationVersion(config) {
	        var versions = config.versions;
	        if (versions) {
	            // Remove the versions from the root config.
	            delete config.versions;

	            // Get the versions up until the current version.
	            var currentVersions = versions.slice(0, _config.version + 1);

	            // Deep extend each version with the next.
	            utils.deepExtend.apply(undefined, [config].concat(currentVersions));
	        }
	        return config;
	    }

	    function _applySpiderConfiguration(spidrConfig, success, failure, password) {

	        // Process version config.
	        _processSpiderConfigurationVersion(spidrConfig);

	        // merge _config with spirdConfig
	        _mergeConfigWithSpidrConfiguration(spidrConfig);

	        // setup SPiDR with fcsConfig
	        fcs.setup(_config.spidrApi);

	        if (spidrConfig.useProxy) {
	            fcs.setKandyUAT(_userDetails.userAccessToken);
	        }

	        fcs.setUserAuth(_userDetails.full_user_id, password);

	        fcs.notification.start(
	                function () {
	                    // if the browser supports local storage persist the Access Token
	                    if (_config.allowAutoLogin && _supportsLocalStorage()) {
	                        _setUserInformationLocalStorage(_userDetails.userAccessToken);
	                    }
	                    success();
	                },
	                function (errorCode) {
	                    _logger.error('login failed: unable to start spidr notification');
	                    failure(errorCode);
	                },
	                false
	        );
	    }

	    // This is needed by some advanced users.
	    api.internal.applySpiderConfiguration = _applySpiderConfiguration;

	    function _getSpidrConfiguration(success, failure) {
	        _kandyRequest({
	            url: '/users/configurations/communications/spidr',
	            params: {
	                secure: true
	            },
	            success: function (response) {
	                if (success) {
	                    success(response.result.spidr_configuration);
	                }
	            },
	            failure: failure
	        });
	    }

	    /*
	     * Retrieves spidr configuration
	     *
	     * @method getSpidrConfiguration
	     * @param {Function} userAccessToken User Access Token.
	     * @param {Function} success The success callback.
	     * @param {Function} failure The failure callback.
	     */
	    me.getSpidrConfiguration = _getSpidrConfiguration;

	    /*
	     * Logs in to Experius and SPiDR through fcs JSL
	     *
	     * @method _logInToSpidr
	     * @param {Function} success Callback for successful login.
	     * @param {Function} failure Callback for unsuccessful login.
	     */
	    _logInToSpidr = function(success, failure, password) {
	        _getSpidrConfiguration(
	            function(spidrConfig) {
	                _applySpiderConfiguration(spidrConfig, success, failure, password);
	            },
	            function (error) {
	                _logger.error('login failed: unable to get spidr configuration');
	                failure();
	            }
	        );
	    };

	    /*
	     * Event handler for beforeunload event.
	     */
	    function _beforeUnloadEventHandler(event) {

	        // End all calls right before leaving a page.
	        for (var i in _calls) {
	            if(_calls.hasOwnProperty(i)) {
	                me.endCall(i);
	            }
	        }
	    }

	    /*
	     * Handles notifications
	     */
	    function _notificationHandler(message) {
	        message = message.message;
	        message = message && (message.kandyType || message.message_type);
	        if (!message || message === 'gofetch') {
	            events.emit('messagesavailable');
	        } else if (message === 'incomingCall') {
	            me._onIncommingCall('CALLavailable', message.call_id);
	        }
	    }

	    /*
	     * WebSocketListeners
	     */
	    registerWebSocketListeners({
	        'notification': _notificationHandler
	    });

	    /*
	     * Setup Spdir
	     * @deprecated
	     */
	    me.setup = function(config) {
	        _logger.warn('Deprecated method KandyAPI.Phone.setup use kandy.setup');
	        api.setup(config);
	    };

	    _setupCall = function (config) {

	        // apply default configuration
	        _config = utils.extend(_config, config);

	        fcs.notification.setOnConnectionEstablished(function () {
	            _logger.info('Connection established');
	            events.emit('onconnectionestablished', 'spider');
	        });

	        fcs.notification.setOnConnectionLost(function () {
	            _logger.info('Connection Lost');
	            events.emit('onconnectionlost', 'spider');
	        });

	        if (_config.allowAutoLogin && _supportsLocalStorage() && _getUserInformationLocalStorage()) {
	            api.loginSSO(_getUserInformationLocalStorage(),
	                    function () {
	                        events.emit('loginsuccess', _userDetails);
	                    },
	                    function (msg, errorCode) {
	                        events.emit('loginfailed', msg, errorCode);
	                    }
	            );
	        }

	        /*
	         * To handle when the user presence on received
	         * @param {object} presence the Prensece object
	         */
	        fcs.presence.onReceived = function (presence) {
	            _handlePresenceNotification(presence);
	        };

	        /*
	         * To handle when call on received
	         * @param {object} presence the Call object
	         */
	        fcs.call.onReceived = function (call) {
	            _logger.info('incoming call');

	            call.onStateChange = function (state, statusCode, reasonText, localStatusAndReason) {
	                localStatusAndReason = localStatusAndReason || {};
	                var reason = {
	                    code: localStatusAndReason.localStatusCode,
	                    text: localStatusAndReason.localReasonText
	                };

	                _handleCallStateChange(call, state, {reason: reason});
	            };

	            // Check if the incoming call is via PSTN.
	            if(call.callerNumber.indexOf('@kandyIn') > -1) {
	                call.isRemotePSTN = true;
	            } else {
	                call.isRemotePSTN = false;
	            }

	            call.isOutgoing = false;
	            _calls[call.getId()] = call;

	            //TODO: What is this doing? concierge?
	            // check if this is an anonymous call
	            call.isAnonymous = (call.callerNumber.indexOf('concierge') !== -1);

	            events.emit('callincoming', call, call.isAnonymous);
	        };
	    };

	    /*
	     * Login as a user
	     *
	     * @method login
	     * @deprecated Use 'kandy.login'
	     * @param {String} domainApiKey
	     * @param {String} userName
	     * @param {String} userPassword
	     * @deprecated
	     */
	    me.login = function (domainApiKey, userName, password) {
	        _logger.warn('Deprecated method KandyAPI.Phone.login use kandy.login');

	        api.login(domainApiKey, userName, password,
	                function () {
	                    events.emit('loginsuccess', _userDetails);
	                },
	                function (errorCode) {
	                    events.emit('loginfailed', '', errorCode);
	                }
	        );
	    };

	    /**
	     * All possible media errors.
	     *
	     * @property mediaErrors
	     * @type {Object} Object with keys for each media error.
	     * @example
	     * ``` javascript
	     *  onMediaFailure(errorCode) {
	     *      switch(errorCode) {
	     *          case kandy.call.mediaErrors.WRONG_VERSION:
	     *              ...
	     *          case kandy.call.mediaErrors.NEW_VERSION_WARNING:
	     *              ...
	     *      }
	     *  }
	     *
	     *  // Possible values
	     *  // WRONG_VERSION: The plugin was found but the version is not supported.
	     *  // NEW_VERSION_WARNING: The plugin was found and is supported, but a new version is available.
	     *  // NOT_INITIALIZED: An error happened while initializing user media.
	     *  // NOT_FOUND: No webRTC support or plugin was found.
	     *  // NO_SCREENSHARING_WARNING: Screen sharing is not possible with this browser or the
	     *                               screensharing extension could not be found.
	     * ```
	     */
	    me.mediaErrors = fcs.call.MediaErrors;

	    /**
	     * Check whether the browser has native WebRTC support or has the Kandy Plugin installed.
	     * If WebRTC is supported either by native support or via the plugin, the success callback
	     * will be called with no parameters. If no support is detected, the failure callback will
	     * be called with an error code. This function will be called automatically when making
	     * or receiving a call but you may want to call it sooner than that in case you need to
	     * direct your user to install the Kandy Plugin.
	     *
	     * @method initMedia
	     * @async
	     * @param {Function} success The success callback. It receives no parameters.
	     * @param {Function} failure The failure callback. It receives one parameter.
	     * @param {Object} failure.error Error object describing error state.
	     * @param {Number} failure.error.type Error code corresponding to the reason WebRTC is not supported. Refer to mediaErrors for possible errors.
	     * @param {String} [failure.error.urlWin32bit] The URL you can use to download the Kandy plugin for Windows 32bit.
	     * @param {String} [failure.error.urlWin64bit] The URL you can use to download the Kandy plugin for Windows 64bit.
	     * @param {String} [failure.error.urlMacUnix] The URL you can use to download the Kandy plugin for Mac.
	     * @param {Boolean} force Force a re-initialization of the media.
	     * @param {Object} options Additional options to set for a call. This overrides `force` to be true.
	     * @param {HTMLElement} options.remoteVideoContainer The container to use for remote video during the call. This is necessary, even for audio calls.
	     * @param {HTMLElement} options.localVideoContainer The container to use for local video during the call.
	     */
	    me.initMedia = function (success, failure, force, options) {
	        if (!force && !options && _initMediaDone) {
	            success();
	            return;
	        }

	        _initMediaDone = false;
	        _mediaInitiated = false;

	        options = options || {};
	        options = utils.defaults(
	            {
	                remoteVideoContainer: options.remoteVideoContainer || _config.remoteVideoContainer,
	                localVideoContainer: options.localVideoContainer || _config.localVideoContainer
	            },
	            _config.spidrMedia);

	        // make sure the browser supports WebRTC
	        fcs.call.initMedia(
	                function () {
	                    _logger.info('media initiated');
	                    _mediaInitiated = true;

	                    // add unload event to end any calls
	                window.addEventListener('beforeunload', _beforeUnloadEventHandler);

	                    _initMediaDone = true;
	                    success();
	                },
	                function (errorCode) {
	                    switch (errorCode) {
	                        case me.mediaErrors.WRONG_VERSION:
	                            _logger.error('Media Plugin Version Not Supported');
	                            events.emit('media', {type: me.mediaErrors.WRONG_VERSION});
	                            break;
	                        case me.mediaErrors.NEW_VERSION_WARNING:
	                            _logger.error('New Plugin Version is available');
	                            events.emit('media', utils.extend({ type: me.mediaErrors.NEW_VERSION_WARNING }, _pluginUrls));
	                            break;
	                        case me.mediaErrors.NOT_INITIALIZED:
	                            _logger.error('Media couldn\'t be initialized');
	                            events.emit('media', {type: me.mediaErrors.NOT_INITIALIZED});
	                            break;
	                        case me.mediaErrors.NOT_FOUND:
	                            _logger.error('Plugin couldn\'t be found!');
	                            events.emit('media', utils.extend({ type: me.mediaErrors.NOT_FOUND }, _pluginUrls));
	                            break;
	                        case me.mediaErrors.NO_SCREENSHARING_WARNING:
	                            _logger.info('ScreenShare extension could not be found');
	                            events.emit('media', { type: me.mediaErrors.NO_SCREENSHARING_WARNING });

	                            // This is not a failure case, just a warning.
	                            _initMediaDone = true;
	                            success();
	                            return;
	                    }

	                    failure(errorCode);
	                },
	            options
	        );
	    };

	    _logOutOfSpidr = function(success){
	        // if the browser supports local storage clear out the stored access token
	        if (_supportsLocalStorage()) {
	            _clearAccessTokeLocalStorage();
	        }

	        fcs.notification.stop(function () {
	            if (success) {
	                success();
	            }
	        }, undefined, true);
	    };


	    /*
	     * Logs out
	     *
	     * @method logout
	     * @param {Function} success The success callback. It receives no parameters.
	     */
	    me.logout = function (success) {
	        _logger.info('KandyAPI.Phone.logout is deprecated use kandy.logout');

	        api.logout(success);
	    };

	    /*
	     * Returns true if login information has been stored in local storage and false otherwise.
	     *
	     * @method hasStoredLogin
	     */
	    me.hasStoredLogin = function () {
	        if (_supportsLocalStorage()) {
	            _getUserInformationLocalStorage();
	        }
	    };

	    /**
	     * Returns true if media is initialized and false otherwise.
	     *
	     * @method isMediaInitialized
	     * @return {Boolean} isMediaInitiated The state of media initialization.
	     */
	    me.isMediaInitialized = function () {
	        return _mediaInitiated;
	    };

	    /*
	     * Returns true if media is initialized and false otherwise.
	     *
	     * @method isMediaInitiated
	     * @deprecated use KandyAPI.Phone.isMediaInitialized instead
	     * @return {BooLean} isMediaInitiated the state of media initialization.
	     */
	    me.isMediaInitiated = function() {
	        _logger.warn('Deprecated method KandyAPI.Phone.isMediaInitiated use KandyAPI.Phone.isMediaInitialized');
	        me.isMediaInitialized();
	    };

	    /**
	     * Returns true if the call is incoming and false otherwise.
	     *
	     * @method isIncoming
	     * @param {String} callId The id of the call.
	     * @return {Boolean} isIncoming The state of the call, whether it's incoming or outgoing.
	     */
	    me.isIncoming = function (callId) {
	        var call = _calls[callId];

	        return !call.isOutgoing;
	    };

	    /**
	     * Returns true if call is outgoing and false otherwise.
	     *
	     * @method isOutgoing
	     * @param {String} callId The id of the call.
	     * @return {Boolean} isOutgoing The state of the call, whether it's incoming or outgoing.
	     */
	    me.isOutgoing = function (callId) {
	        var call = _calls[callId];

	        return call.isOutgoing;
	    };

	    /**
	     * All call types.
	     *
	     * @property callTypes
	     * @type {Object} Object with keys for each call type.
	     * @example
	     * ``` javascript
	     *  var type = kandy.call.callType(callId);
	     *
	     *  switch(type) {
	     *      case kandy.call.callTypes.INCOMING_CALL:
	     *          ...
	     *      case kandy.call.callTypes.OUTGOING_CALL:
	     *          ...
	     *  }
	     *
	     *  // Possible values
	     *  // INCOMING_CALL: The call is incoming.
	     *  // OUTGOING_CALL: The call is outgoing.
	     * ```
	     */
	    me.callTypes = function () {
	        return _callTypes;
	    };

	    /*
	     * We want callTypes to be a property but there was already a getter function
	     * so now we merge _callTypes and me.callTypes so that me.callTypes is a function
	     * that can be used like an object property. Officially, this is just an object.
	     */
	    for(var key in _callTypes) {
	        if(_callTypes.hasOwnProperty(key)) {
	            me.callTypes[key] = _callTypes[key];
	        }
	    }

	    /*
	     * Returns anonymous data if the call is anonymous and null if it isn't.
	     *
	     * @method getAnonymousData
	     * @param {String} callId The id of the call to get the Anonymous data for.
	     */
	    me.getAnonymousData = function (callId) {
	        var call = _call[callId];

	        if (call && call.isAnonymous) {
	            return call.callerName;
	        } else {
	            return null;
	        }
	    };

	    /**
	     * Returns call type which is either incoming or outgoing.
	     *
	     * @method callType
	     * @param {String} callId The id of the call.
	     * @return {Number} callType Use callTypes() to interpret callType. Possible types are INCOMING_CALL and OUTGOING_CALL.
	     */
	    me.callType = function (callId) {
	        var call = _calls[callId];

	        if (call.isIncoming) {
	            return _callTypes.INCOMING_CALL;
	        }
	        else if (call.isOutgoing) {
	            return _callTypes.OUTGOING_CALL;
	        }
	    };

	    /**
	     * Make a SIP trunk call to a given SIP phone number or SIP endpoint URI.
	     *
	     * @method makeSIPCall
	     * @async
	     * @param {String} number SIP phone number to call
	     * @param {String} callerId Caller's phone number / username as it should appear to callee
	     * @param {Object} options Additional options to set for a call.
	     * @param {HTMLElement} options.remoteVideoContainer The container to use for remote video during the call. This is necessary, even for audio calls.
	     * @param {HTMLElement} options.localVideoContainer The container to use for local video during the call.
	     */
	    me.makeSIPCall = function (number, callerId, options) {
	        me.makeCall(_config.sipOutNumber + number + '@' + _userDetails.domain_name, false, callerId, options);
	    };

	    /**
	     * Make a Public Switched Telephone Network (PSTN) call to a given PSTN phone number.
	     *
	     * @method makePSTNCall
	     * @async
	     * @param {String} number PSTN phone number to call
	     * @param {String} callerId Caller's phone number as it should appear to callee.
	     * @param {Object} options Additional options to set for a call.
	     * @param {HTMLElement} options.remoteVideoContainer The container to use for remote video during the call. This is necessary, even for audio calls.
	     */
	    me.makePSTNCall = function (number, callerId, options) {
	        me.makeCall(_config.pstnOutNumber + number + '@' + _userDetails.domain_name, false, callerId, options);
	    };

	    /**
	     * Make an IP call to another Kandy user
	     *
	     * @method makeCall
	     * @async
	     * @param {String} fullUserId Username of the intended callee.
	     * @param {Boolean} cameraOn When true, the user's video will be sent to the callee. Otherwise, the user's video will not be sent.
	     * @param {String} callerId Caller's identification as it should appear to callee
	     * @param {Object} options Additional options to set for a call.
	     * @param {HTMLElement} options.remoteVideoContainer The container to use for remote video during the call. This is necessary, even for audio calls.
	     * @param {HTMLElement} options.localVideoContainer The container to use for local video during the call.
	     * @param {Number} options.videoResolution.width The width of the local video in pixels.
	     * @param {Number} options.videoResolution.height The height of the local video in pixels.
	     */
	    me.makeCall = function (fullUserId, cameraOn, callerId, options) {
	        options = options || {};
	        if (fullUserId === _userDetails.full_user_id) {
	            events.emit('callinitiatefailed', 'You cannot call yourself');
	            _logger.warn('You cannot call yourself');
	            return;
	        }

	        _logger.info('making voice call');

	        // We fire and forget this request to enable fast calling on mobile
	        _kandyRequestAsync({
	            type: 'POST',
	            url: '/users/messages/event',
	            params: {
	                client_timestamp: new Date().getTime()
	            },
	            data: {
	                message: {
	                    UUID: utils.createUUIDv4(),
	                    destination: fullUserId,
	                    messageType: 'PRIVATE',
	                    message: {type: 'WAKEUP'}
	                }
	            }
	        });

	        me.initMedia(
	            function () {
	                fcs.call.startCall(fcs.getUser(), {firstName: callerId}, fullUserId,
	                    //onSuccess
	                    function (outgoingCall) {
	                        outgoingCall.onStateChange = function (state, statusCode, reasonText, localStatusAndReason) {
	                            outgoingCall.statusCode = statusCode;

	                            localStatusAndReason = localStatusAndReason || {};
	                            var reason = {
	                                code: localStatusAndReason.localStatusCode,
	                                text: localStatusAndReason.localReasonText
	                            };

	                            _handleCallStateChange(outgoingCall, state, {reason: reason});
	                        };

	                        outgoingCall.isOutgoing = true;
	                        outgoingCall.isAnonymous = false;
	                        _calls[outgoingCall.getId()] = outgoingCall;

	                        events.emit('callinitiated', outgoingCall, fullUserId);
	                    },
	                    //onFailure
	                    function (errorCode) {
	                        _logger.error('call failed');
	                        events.emit('callinitiatefailed', 'Start call failed: ' + errorCode);

	                    }, true, cameraOn, options.videoResolution);
	            },
	            function (errorCode) {
	                _logger.error('call failed');
	                events.emit('callinitiatefailed', 'Init media failed: ' + errorCode);
	            },
	            false,
	            options
	        );
	    };

	    /*
	     * Starts Anonymous video call
	     *
	     * @method makeAnonymousCall
	     * @param {String} domainApiKey The Domain API Key for the domain on which the call will be made.
	     * @param {String} account The account on which the call will be made.
	     * @param {String} caller The Kandy user making the call (caller)
	     * @param {String} callee The Kandy user being called (callee)
	     * @param {String} cli
	     * @param {Boolean} cameraOn Whether call is made with camera on
	     */
	    function makeAnonymousCall(domainApiKey, account, caller, callee, cli, cameraOn){

	        /*
	        * Apply spidr configuration
	        *
	        * @method applyConfiguration
	        * @param {JSON} Config Input configuration variable for Spidr.
	        */
	        function applyConfiguration(config) {

	            _mergeConfigWithSpidrConfiguration(config.result.spidr_configuration);

	            fcs.setup(_config.spidrApi);

	            //Setup user credential
	            fcs.setUserAuth(account, '');

	            fcs.notification.start(
	                function () {
	                  _logger.info('Notification started');


	                  me.initMedia(
	                      function () {
	                        _logger.info('Call init successfully');
	                        //TODO: do we need setTimeout
	                        setTimeout(function () {

	                            fcs.call.startCall(caller, cli, callee,
	                                //onSuccess
	                                function (outgoingCall) {
	                                    outgoingCall.onStateChange = function (state, statusCode, reasonText, localStatusAndReason) {
	                                        outgoingCall.statusCode = statusCode;

	                                        localStatusAndReason = localStatusAndReason || {};
	                                        var reason = {
	                                            code: localStatusAndReason.localStatusCode,
	                                            text: localStatusAndReason.localReasonText
	                                        };

	                                        _handleCallStateChange(outgoingCall, state, {reason: reason});
	                                    };

	                                    outgoingCall.isOutgoing = true;
	                                    outgoingCall.isAnonymous = true;
	                                    _calls[outgoingCall.getId()] = outgoingCall;
	                                    events.emit('callinitiated', outgoingCall, callee);
	                                },
	                                //onFailure
	                                function (errorCode) {
	                                    _logger.error('call failed');
	                                    events.emit('callinitiatefailed', 'error code: ' + errorCode);

	                                }, false, cameraOn
	                            );

	                        }, 100);
	                      },
	                      function (errorCode) {
	                          _logger.error('Call init failed');
	                          api.logout();
	                          events.emit('callinitiatefailed', 'Init media failed: ' + errorCode);
	                      }
	                  );
	                },
	                function () {
	                    _logger.error('Notification failed');
	                    events.emit('callinitiatefailed', 'Auth failed');
	                }, true);
	        }

	        _initLogger();

	        _kandyRequest({
	          url: '/domains/configurations/communications/spidr',
	          params: { key: domainApiKey },
	          success: applyConfiguration,
	          failure: function() {
	              events.emit('callinitiatefailed', 'Failed to retrieve domain configuration');
	              _logger.error('Call Failed: Failed to retrieve domain configuration');
	          }
	        });
	    }

	    /*
	     * Starts Anonymous video call using a token
	     *
	     * @method makeAnonymousCallWithToken
	     * @param {String} domainApiKey The Domain API Key for the domain on which the call will be made.
	     * @param {String} tokenRealm The realm used to encrypt the tokens
	     * @param {String} acountToken The encoded account token used to make the call
	     * @param {String} fromToken The encoded origination for the call
	     * @param {String} toToken The encoded destination for the call
	     * @param {Boolean} cameraOn Whether call is made with camera on
	     * @private
	     */
	    me.makeAnonymousCallWithToken = function (domainApiKey, tokenRealm, acountToken, fromToken, toToken, cameraOn){
	        fcs.setRealm(tokenRealm);
	        makeAnonymousCall(domainApiKey, acountToken, fromToken, toToken, null, cameraOn);
	    };

	    /*
	     * Starts Anonymous video call
	     *
	     * @method makeAnonymousCall
	     * @param {String} domainApiKey The Domain API Key for the domain on which the call will be made.
	     * @param {String} calleeUsername The Kandy user being called (callee)
	     * @param {String} anonymousData Data to send with anonymous call
	     * @param {String} callerUserName The Kandy user making the call (caller)
	     * @param {Boolean} cameraOn Whether call is made with camera on
	     */
	    me.makeAnonymousCall = function (domainApiKey, calleeUsername, anonymousData, callerUserName, cameraOn) {
	        var anonymousUserName = {
	            firstName: anonymousData
	        };
	        callerUserName = callerUserName || 'anonymous@concierge.com';
	        makeAnonymousCall(domainApiKey, callerUserName, callerUserName, calleeUsername, anonymousUserName, cameraOn);
	    };

	    /**
	     * Reject incoming call.
	     *
	     * @method rejectCall
	     * @param {String} callId ID of call. This can be obtained from calling getId() on the call object received by the callincoming event handler.
	     */
	    me.rejectCall = function (callId) {
	        var call = _calls[callId];
	        call.reject(
	                function () {
	                    events.emit('callrejected', call);
	                },
	                function (errorCode) {
	                    _logger.info('reject failed');
	                    events.emit('callrejectfailed', call, errorCode);
	                }
	        );
	    };

	    /**
	     * Ignore incoming call.
	     *
	     * @method ignoreCall
	     * @param {String} callId ID of call. This can be obtained from calling getId() on the call object received by the callincoming event handler.
	     */
	    me.ignoreCall = function (callId) {
	        var call = _calls[callId];
	        call.ignore(
	                function () {
	                    events.emit('callignored', call);
	                },
	                function (errorCode) {
	                    events.emit('callignorefailed', call, errorCode);
	                    _logger.info('ignore failed');
	                }
	        );
	    };

	    /**
	     * Answer an incoming call.
	     *
	     * @method answerCall
	     * @param {String} ID of call. This can be obtained by calling getId() on the call object passed to the callincoming event listener.
	     * @param {Boolean} cameraOn When true, call will be answered with the user's video being sent to caller. Otherwise, the user's video will not be sent.
	     * @param {Object} options Additional options to set for a call.
	     * @param {HTMLElement} options.remoteVideoContainer The container to use for remote video during the call. This is necessary, even for audio calls.
	     * @param {HTMLElement} options.localVideoContainer The container to use for local video during the call.
	     * @param {Number} options.videoResolution.width The width of the local video in pixels.
	     * @param {Number} options.videoResolution.height The height of the local video in pixels.
	     */
	    me.answerCall = function (callId, cameraOn, options) {
	        options = options || {};
	        me.initMedia(function () {
	            var call = _calls[callId];
	            call.answer(function () {
	                        events.emit('callanswered', call, call.isAnonymous);

	                        // For some reason, FCS doesn't send us a state change to IN_CALL whenever
	                        // we answer an incoming call. Trigger it here to fake it.
	                        _handleCallStateChange(call, fcs.call.States.IN_CALL);
	                    },
	                    function (errorCode) {
	                        _logger.info('answer failed');
	                        events.emit('callanswerfailed', call, errorCode);
	                    },
	                    cameraOn, options.videoResolution
	            );
	        },
	            function (errorCode) {
	                _logger.info('answer failed');
	                events.emit('callanswerfailed');
	            },
	            false,
	            options
	        );
	    };

	    /**
	     * Stop sending the user's audio to the other party on the call
	     *
	     * @method muteCall
	     * @param {String} callId ID of call. This can be obtained from calling getId() on the call object received by either the callincoming or callinitiated event handler.
	     */
	    me.muteCall = function (callId) {
	        var call = _calls[callId];
	        if (call) {
	            call.mute();
	            call.isMuted = true;
	        }
	    };

	    /**
	     * Start sending the user's audio to the other party on the call.
	     *
	     * @method unMuteCall
	     * @param {String} callId ID of call. This can be gotten from calling getId() on the call object received by either the callincoming or callinitiated event handler.
	     */
	    me.unMuteCall = function (callId) {
	        var call = _calls[callId];
	        if (call) {
	            call.unmute();
	            call.isMuted = false;
	        }
	    };

	    /**
	     * Place a call on hold.
	     *
	     * @method holdCall
	     * @async
	     * @param {String} callId ID of call. This can be obtained from calling getId() on the call object received by either the callincoming or callinitiated event handler.
	     * @param {Function} success The success callback. It receives no parameters.
	     * @param {Function} failure The failure callback. It receives no parameters.
	     */
	    me.holdCall = function (callId, success, failure) {
	        var call = _calls[callId];
	        if (call) {
	            call.hold(success, failure);
	            call.held = true;
	        }
	    };

	    /**
	     * Take a call off hold.
	     *
	     * @method unHoldCall
	     * @async
	     * @param {String} callId ID of call. This can be obtained from calling getId() on the call object received by either the callincoming or callinitiated event handler.
	     * @param {Function} success The success callback. It receives no parameters.
	     * @param {Function} failure The failure callback. It receives no parameters.
	     */
	    me.unHoldCall = function (callId, success, failure) {
	        var call = _calls[callId];
	        if (call) {
	            call.unhold(success, failure);
	            call.held = false;
	        }
	    };

	    /**
	     * Start sending the user's video to the other party on the call.
	     *
	     * @method startCallVideo
	     * @async
	     * @param {String} callId ID of call. This can be obtained from calling getId() on the call object received by either the callincoming or callinitiated event handler.
	     * @param {Function} success The success callback. It receives no parameters.
	     * @param {Function} failure The failure callback. It receives no parameters.
	     */
	    me.startCallVideo = function (callId, success, failure) {
	        var call = _calls[callId];
	        if (call) {
	            call.videoStart(success, failure);
	        }
	    };

	    /**
	     * Stop sending the user's video to the other party on the call
	     *
	     * @method stopCallVideo
	     * @async
	     * @param {String} callId ID of call. This can be obtained from calling getId() on the call object received by either the callincoming or callinitiated event handler.
	     * @param {Function} success The success callback. It receives no parameters.
	     * @param {Function} failure The failure callback. It receives no parameters.
	     */
	    me.stopCallVideo = function (callId, success, failure) {
	        var call = _calls[callId];
	        if (call) {
	            call.videoStop(success, failure);
	        }
	    };

	    /**
	     * Start screen sharing for the specified call. If the call already has video, the screen sharing will replace the video. Note
	     * that a screensharing extension has to be present to enable this. See `kandy.setup` for more information.
	     *
	     * @method startScreenSharing
	     * @async
	     * @param {String} callId Id of the call for which to start screen sharing.
	     * @param {Function} success The success callback. It receives no parameters.
	     * @param {Function} failure The failure callback. It receives one parameter.
	     * @param {Number} failure.errorCode Error code for the failure.
	     * @param {Object} options Options for the screen sharing session.
	     * @param {Number} [options.width=1024] The width of the screen to request.
	     * @param {Number} [options.height=768] The height of the screen to request.
	     * @param {Number} [options.frameRate=15] The number of frames per second to request.
	     */
	    me.startScreenSharing = function (callId, success, failure, options) {
	        var call = _calls[callId];
	        if (call) {

	            call.screenSharingStart(success, failure, function() {
	                // Emit the callscreenstopped event.
	                events.emit('callscreenstopped', call);
	            }, options);
	        }
	    };

	    /**
	     * Stop screen sharing for the specified call. If the call is set to send video, then the screen sharing will
	     * stop and video will resume.
	     *
	     * @method stopScreenSharing
	     * @async
	     * @param {String} callId Id of call.
	     * @param {Function} success The success callback. It receives no parameters.
	     * @param {Function} failure The failure callback. It receives no parameters.
	     */
	    me.stopScreenSharing = function (callId, success, failure) {
	        var call = _calls[callId];
	        if (call) {
	            call.screenSharingStop(function() {
	                events.emit('callscreenstopped', call);
	                if (success) {
	                    success();
	                }
	            }, failure);
	        }
	    };

	    /**
	     * Retrieves the MediaStream object for a specified call.
	     * @method getMediaStream
	     * @param  {String} callId ID of the call.
	     * @return {MediaStream} stream MediaStream object.
	     */
	    me.getMediaStream = function(callId) {
	        var call = _calls[callId];
	        if(call) {
	            return call.getMediaStream();
	        } else {
	            _logger.warn('Invalid call Id.');
	        }
	    };

	    /**
	     * Send a tone (Dual Tone Multi Frequency) in a PSTN call.
	     *
	     * @method sendDTMF
	     * @param {String} callId ID of call. This can be obtained from calling getId() on the call object passed to either the callincoming or callinitiated event handlers.
	     * @param {String} tones Tones to send.
	     */
	    //TODO: Document format of tones
	    me.sendDTMF = function (callId, tones) {
	        var call = _calls[callId];
	        if (call) {
	            call.sendDTMF(tones);
	        }
	    };

	    /*
	     * Transfers a call to a third-party. Establishes a call
	     * between the remote user and the third-party. The call must be on hold
	     * prior to the transferCall being invoked or else the transfer will fail.
	     * Warning: This is an unstable version of the call transfer feature.
	     * 		A transferred call must be accepted (can't be rejected) without video
	     * 		(but video can be toggled on afterwards), otherwise it will cause issues.
	     * @method transferCall
	     * @param  {String} callId Id of call to transfer.
	     * @param  {String} transferTo The fullUserId of the user to transfer the call to.
	     */
	    // When call transfer is officially supported and documented, add documenation for SESSION_COMPLETED in callendReasons constants
	    me.transferCall = function(callId, transferTo) {

	        if(transferTo === _userDetails.full_user_id) {
	            events.emit('calltransferfailed', 'You cannot transfer to yourself.');
	            return;
	        }

	        var call = _calls[callId];
	        if(call && transferTo) {

	          //Attempt to transfer the call. Will fail if the call is not on hold.
	          call.directTransfer(
	              transferTo,
	              // Success.
	              function() {
	                  _logger.info('Call transferred to ' + transferTo);
	              },
	              // Failure.
	              function() {
	                  _logger.info('Could not transfer call.');
	              }
	          );
	        }
	    };

	    /**
	     * All possible reasons for a call ending.
	     *
	     * @property callEndReasons
	     * @type {Object} Object with keys for each call end reason.
	     * @example
	     * ``` javascript
	     *  kandy.on('callended', function (call, data) {
	     *      switch(data.reason.code) {
	     *          case kandy.call.callEndReasons.STATUS_CODE_NOT_PROVIDED:
	     *              ...
	     *          case kandy.call.callEndReasons.ENDED_BY_LOCAL:
	     *              ...
	     *      }
	     *  })
	     *
	     *  // Possible values
	     *  // STATUS_CODE_NOT_PROVIDED: The call's reason text has not been provided. You can assume that this means the remote user has ended, rejected or ignored the call.
	     *  // ENDED_BY_LOCAL: The call has been ended locally.
	     *  // REJECTED_BY_LOCAL: The call has been rejected by local user.
	     *  // IGNORED_BY_LOCAL: The call has been ignored by local user.
	     *  // RESPONDED_FROM_ANOTHER_DEVICE: The call has been answered on another device.
	     * ```
	     */
	    /*
	     * When call transfer is officially supported and documented, add documenation for:
	     *  // SESSION_COMPLETED: The call has been transfered successfully or unsuccessfully.
	     */
	    me.callEndReasons = fcs.call.LOCAL_STATUS_CODES;


	    /**
	     * Ends a call.
	     *
	     * @method endCall
	     * @param {String} callId ID of call. This can be obtained from calling getId() on the call object passed to either the callincoming or callinitiated event handlers.
	     */
	    me.endCall = function (callId) {
	        var call = _calls[callId];

	        if (call) {
	            _logger.info('ending call');
	            call.end(
	                null,
	                function (errorCode) {
	                    _logger.error('COULD NOT END CALL');
	                    events.emit('callendfailed', call, errorCode);
	                }
	            );
	        }
	    };

	    /**
	     * Starts the local video stream and displays it to the user.
	     * @method startLocalVideo
	     * @param  {HTMLElement} [videoContainer] The container to use for local video.
	     * @example
	     * ``` javascript
	     *  var container = document.getElementById('local-video');
	     *  kandy.call.startLocalVideo(container);
	     * ```
	     */
	    me.startLocalVideo = function(videoContainer) {
	        var container = videoContainer || _config.localVideoContainer;
	        if(!container) {
	            _logger.info('No local video container specified.');
	            return;
	        }

	        me.initMedia(
	            function() {
	                fcs.call.getUserMedia(
	                    // Success.
	                    function(streamInfo) {
	                        fcs.call.createStreamRenderer(streamInfo.streamURL, container, { muted: true });
	                        // Store the local stream's info.
	                        localStream = {
	                            stream: streamInfo,
	                            container: container
	                        };
	                        _logger.info('Started local video stream.');
	                    },
	                    // Failure.
	                    function (errorCode) {
	                        _logger.info('Failed to start local video.');
	                    },
	                    {
	                        audio: false,
	                        video: true
	                    }
	                );
	            },
	            // initMedia failure.
	            function (errorCode) {
	                _logger.info('Failed to start local video.');
	            }
	        );
	    };

	    /**
	     * Stops the local video stream created in `startLocalVideo`.
	     * @method stopLocalVideo
	     */
	    me.stopLocalVideo = function() {
	        // Only act on the stream that was started earlier via `startLocalVideo`.
	        if(localStream) {
	            fcs.call.disposeStreamRenderer(localStream.container);
	            fcs.call.removeStreamById(localStream.stream.id);
	            localStream = null;
	            _logger.info('Local video stream stopped.');
	        } else {
	            _logger.info('No local video stream to stop.');
	        }
	    };

	    /*
	     * watch presence for logged in user.
	     *
	     * @method watchPresence
	     * @deprecated Use `kandy.getLastSeen`
	     * @async
	     * no callbacks
	     * @param {Array} list Watch presence given array of users
	     * @param {Function} success The success callback
	     * @param {Function} failure The failure callback
	     * @deprecated Use `kandy.getLastSeen`
	     */
	    me.watchPresence = function (list, success, failure) {

	        _logger.warn('KandyAPI.Phone.watchPresence is deprecated please use kandy.getLastSeen');

	        var contactList = [];

	        fcs.presence.watch(
	                list.map(function (item) {
	                    return item.full_user_id;
	                }),
	                function () {
	                    _logger.info('Watch presence successful');
	                    if (success) {
	                        success();
	                    }
	                },
	                function () {
	                    _logger.error('Watch presence error');
	                    if (failure) {
	                        failure();
	                    }
	                }
	        );
	    };

	    /*
	     * Sets presence for logged in user.
	     *
	     * @method updatePresence
	     * @param {Boolean} status true or false value to set for user presence
	     * @deprecated Use `kandy.getLastSeen`
	     */
	    me.updatePresence = function (status) {
	        _logger.warn('KandyAPI.Phone.updatePresence is deprecated please use kandy.getLastSeen');
	        if (fcs.getServices().presence === true) {
	            fcs.presence.update(parseInt(status),
	                    function () {
	                        _logger.info('Presence update success');
	                    },
	                    function () {
	                        _logger.error('Presence update failed');
	                    });
	        } else {
	            _logger.error('Presence service not available for account');
	        }
	    };

	    me.normalizeNumber = function (number, countryCode, success, failure) {
	        _kandyRequest({
	            url: '/users/services/normalize/phone_number',
	            params: {
	                'phone_number': number,
	                'country_code': countryCode
	            },
	            success: function (response) {
	                if (success) {
	                    success(response.result);
	                }
	            },
	            failure: failure
	        });
	    };

	    /**
	     * Retrieves WebRTC statistics about an on-going call. The stats retrieved are a summary of the accumulated stats for the call.
	     * @method getStats
	     * @param  {String} callId  Id of the call to retrieve stats for.
	     * @param  {Function} success The success callback. It receives one parameter.
	     * @param  {Object} success.stats Statistics object for the call.
	     * @param  {WebRTCStats} success.stats.audio Audio statistics for the call.
	     * @param  {WebRTCStats} success.stats.video Video statistics for the call.
	     * @param  {Function} failure The failure callback. It receives one parameter.
	     * @param  {Object} failure.error Failure object with the error information.
	     * @param  {String} failure.error.message The error message explaining what failed.
	     */
	    me.getStats = function(callId, success, failure) {
	        var call = _calls[callId];
	        if(call) {
	            call.getWebRtcStats(success, failure);
	        } else {
	            failure({ message: 'Specified call not on-going.' });
	        }
	    };

	    /**
	     * Retrieves WebRTC statistics about an on-going call. The stats retrived are the native RTCStatsReport objects as specified by WebRTC standards.
	     * @method getNativeStats
	     * @param  {String} callId  Id of the call to retrieve stats for.
	     * @param  {Function} success The success callback. It receives one parameter.
	     * @param  {Array} success.stats Array of RTCStatsReport objects.
	     * @param  {Function} failure The failure callback. It receives one parameter.
	     * @param  {Object} failure.error Failure object with the error information.
	     * @param  {String} failure.error.message The error message explaining what failed.
	     */
	    me.getNativeStats = function(callId, success, failure) {
	        var call = _calls[callId];
	        if(call) {
	            call.getNativeWebRtcStats(success, failure);
	        } else {
	            failure({ message: 'Specified call not on-going.' });
	        }
	    };

	    /**
	     * Starts a timer to periodically retrieve WebRTC statistics about a call. The stats retrieved are a summary of the accumulated stats for the call.
	     * @method getStatsPeriodically
	     * @param  {String} callId  Id of the call to retrieve stats for.
	     * @param  {Number} statsInterval The time interval, in seconds, to retrieve stats.
	     * @param  {Function} success The success callback. It receives one parameter.
	     * @param  {Object} success.stats Statistics object for the call.
	     * @param  {WebRTCStats} success.stats.audio Audio statistics for the call.
	     * @param  {WebRTCStats} success.stats.video Video statistics for the call.
	     * @param  {Function} failure The failure callback. It receives one parameter.
	     * @param  {Object} failure.error Failure object with the error information.
	     * @param  {String} failure.error.message The error message explaining what failed.
	     */
	    me.getStatsPeriodically = function(callId, statsInterval, success, failure) {
	        var call = _calls[callId];
	        if(call) {
	            call.startWebRtcStatsTimer(statsInterval, success, failure);
	        } else {
	            failure({ message: 'Specified call not on-going.' });
	        }
	    };

	    /**
	     * Stops an interval for retrieving WebRTC statistics about a call.
	     * @method stopPeriodicStats
	     * @param  {String} callId  Id of the call to retrieve stats for.
	     */
	    me.stopPeriodicStats = function(callId) {
	        var call = _calls[callId];
	        if(call) {
	            call.stopWebRtcStatsTimer();
	        }
	    };

	    return me;
	}());

	/**
	 * Kandy conference is used to create and manage conferences for multi-party
	 * video calls.
	 *
	 * @class conference
	 * @namespace kandy
	 * @static
	 */

	api.conference = (function () {
	    var exports = {};

	    function convertConfObject(response) {
	        var conference = response.result.conference_details;
	        return {
	            conferenceId: conference.conference_id,
	            pstnAccess: conference.pstn_access,
	            ipAccess: conference.ip_access + '@' + _userDetails.domain_name,
	            pinCode: conference.pin_code,
	            participants: response.result.participants ?
	                response.result.participants.map(function(participant) {
	                    return {
	                        participantId: participant.participant_id,
	                        displayName: participant.participant_nick_name,
	                        audioState: participant.call_state.audio_state,
	                        videoState: participant.call_state.video_state,
	                        callDuration: participant.call_duration_in_seconds
	                    };
	                }) : [],
	            administrators: response.result.participants ?
	                response.result.participants.map(function(admin) {
	                    return admin.participant_id;
	                }) : []
	        };
	    }

	    function joinConference(conferenceId, displayName) {
	        return _kandyRequestAsync({
	            type: 'POST',
	            url: '/users/mpv/join',
	            params: {
	                conference_id: conferenceId,
	                register_for_event: true,
	                user_nick_name: displayName
	            }
	        });
	    }

	    function getConference(conferenceId) {
	        return _kandyRequestAsync({
	            url: '/users/mpv/status',
	            params: {
	                conference_id: conferenceId
	            }
	        })
	        .then(convertConfObject);
	    }

	    function sendControl(action, conferenceId, participantId) {
	        return _kandyRequestAsync({
	            type: 'POST',
	            url: '/users/mpv/control',
	            params: {
	                conference_id: conferenceId
	            },
	            data: {
	                control_participants: [
	                    {
	                        participant_id: participantId,
	                        action: action
	                    }
	                ]
	            }
	        })
	        .then(function() {
	            // Make sure the success callback doesn't get a parameter
	            return undefined;
	        });
	    }

	    /**
	     * Creates a conference with a list of initial invitees.
	     *
	     * @method createConference
	     * @async
	     * @param {Function} success The success callback. It receives one parameter.
	     * @param {Conference} success.conference The conference object.
	     * @param {Function} failure The failure callback. It receives no parameters.
	     */
	    exports.createConference = function(success, failure) {
	        _kandyRequestAsync({
	            type: 'POST',
	            url: '/users/mpv/conference'
	        })
	        .then(convertConfObject)
	        .then(success)
	        .catch(failure);
	    };

	    /**
	     * Joins a conference. The conference must first have been created.
	     *
	     * @method joinConference
	     * @async
	     * @param {String} conferenceId The ID of the conference.
	     * @param {Boolean} cameraOn When true, the user's video will be sent to the callee. Otherwise, the user's video will not be sent.
	     * @param {String} displayName Name to be displayed in the conference for the current user.
	     * @param {Function} success The success callback. It receives one parameter.
	     * @param {Conference} success.conference The conference object.
	     * @param {Function} failure The failure callback. It receives no parameters.
	     * @param {Object} options Additional options to set for a call. Implies force.
	     * @param {HTMLElement} options.remoteVideoContainer The container to use for remote video during the call.
	     * @param {HTMLElement} options.localVideoContainer The container to use for local video during the call.
	     */
	    exports.joinConference = function(conferenceId, cameraOn, displayName, success, failure, options) {
	        joinConference(conferenceId, displayName)
	        .then(function() {
	            return getConference(conferenceId);
	        })
	        .then(function(conference) {
	            // Call the conference
	            api.call.makeCall(
	                conference.ipAccess,
	                cameraOn,
	                displayName,
	                options
	            );

	            return conference;
	        })
	        .then(success)
	        .catch(failure);
	    };

	    /**
	     * Leaves a conference.
	     *
	     * @method leaveConference
	     * @async
	     * @param {String} conferenceId The ID of the conference.
	     * @param {Function} success The success callback. It receives no parameters.
	     * @param {Function} failure The failure callback. It receives no parameters.
	     */
	    exports.leaveConference = function(conferenceId, success, failure) {
	        _kandyRequestAsync({
	            type: 'POST',
	            url: '/users/mpv/leave',
	            params: {
	                conference_id: conferenceId
	            }
	        })
	        .then(success)
	        .catch(failure);
	    };

	    /**
	     * Ends a conference, which disconnects all participants. Only an admin is allowed to do this.
	     *
	     * @method endConference
	     * @async
	     * @param {String} conferenceId The ID of the conference.
	     * @param {Function} success The success callback. It receives no parameters.
	     * @param {Function} failure The failure callback. It receives no parameters.
	     */
	    exports.endConference = function(conferenceId, success, failure) {
	        _kandyRequestAsync({
	            type: 'DELETE',
	            url: '/users/mpv/conference',
	            params: {
	                conference_id: conferenceId
	            }
	        })
	        .then(success)
	        .catch(failure);
	    };

	    /**
	     * Invites a user to a conference. This means they will receive the `conferenceInvite` event.
	     *
	     * @method inviteToConference
	     * @async
	     * @param {String} conferenceId The ID of the conference.
	     * @param {Function} success The success callback. It receives no parameters.
	     * @param {Function} failure The failure callback. It receives no parameters.
	     */
	    exports.inviteToConference = function(conferenceId, invitee, success, failure) {
	        _kandyRequestAsync({
	            type: 'POST',
	            url: '/users/mpv/invite',
	            params: {
	                conference_id: conferenceId
	            },
	            data: {
	                invitees: {
	                    invite_by_chat: [
	                        {
	                            invitee: invitee
	                        }
	                    ]
	                }
	            }
	        })
	        .then(function (response) {
	            // We must check for the failure case.
	            // Some failures will not call the failure callback.
	            if (failure &&
	                response.result &&
	                response.result.invitees_failures.invite_by_chat.length) {
	                var error = response.result.invitees_failures.invite_by_chat[0];
	                throw 'Failed to invite \"'+ error.invitee +'\": '+ error.reason;
	            }

	            // Don't pass the response to the user
	            return undefined;
	        })
	        .then(success)
	        .catch(failure);
	    };

	    /**
	     * Gets a conference's details. You must be in the conference to get a conference's details.
	     *
	     * @method getConference
	     * @async
	     * @param {String} conferenceId The ID of the conference.
	     * @param {Function} success The success callback. It receives one parameter.
	     * @param {Conference} success.conference The conference object.
	     * @param {Function} failure The failure callback. It receives no parameters.
	     */
	    exports.getConference = function(conferenceId, success, failure) {
	        getConference(conferenceId)
	        .then(success)
	        .catch(failure);
	    };

	    /**
	     * Mutes a participant. Only availble to admins.
	     *
	     * @method muteParticipant
	     * @async
	     * @param {String} conferenceId The ID of the conference.
	     * @param {String} participantId The ID of the participant.
	     * @param {Function} success The success callback. It receives no parameters.
	     * @param {Function} failure The failure callback. It receives no parameters.
	     */
	    exports.muteParticipant = function(conferenceId, participantId, success, failure) {
	        sendControl('mute', conferenceId, participantId)
	        .then(success)
	        .catch(failure);
	    };

	    /**
	     * Unmutes a participant. Only availble to admins.
	     *
	     * @method unMuteParticipant
	     * @async
	     * @param {String} conferenceId The ID of the conference.
	     * @param {String} participantId The ID of the participant.
	     * @param {Function} success The success callback. It receives no parameters.
	     * @param {Function} failure The failure callback. It receives no parameters.
	     */
	    exports.unMuteParticipant = function(conferenceId, participantId, success, failure) {
	        sendControl('unmute', conferenceId, participantId)
	        .then(success)
	        .catch(failure);
	    };

	    /**
	     * Starts participant's video. Only availble to admins.
	     *
	     * @method startParticipantVideo
	     * @async
	     * @param {String} conferenceId The ID of the conference.
	     * @param {String} participantId The ID of the participant.
	     * @param {Function} success The success callback. It receives no parameters.
	     * @param {Function} failure The failure callback. It receives no parameters.
	     */
	    exports.startParticipantVideo = function(conferenceId, participantId, success, failure) {
	        sendControl('enableVideo', conferenceId, participantId)
	        .then(success)
	        .catch(failure);
	    };

	    /**
	     * Stops participant's video. Only availble to admins.
	     *
	     * @method stopParticipantVideo
	     * @async
	     * @param {String} conferenceId The ID of the conference.
	     * @param {String} participantId The ID of the participant.
	     * @param {Function} success The success callback. It receives no parameters.
	     * @param {Function} failure The failure callback. It receives no parameters.
	     */
	    exports.stopParticipantVideo = function(conferenceId, participantId, success, failure) {
	        sendControl('disableVideo', conferenceId, participantId)
	        .then(success)
	        .catch(failure);
	    };

	    /**
	     * Puts a participant on hold. Only availble to admins.
	     *
	     * @method holdParticipant
	     * @async
	     * @param {String} conferenceId The ID of the conference.
	     * @param {String} participantId The ID of the participant.
	     * @param {Function} success The success callback. It receives no parameters.
	     * @param {Function} failure The failure callback. It receives no parameters.
	     */
	    exports.holdParticipant = function(conferenceId, participantId, success, failure) {
	        sendControl('hold', conferenceId, participantId)
	        .then(success)
	        .catch(failure);
	    };

	    /**
	     * Takes a participant off hold. Only availble to admins.
	     *
	     * @method unHoldParticipant
	     * @async
	     * @param {String} conferenceId The ID of the conference.
	     * @param {String} participantId The ID of the participant.
	     * @param {Function} success The success callback. It receives no parameters.
	     * @param {Function} failure The failure callback. It receives no parameters.
	     */
	    exports.unHoldParticipant = function(conferenceId, participantId, success, failure) {
	        sendControl('unhold', conferenceId, participantId)
	        .then(success)
	        .catch(failure);
	    };

	    /**
	     * Removes a participant from the conference. Only availble to admins.
	     *
	     * @method removeParticipant
	     * @async
	     * @param {String} conferenceId The ID of the conference.
	     * @param {String} participantId The ID of the participant.
	     * @param {Function} success The success callback. It receives no parameters.
	     * @param {Function} failure The failure callback. It receives no parameters.
	     */
	    exports.removeParticipant = function(conferenceId, participantId, success, failure) {
	        sendControl('remove', conferenceId, participantId)
	        .then(success)
	        .catch(failure);
	    };

	    /**
	     * Changes a participant's display name. Only availble to admins.
	     *
	     * @method changeParticipantName
	     * @async
	     * @param {String} conferenceId The ID of the conference.
	     * @param {String} participantId The ID of the participant.
	     * @param {String} newName The new display name to assign to the participant.
	     * @param {Function} success The success callback. It receives no parameters.
	     * @param {Function} failure The failure callback. It receives no parameters.
	     */
	    exports.changeParticipantName = function(conferenceId, participantId, newName, success, failure) {
	        _kandyRequestAsync({
	            type: 'PUT',
	            url: '/users/mpv/participant/name',
	            params: {
	                conference_id: conferenceId,
	                participant_id: participantId,
	                name: newName
	            }
	        })
	        .then(function() {return undefined;}) // removes param from success callback
	        .then(success)
	        .catch(failure);
	    };

	    /*
	     * Adds a property to targetObject with name `propertyName`
	     * and value `value` if value exists.
	     */
	    function addProperty(targetObject, propertyName, value) {
	        if (value) {
	            targetObject[propertyName] = value;
	        }
	    }

	    /*
	     * Converts message from server to event. This will camelize, rename
	     * and restructure properties.
	     */
	    function convertMessageToEvent(msg) {
	        var event = {
	            type: msg.messageType,
	            UUID: msg.UUID,
	            timestamp: msg.server_time_stamp,
	            sender: msg.sender.full_user_id,
	            conferenceId: msg.conference_details.conference_id
	        };

	        // Only certain messages have these properties
	        addProperty(event, 'participantId', msg.participant_id);
	        addProperty(event, 'newParticipantName', msg.participant_new_name);
	        addProperty(event, 'ipAccess', msg.conference_details.ip_access);
	        addProperty(event, 'pstnAccess', msg.conference_details.pstn_access);
	        addProperty(event, 'pinCode', msg.conference_details.pin_code);

	        return event;
	    }

	    /*
	     * Handles notifications
	     */
	    var eventRebroadcastMap = {
	        conferenceInvite: 'conferenceInvite',
	        participantJoinedConference: 'participantJoinedConference',
	        participantLeftConference: 'participantLeftConference',
	        participantNameChanged: 'participantNameChanged',
	        participantMuted: 'participantMuted',
	        participantUnmuted: 'participantUnmuted',
	        participantVideoEnabled: 'participantVideoStarted',
	        participantVideoDisabled: 'participantVideoStopped',
	        participantPutOnHold: 'participantOnHold',
	        participantPutOffHold: 'participantOffHold'
	    };
	    registerWebSocketListeners({
	        'notification': function (message) {
	            var msg = message.message;

	            if(msg) {
	                // If the event is one we want to handle, emit it with the
	                // external event name.
	                var externalEventName = eventRebroadcastMap[msg.messageType];
	                if (externalEventName) {
	                    events.emit(externalEventName, convertMessageToEvent(msg));
	                }
	            }
	        }
	    });

	    return exports;
	}());

	/**
	 * The addressBook namespace contains functions to manage user's address book as well as to provide search and retrieval
	 * of the Kandy domain's directory. The address book contains user contacts that can be shared between all the different
	 * devices and Kandy apps.
	 *
	 * @todo We should add the ability to modify users in the personal address book.
	 * @class addressBook
	 * @namespace kandy
	 * @static
	 */
	api.addressBook = api.addressbook = (function() {

	    var me = {};

	    /**
	     * Search the domain directory by phone number.
	     *
	     * @method searchDirectoryByPhoneNumber
	     * @async
	     * @param {String} phoneNumber The phone number to search for. Can be a partial phone number.
	     * @param {Function} success The success callback. It receives one parameter.
	     * @param {User[]} success.users An array of users that correspond to the search criteria.
	     * @param {Function} failure The failure callback. It receives one parameter.
	     * @param {String} failure.errorMessage The error message explaining what failed.
	     */
	    me.searchDirectoryByPhoneNumber = function(phoneNumber, success, failure) {
	        _kandyRequest({
	            url: '/users/directories/native/searches/phone_number',
	            params: {
	                'search_string': phoneNumber
	            },
	            success: function(response) {
	                if (success) {
	                    success(response.result.contacts);
	                }
	            },
	            failure: failure
	        });
	    };

	    /**
	     * Search the domain directory by name. The search will be done on both the first name and the last name.
	     *
	     * @method searchDirectoryByName
	     * @async
	     * @param {String} name The name to search for. The name is case sensitive and can be a partial name.
	     * @param {Function} success The success callback. It receives one parameter.
	     * @param {User[]} success.users An array of users that correspond to the search criteria.
	     * @param {Function} failure The failure callback. It receives one parameter.
	     * @param {String} failure.errorMessage The error message explaining what failed.
	     */
	    me.searchDirectoryByName = function(name, success, failure) {
	        _kandyRequest({
	            url: '/users/directories/native/searches/name',
	            params: {
	                'search_string': name
	            },
	            success: function(response) {
	                if (success) {
	                    success(response.result.contacts);
	                }
	            },
	            failure: failure
	        });
	    };

	    /**
	     * Search the domain directory by username.
	     *
	     * @method searchDirectoryByUsername
	     * @async
	     * @param {String} username Username to search for.
	     * @param {Function} success The success callback. It receives one parameter.
	     * @param {User[]} success.users An array of users that correspond to the search criteria.
	     * @param {Function} failure The failure callback. It receives one parameter.
	     * @param {String} failure.errorMessage The error message explaining what failed.
	     */
	    me.searchDirectoryByUsername = function(username, success, failure) {
	        _kandyRequest({
	            url: '/users/directories/native/searches/user_id',
	            params: {
	                'search_string': username
	            },
	            success: function(response) {
	                if (success) {
	                    success(response.result.contacts);
	                }
	            },
	            failure: failure
	        });
	    };

	    /*
	     * @method searchDirectoryByUserName
	     * @deprecated Use `kandy.addressBook.searchDirectoryByUsername` instead.
	     * @async
	     * @param {String} username Username to search for.
	     * @param {Function} success The success callback. It receives one parameter.
	     * @param {User[]} success.users An array of users that correspond to the search criteria.
	     * @param {Function} failure The failure callback. It receives one parameter.
	     * @param {String} failure.errorMessage The error message explaining what failed.
	     */
	    me.searchDirectoryByUserName = me.searchDirectoryByUsername;

	    /**
	     * Full text search of the directory. This will search the first name, last name, user id and phone number. The
	     * search is case-sensitive and can be partial.
	     *
	     * @method searchDirectory
	     * @async
	     * @param {String} searchString The string to search for.
	     * @param {Function} success The success callback. It receives one parameter.
	     * @param {User[]} success.users An array of users that correspond to the search criteria.
	     * @param {Function} failure The failure callback. It receives one parameter.
	     * @param {String} failure.errorMessage The error message explaining what failed.
	     */
	    me.searchDirectory = function(searchString, success, failure) {
	        _kandyRequest({
	            url: '/users/directories/native/search/',
	            params: {
	                'search_string': searchString
	            },
	            success: function(response) {
	                if (success) {
	                    success(response.result.contacts);
	                }
	            },
	            failure: failure
	        });
	    };

	    /**
	     * Retrieves the whole directory.
	     *
	     * @method retrieveDirectory
	     * @async
	     * @param {Function} success The success callback. It receives one parameter.
	     * @param {User[]} success.users An array of all users in the directory.
	     * @param {Function} failure The failure callback. It receives one parameter.
	     * @param {String} failure.errorMessage The error message explaining what failed.
	     */
	    me.retrieveDirectory = function(success, failure) {
	        _kandyRequest({
	            url: '/users/directories/native',
	            success: function(response) {
	                if (success && response.result && response.result.contacts) {
	                    response.result.contacts.forEach(function(contact) {
	                        contact.firstName = contact.user_first_name;
	                        contact.lastName = contact.user_last_name;
	                        contact.number = contact.user_phone_number;
	                        contact.hintType = 'community';
	                        delete contact.user_first_name;
	                        delete contact.user_last_name;
	                    });
	                    success(response.result);
	                }
	            },
	            failure: failure
	        });
	    };

	    /**
	     * Retrieves all entries of the user's personal address book.
	     *
	     * @method retrievePersonalAddressBook
	     * @async
	     * @param {Function} success The success callback. It receives one parameter.
	     * @param {Contact[]} success.contacts An array of all contacts in the user's address book.
	     * @param {Function} failure The failure callback. It receives one parameter.
	     * @param {String} failure.errorMessage The error message explaining what failed.
	     */
	    me.retrievePersonalAddressBook = function(success, failure) {
	        _kandyRequest({
	            url: '/users/addressbooks/personal',
	            success: function(response) {
	                if (success) {
	                    success(response.result.contacts);
	                }
	            },
	            failure: failure
	        });
	    };

	    /**
	     * Adds a contact to the user's personal address book.
	     *
	     * @method addToPersonalAddressBook
	     * @async
	     * @param {Contact} contact The contact to add to the address book.
	     * @param {Function} success The success callback. It receives one parameter.
	     * @param {Contact} success.contact The contact that was added to the address book with it's newly generated
	     *                                  contact_id.
	     * @param {Function} failure The failure callback. It receives one parameter.
	     * @param {String} failure.errorMessage The error message explaining what failed.
	     */
	    me.addToPersonalAddressBook = function(contact, success, failure) {
	        _kandyRequest({
	            type: 'POST',
	            url: '/users/addressbooks/personal',
	            data: {
	                contact: contact
	            },
	            success: function(response) {
	                if (success) {
	                    success(response.result);
	                }
	            },
	            failure: failure
	        });
	    };

	    /**
	     * Remove a contact from the user's personal address book.
	     *
	     * @method removeFromPersonalAddressBook
	     * @async
	     * @param {String} contactId The contact id of the contact to remove.
	     * @param {Function} success The success callback. It receives no parameters.
	     * @param {Function} failure The failure callback. It receives one parameter.
	     * @param {String} failure.errorMessage The error message explaining what failed.
	     */
	    me.removeFromPersonalAddressBook = function(contactId, success, failure) {
	        _kandyRequest({
	            type: 'DELETE',
	            url: '/users/addressbooks/personal',
	            params: {
	                'contact_id': contactId
	            },
	            success: function(response) {
	                if (success) {
	                    success();
	                }
	            },
	            failure: failure
	        });
	    };

	    /**
	     * Retrieves the user's device address book. This address book is a separate address book.
	     *
	     * @private
	     * @todo One of a few things should happen here. Either we document why we have a separate read-only address book,
	     *       remove this feature, or add full management of this address book.
	     *
	     * @method retrieveUserDeviceAddressBook
	     * @async
	     * @param {Function} success The success callback. It receives one parameter.
	     * @param {Contact[]} success.contacts An array of all contacts in the user's address book.
	     * @param {Function} failure The failure callback. It receives one parameter.
	     * @param {String} failure.errorMessage The error message explaining what failed.
	     */
	    me.retrieveUserDeviceAddressBook = function(success, failure) {
	        _kandyRequest({
	            url: '/users/addressbooks/device',
	            success: function(response) {
	                if (success) {
	                    success(response.result);
	                }
	            },
	            failure: failure
	        });
	    };

	    return me;
	}());

	/*
	 * Everything in registration needs to be deprecated. These functions should be
	 * run on the server, especially since one of them requires a secret key.
	 *
	 * @class registration
	 * @namespace kandy
	 * @static
	 */

	api.Registration = api.registration = (function () {
	    var me = {};

	    /*
	     * @property {String} _config Domain Access Code.
	     */
	    var _domainAccessToken = null;

	    /*
	     * Fires passed event
	     *
	     * @method _fireEvent
	     */
	    function _fireEvent() {
	        var eventName = Array.prototype.shift.apply(arguments);

	        if (me.events[eventName]) {
	            me.events[eventName].apply(me, arguments);
	        }
	    }

	    /*
	     * @method setup
	     * @param {Object} config Configuration.
	     * @param {Array} [config.listeners={}] Listeners for KandyAPI.Registration.
	     * @param {String} [config.mediatorUrl="http://api.kandy.io"] Rest endpoint for KandyWrapper.
	     */
	    me.setup = function (config) {

	        // setup default configuration
	        _config = utils.extend(_config, config);

	        me._domainAccessToken = config.domainAccessToken;

	        // setup listeners
	        //TODO me.events realy needed for KandyAPI.Registration?
	        /*
	        if (_config.listeners) {
	            for (var listener in _config.listeners) {

	                // TODO: This has to be a bug right? We're only adding the listener if it's already defined?
	                if (me.events[listener] !== undefined) {
	                    me.events[listener] = _config.listeners[listener];
	                }
	            }
	        }

	        */
	        _logger = fcs.logManager.getLogger();
	    };

	    /*
	     * @method retrieveCountryCode
	     * Retrieves county code based on Device
	     * @param {Function} success The success callback.
	     * @param {Function} failure The failure callback.
	     */
	    me.retrieveCountryCode = function (success, failure) {
	        _kandyRequest({
	            url: '/domains/countrycodes',
	            params: {
	                key: me._domainAccessToken
	            },
	            success: function (response) {
	                if (success) {
	                    success(response.result);
	                }
	            },
	            failure: failure
	        });
	    };

	    /*
	     * @method sendValidationCode
	     * Send validation code to phone
	     * @param {String} phoneNumber Phone number to send validation SMS to.
	     * @param {Function} success The success callback.
	     * @param {Function} failure The failure callback.
	     */
	    me.sendValidationCode = function (phoneNumber, countryCode, success, failure) {
	        _kandyRequest({
	            type: 'POST',
	            url: '/domains/verifications/smss',
	            params: {
	                key: me._domainAccessToken
	            },
	            data: {
	                'user_phone_number': phoneNumber,
	                'user_country_code': countryCode
	            },
	            success: success,
	            failure: failure
	        });
	    };

	    /*
	     * @method validateCode
	     * Validate SMS code sent to phone
	     * @param {String} validationCode Validation code sent to phone.
	     * @param {Function} success The success callback.
	     * @param {Function} failure The failure callback.
	     */
	    me.validateCode = function (validationCode, success, failure) {
	        var encodedAccessCode = encodeURIComponent(me._domainAccessToken);

	        _kandyRequest({
	            url: '/domains/verifications/codes',
	            params: {
	                key: me._domainAccessToken,
	                'validation_code': validationCode
	            },
	            success: function (response) {
	                if (success) {
	                    success(response.result.valid);
	                }
	            },
	            failure: failure
	        });
	    };

	    me.getUserInfo = function (success, failure) {
	        _kandyRequest({
	            url: '/users/billing/packages/status/active',
	            success: function (response) {
	                if (success) {
	                    success(response.result);
	                }
	            },
	            failure: failure
	        });
	    };

	    me.getProfileInfo = function (userId, domainId, success, failure) {

	        _kandyRequest({
	            url: '/users/profiles/user_profiles/user_profile',
	            params: {
	                'user_id': userId,
	                'domain_name': domainId
	            },
	            success: function (response) {
	                if (success) {
	                    success(response.result);
	                }
	            },
	            failure: failure
	        });
	    };

	    // TODO: Document, and set parameters to camel case.
	    me.setProfileInfo = function (data, success, failure) {
	        _kandyRequest({
	            type: 'POST',
	            url: '/users/profiles/user_profiles',
	            params: {
	                'first_name': data.first_name,
	                'last_name': data.last_name,
	                'status_text': data.status_text,
	                'image_details': data.image_details,
	                'user_data': data.user_data
	            },
	            success: function (response) {
	                if (success) {
	                    success();
	                }
	            },
	            failure: failure
	        });
	    };


	    /*
	     * @method register a device
	     * Registers a device in Kandy
	     * @param {Object}
	     * e.g. {
	     *        {String} domainAccessToken: "7b81d8e63f5b478382b4e23127260090", // optional
	     *        {String} userPhoneNumber: "4034932232",
	     *        {String} userCountryCode "UA",
	     *        {String} validationCode "1234",
	     *        {String} deviceNativeId "3456",
	     *        {String} deviceFamily "iPhone",  // optional
	     *        {String} deviceName "myPhone",  // optional
	     *        {String} clientSwVersion "4",  // optional
	     *        {String} deviceOsVersion "801",  // optional
	     *        {String} userPassword "pwdxyz13!",  // optional
	     *        {Function} success = function() { doSomething(); }
	     *        {Function} failure = function() { doSomethingElse(); }
	     *   }
	     * @return {Object} response object
	     * e.g. { user_id: "972542405850",
	     full_user_id: "972542405850@domain.com",
	     domain_name:  "domain.com",
	     user_access_token: "4d405f6dfd9842a981a90daaf0da08fa",
	     device_id: "4d405f6dfd9842a389d5b45d65a9dfd0"
	     }
	     */
	    me.register = function (params, success, failure) {
	        _kandyRequest({
	            type: 'POST',
	            url: '/api_wrappers/registrations',
	            params: {
	                // TODO "internal server error" if client_sw_version and client_sw_type are used.
	                // 'client_sw_version': api.version,
	                // 'client_sw_type': 'JS',

	                key: me._domainAccessToken
	            },
	            data: {

	                'user_phone_number': params.userPhoneNumber,
	                'user_country_code': params.userCountryCode,
	                'validation_code': params.validationCode,
	                'device_native_id': params.deviceNativeId
	            },
	            success: function (response) {
	                if (success) {
	                    success(response.result);
	                }

	            },
	            failure: failure
	        });
	    };

	    /*
	     * @method getConfiguration
	     * Retrieves domain name, access token, and SPiDR configuration
	     * @param {String} domainApiKey
	     * @param {String} domainApiSecret
	     * @param {Function} success The success callback.
	     * @param {Function} failure The failure callback.
	     * @return {Object} response object
	     * e.g. {
	     "domain_name": "domain.com",
	     "domain_access_token": "4d405f6dfd9842a981a90daaf0da08fa",
	     "spidr_configuration":
	     {
	     "REST_server_address":"kandysimplex.fring.com",
	     "REST_server_port":443,
	     "webSocket_server_address":"kandysimplex.fring.com",
	     "webSocket_server_port":8582,
	     "ICE_server_address":"54.84.226.174",
	     "ICE_server_port":3478,
	     "subscription_expire_time_seconds":null,
	     "REST_protocol":"https",
	     "server_certificate":null,
	     "use_DTLS":false,
	     "audit_enable":true,
	     "audit_packet_frequency":null
	     }
	     }
	     */

	    me.getConfiguration = function (params, success, failure) {
	        _kandyRequest({
	            url: '/api_wrappers/configurations',
	            params: {
	                key: params.domainApiKey,
	                'domain_api_secret': params.domainApiSecret
	            },
	            success: function (response) {
	                if (success) {
	                    success({
	                        domainName: response.result.domain_name,
	                        domainAccessToken: response.result.domain_access_token,
	                        spidrConfiguration: {
	                            restUrl: response.result.spidr_configuration.REST_server_address,
	                            restPort: response.result.spidr_configuration.REST_server_port,
	                            protocol: response.result.spidr_configuration.REST_protocol,
	                            websocketIP: response.result.spidr_configuration.webSocket_server_address,
	                            websocketPort: response.result.spidr_configuration.webSocket_server_port,
	                            'spidr_env': {
	                                iceserver: ('stun:' + response.result.spidr_configuration.ICE_server_address + ':' +
	                                        response.result.spidr_configuration.ICE_server_port),
	                                ice: ('STUN stun:' + response.result.spidr_configuration.ICE_server_address + ':' +
	                                        response.result.spidr_configuration.ICE_server_port)

	                            }
	                        }
	                    });
	                }
	            },
	            failure: failure
	        });
	    };

	    return me;
	}());

	/**
	 * Module to group type interfaces used throughout kandy.
	 *
	 * @todo Split this into multiple files. It is getting too big.
	 * @module interfaces
	 * @namespace
	 */

	//======================================================================================================================

	/**
	 * The call interface contains information about a call. It is used only during call events.
	 *
	 * @class Call
	 */

	/**
	 * The username or number of the callee for the call.
	 *
	 * @property calleeNumber
	 * @type String
	 */

	/**
	 * Caller first and last name of the call.
	 *
	 * @property callerName
	 * @type String
	 */

	/**
	 * The number or full user id (username@domainname.com) of the caller  for the call.
	 *
	 * @property callerNumber
	 * @type String
	 */

	/**
	 * Flag for whether the remote side of an incoming call is PSTN.
	 *
	 * @property isRemotePSTN
	 * @type Boolean
	 */

	/**
	 * Flag indicating whether the call is an anonymous call.
	 *
	 * @private
	 * @property isAnonymous
	 * @type Boolean
	 */

	/**
	 * Returns the id of the call.
	 *
	 * @method getId
	 * @return {String} Id of the call.
	 */

	/**
	 * Returns a string that corresponds to the remote video state.
	 * @method getRemoteVideoState
	 * @return {String} Can be "sendrecv", "sendonly", "recvonly", "inactive" or "notfound"
	 */

	//======================================================================================================================

	/**
	 * The User interface represents a user and it's properties. It is used as part of the address book APIs.
	 *
	 * @todo This should be normalized to using camel case properties.
	 * @class User
	 */

	/**
	 * The user id without the domain (e.g. "john.smith").
	 *
	 * @property user_id
	 * @type String
	 */

	/**
	 * The user's domain name.
	 *
	 * @property domain_name
	 * @type String
	 */

	/**
	 * The user's full user id including the domain (e.g. "john.smith@domain.com")
	 *
	 * @property full_user_id
	 * @type String
	 */

	/**
	 * The user's first name.
	 *
	 * @property user_first_name
	 * @type String
	 */

	/**
	 * The user's last name.
	 *
	 * @property user_last_name
	 * @type String
	 */

	/**
	 * The user's email.
	 *
	 * @property user_email
	 * @type String
	 */

	/**
	 * The user's phone number.
	 *
	 * @property user_phone_number
	 * @type String
	 */

	//======================================================================================================================

	/**
	 * The Contact interface represents a contact stored in a user's personal address book. Note that
	 * a contact does not have any formal references to a Kandy user. An application can manage such a reference
	 * by using one of the fields provided, or add new fields as needed.
	 *
	 * @class Contact
	 */

	/**
	 * The id of the contact. This is a read-only property generated by Kandy.
	 *
	 * @todo Make this camel case.
	 * @property contact_id
	 * @readOnly
	 */

	/**
	 * The name of the contact.
	 *
	 * @property name
	 * @type String
	 * @optional
	 */

	/**
	 * The nickname of the contact.
	 *
	 * @property nickname
	 * @type String
	 * @optional
	 */

	/**
	 * The first name of the contact.
	 *
	 * @property firstName
	 * @type String
	 * @optional
	 */

	/**
	 * The last name of the contact.
	 *
	 * @property lastName
	 * @type String
	 * @optional
	 */

	/**
	 * The email of the contact.
	 *
	 * @property email
	 * @type String
	 * @optional
	 */

	/**
	 * The home phone number of the contact.
	 *
	 * @property homePhone
	 * @type String
	 * @optional
	 */

	/**
	 * The business phone number of the contact.
	 *
	 * @property businessPhone
	 * @type String
	 * @optional
	 */

	/**
	 * The mobile phone number of the contact.
	 *
	 * @property mobilePhone
	 * @type String
	 * @optional
	 */

	/**
	 * The fax number of the contact.
	 *
	 * @property fax
	 * @type String
	 * @optional
	 */

	//======================================================================================================================

	/**
	 * The group interface represents a group that can contain one or many users. Users can join and leave
	 * groups in order to send and receive messages posted to the group for all members to see. The
	 * creator of the group is the admin and they can do things like add group members or mute them.
	 *
	 * @class Group
	 */

	/**
	 * The id of the group. This is a read-only property generated by Kandy.
	 *
	 * @todo Make every property of this class camel case.
	 * @property group_id
	 * @type String
	 * @readOnly
	 */

	/**
	 * The name of the group assigned or updated by the creator.
	 *
	 * @property group_name
	 * @type String
	 * @optional
	 */

	/**
	 * The image of the group assigned or updated by the creator.
	 *
	 * @property group_image
	 * @type String
	 * @optional
	 */

	/**
	 * The maximum number of members allowed to join the group.
	 *
	 * @property max_members
	 * @type Number
	 * @optional
	 */

	/**
	 * An array of member objects for members who are owners of the group.
	 *
	 * @property owners
	 * @optional
	 */

	/**
	 * A unix timestamp of the time the date and time the group was created.
	 *
	 * @property creation_time
	 * @optional
	 */

	/**
	 * An array of member objects corresponding to the members in the group.
	 *
	 * @property members
	 * @type Member[]
	 * @optional
	 */

	/**
	 * A boolean property that is true when the group is muted and false otherwise.
	 * When a group is muted, none of its members can send messages.
	 *
	 * @property muted
	 * @optional
	 */

	//======================================================================================================================

	/**
	 * The Member interface represents a user who is part of a group.
	 *
	 * @class Member
	 */

	/**
	 * The user id for the member.
	 *
	 * @todo Make this camel case.
	 * @property full_user_id
	 * @type String
	 * @readonly
	 */

	/**
	 * A boolean property that is true when the member is muted and false otherwise.
	 * Muted members cannot send messages.
	 *
	 * @property muted
	 * @type Boolean
	 * @optional
	 */

	//======================================================================================================================

	/**
	 * Interface representing a device.
	 *
	 * @class Device
	 */

	/**
	 * The device's id.
	 *
	 * @property id
	 * @type String
	 */

	/**
	 * The device's native id.
	 *
	 * @property nativeID
	 * @type String
	 */

	/**
	 * The device's family.
	 *
	 * @property family
	 * @type String
	 */

	/**
	 * The device's name.
	 *
	 * @property name
	 * @type String
	 */

	/**
	 * The device's OS version.
	 *
	 * @property osVersion
	 * @type String
	 */

	/**
	 * The device's client version.
	 *
	 * @property clientVersion
	 * @type String
	 */

	//======================================================================================================================

	/**
	 * The Message interface represents a message between 2 targets including envelope and metadata information.
	 *
	 * @class Message
	 */

	/**
	 * The unique id of the message.
	 *
	 * @property UUID
	 * @type String
	 */

	/**
	 * The type of content for this message.
	 * Can be one of: 'text', 'file', 'video', 'audio', 'image', 'location', 'contact'
	 *
	 * @property contentType
	 * @type String
	 */

	/**
	 * The destination of the message as a fully qualified username. This field is only used for personal chat or SMS messages.
	 *
	 * @property destination
	 * @type String
	 */

	/**
	 * The id of the group this message belongs to. This field is only used for group chat event messages.
	 *
	 * @property group_id
	 * @type String
	 */

	/**
	 * The name of the group. This field is only used for group chat event messages.
	 *
	 * @property group_name
	 * @type String
	 */

	/**
	 * The user that is inviting other users. This field is only used for `chatGroupInvite` event messages.
	 *
	 * @property inviter
	 * @type String
	 */

	/**
	 * The users being invited to a group chat. This field is only used for `chatGroupInvite` event messages. This is an array of full user ids.
	 *
	 * @property invitees
	 * @type String[]
	 */

	/**
	 * The user that is booting other users. This field is only used for `chatGroupBoot` event messages.
	 *
	 * @property booter
	 * @type String
	 */

	/**
	 * The users being removed from a group chat. This field is only used for `chatGroupBoot` event messages. This is an array of full user ids.
	 *
	 * @property booted
	 * @type String[]
	 */

	/**
	 * The user updating the group chat. This field is only used for `chatGroupUpdate` event messages.
	 *
	 * @property updater
	 * @type String
	 */

	/**
	 * The user deleting the group chat. This field is only used for `chatGroupDelete` event messages.
	 *
	 * @property eraser
	 * @type String
	 */

	/**
	 * The type of message that this represents. Can be one of:
	 * - chat: Personal chat message.
	 * - groupChat: Group chat message.
	 * - chatGroupInvite: All chat members receive the chatGroupInvite event message when someone is invited.
	 * - chatGroupBoot: All chat member recieve the chatGroupBoot event message when someone is booted.
	 * - chatGroupLeave: All chat members receive the chatGroupLeave event message when someone leaves the group.
	 * - chatGroupUpdate: All chat members receive the chatGroupUpdate event message when someone updates the group via updateGroup().
	 * - chatGroupDelete: All chat members receive the chatGroupDelete event message when the group is deleted.
	 * - chatRemoteAck: The sender of a message receives the chatRemoteAck event message when the message was acknowledged.
	 *
	 * @property messageType
	 * @type String
	 */

	/**
	 * The sender of a message.
	 *
	 * @property sender
	 * @type MessageSender
	 */

	/**
	 * A timestamp that represents the time that the message was sent in milliseconds since the unix epoch time.
	 *
	 * @property timestamp
	 * @type number
	 */

	/**
	 * A sequence number that represents the order in which this message was sent compared to other
	 * messages within the same conversation.
	 *
	 * @property scn
	 * @type number
	 */

	/**
	 * The payload of the message.
	 *
	 * @property message
	 * @type MessagePayload
	 */

	//======================================================================================================================

	/**
	 * Describes the payload of a message. Note that some fields are only used with certain
	 * content types.
	 *
	 * @class MessagePayload
	 */

	/**
	 * The text sent with the message. Used only for the 'text' content type.
	 *
	 * @property text
	 * @type String
	 */

	/**
	 * The mime type of the message payload.
	 *
	 * @property mimeType
	 * @type String
	 */

	/**
	 * Describes the name of a file that is attached with this message. Used for 'file', 'video', 'audio', 'image'
	 * and 'contact' content types.
	 *
	 * @property content_name
	 * @type String
	 */

	/**
	 * The unique identifier of a file that is attached with this message. This id can be used to retrieve the file with
	 * `kandy.messaging.buildFileUrl` and `kandy.messaging.buildFileThumbnailUrl`.Used for 'file', 'video', 'audio', 'image'
	 * and 'contact' content types.
	 *
	 * @property content_uuid
	 * @type String
	 */

	/**
	 * Display name for a sent contact. Only used for the 'contact' content type.
	 *
	 * @property contact_display_name
	 * @type String
	 */

	/**
	 * Longitude coordinate of a sent location. Only used for 'location' content type.
	 *
	 * @property locationLongitude
	 * @type String
	 */

	/**
	 * Latitude coordinate of a sent location. Only used for 'location' content type.
	 *
	 * @property locationLatitude
	 * @type String
	 */

	//======================================================================================================================

	/**
	 * Describes the sender of a message
	 *
	 * @class MessageSender
	 */

	/**
	 * Domain name of the sender.
	 *
	 * @property domain_name
	 * @type String
	 */

	/**
	 * Simple username of the sender.
	 *
	 * @property user_id
	 * @type String
	 */

	/**
	 * Full user id of the sender.
	 *
	 * @property full_user_id
	 * @type String
	 */

	//======================================================================================================================

	/**
	  * The WebRTCStats interface represents statistics for a WebRTC call. The statistics are either for the audio or video of the call.
	  * @class WebRTCStats
	  */

	 /**
	  * The number of bytes received so far for the call.
	  * @property bytesReceived
	  * @type Number
	  */

	 /**
	  * The number of bytes sent so far for the call.
	  * @property bytesSent
	  * @type Number
	  */

	 /**
	  * The codec used for this media type of the call.
	  * @property codec
	  * @type String
	 */

	/**
	  * Packet jitter measured in seconds. In audio stats only.
	  * @property jitter
	  * @type String
	 */

	/**
	  * Number of packets lost so far for the call.
	  * @property packetsLost
	  * @type Number
	 */

	/**
	  * Number of packets sent so far for the call.
	  * @property packetsSent
	  * @type Number
	 */

	/**
	  * Address of the connected peer for the call.
	  * @property peerAddress
	  * @type String
	 */

	/**
	  * The round trip time computed by the STUN connectivity checks.
	  * @property rtt
	  * @type String
	 */

	//======================================================================================================================

	/**
	 * The conference interface represents a multi-party call.
	 * @class Conference
	 */

	/**
	 * The ID of the conference.
	 *
	 * @property conferenceId
	 */

	/**
	 * The PSTN phone number you can use to call into the conference.
	 *
	 * @property pstnAccess
	 */

	/**
	 * The IP number you can use to call into the conference.
	 *
	 * @property ipAccess
	 */

	/**
	 * An array of Participants's full user IDs for the participants in the conference.
	 *
	 * @property participants
	 * @type Participant[]
	 */

	/**
	 * An array of administrators's full user IDs of the conference.
	 *
	 * @property administrators
	 * @type String[]
	 */

	//======================================================================================================================

	/**
	 * The Participant object, representing a conference participant.
	 * @class Participant
	 */

	/**
	 * The Id of the participant.
	 *
	 * @property participantId
	 */

	/**
	 * The participant's display name.
	 *
	 * @property displayName
	 */

	/**
	 * The length of time that the user has been in the conference, in seconds.
	 *
	 * @property callDuration
	 */

	/**
	 * The state of the participants audio. Can be 'incoming_outgoing' or 'incoming'
	 *
	 * @property audioState
	 */

	/**
	 * The state of the participants video. Can be 'incoming_outgoing' or 'incoming'
	 *
	 * @property videoState
	 */


	    //Announced deprecation in 2.2.0

	    api.Phone.sendSMS = function (){
	        _logger.warn('KandyAPI.Phone.sendSMS is deprecated please use kandy.messaging.sendSMS');
	        return api.messaging.sendSMS.apply(null, arguments);
	    };

	    api.Phone.sendIm = function (){
	        _logger.warn('KandyAPI.Phone.sendIm is deprecated please use kandy.messaging.sendIm');
	        return api.messaging.sendIm.apply(null, arguments);
	    };
	    api.Phone.sendJSON = function (){
	        _logger.warn('KandyAPI.Phone.sendJSON is deprecated please use kandy.messaging.sendJSON');
	        return api.messaging.sendJSON.apply(null, arguments);
	    };
	    api.Phone.sendImWithFile = function (){
	        _logger.warn('KandyAPI.Phone.sendImWithFile is deprecated please use kandy.messaging.sendImWithFile');
	        return api.messaging.sendImWithFile.apply(null, arguments);
	    };
	    api.Phone.sendImWithImage = function (){
	        _logger.warn('KandyAPI.Phone.sendImWithImage is deprecated please use kandy.messaging.sendImWithImage');
	        return api.messaging.sendImWithImage.apply(null, arguments);
	    };
	    api.Phone.sendImWithAudio = function (){
	        _logger.warn('KandyAPI.Phone.sendImWithAudio is deprecated please use kandy.messaging.sendImWithAudio');
	        return api.messaging.sendImWithAudio.apply(null, arguments);
	    };
	    api.Phone.sendImWithVideo = function (){
	        _logger.warn('KandyAPI.Phone.sendImWithVideo is deprecated please use kandy.messaging.sendImWithVideo');
	        return api.messaging.sendImWithVideo.apply(null, arguments);
	    };
	    api.Phone.uploadFile = function (){
	        _logger.warn('KandyAPI.Phone.uploadFile is deprecated please use kandy.messaging.uploadFile');
	        return api.messaging.uploadFile.apply(null, arguments);
	    };
	    api.Phone.buildFileUrl = function (){
	        _logger.warn('KandyAPI.Phone.buildFileUrl is deprecated please use kandy.messaging.buildFileUrl');
	        return api.messaging.buildFileUrl.apply(null, arguments);
	    };
	    api.Phone.buildFileThumbnailUrl = function (){
	        _logger.warn('KandyAPI.Phone.buildFileThumbnailUrl is deprecated please use kandy.messaging.buildFileThumbnailUrl');
	        return api.messaging.buildFileThumbnailUrl.apply(null, arguments);
	    };

	    api.Phone.getIm = function (){
	        _logger.warn('KandyAPI.Phone.getIm is deprecated please use kandy.messaging.getIm');
	        return api.messaging.getIm.apply(null, arguments);
	    };

	    api.Phone.clearIm = function (){
	        _logger.warn('KandyAPI.Phone.clearIm is deprecated please use kandy.messaging.clearIm');
	        return api.messaging.clearIm.apply(null, arguments);
	    };

	    api.Phone.searchDirectoryByPhoneNumber = function (){
	        _logger.warn('KandyAPI.Phone.searchDirectoryByPhoneNumber is deprecated please use kandy.addressbook.searchDirectoryByPhoneNumber');
	        return api.addressbook.searchDirectoryByPhoneNumber.apply(null, arguments);
	    };
	    api.Phone.searchDirectoryByName = function (){
	        _logger.warn('KandyAPI.Phone.searchDirectoryByName is deprecated please use kandy.addressbook.searchDirectoryByName');
	        return api.addressbook.searchDirectoryByName.apply(null, arguments);
	    };
	    api.Phone.searchDirectoryByUserName = function (){
	        _logger.warn('KandyAPI.Phone.searchDirectoryByUserName is deprecated please use kandy.addressbook.searchDirectoryByUserName');
	        return api.addressbook.searchDirectoryByUserName.apply(null, arguments);
	    };
	    api.Phone.searchDirectory = function (){
	        _logger.warn('KandyAPI.Phone.searchDirectory is deprecated please use kandy.addressbook.searchDirectory');
	        return api.addressbook.searchDirectory.apply(null, arguments);
	    };
	    api.Phone.retrievePersonalAddressBook = function (){
	        _logger.warn('KandyAPI.Phone.retrievePersonalAddressBook is deprecated please use kandy.addressbook.retrievePersonalAddressBook');
	        api.addressbook.retrievePersonalAddressBook.apply(null, arguments);
	    };
	    api.Phone.addToPersonalAddressBook = function (){
	        _logger.warn('KandyAPI.Phone.addToPersonalAddressBook is deprecated please use kandy.addressbook.addToPersonalAddressBook');
	        return api.addressbook.addToPersonalAddressBook.apply(null, arguments);
	    };
	    api.Phone.removeFromPersonalAddressBook = function (){
	        _logger.warn('KandyAPI.Phone.removeFromPersonalAddressBook is deprecated please use kandy.addressbook.removeFromPersonalAddressBook');
	        return api.addressbook.removeFromPersonalAddressBook.apply(null, arguments);
	    };
	    api.Phone.retrieveUserDeviceAddressBook = function (){
	        _logger.warn('KandyAPI.Phone.retrieveUserDeviceAddressBook is deprecated please use kandy.addressbook.retrieveUserDeviceAddressBook');
	        return api.addressbook.retrieveUserDeviceAddressBook.apply(null, arguments);
	    };


	    return api;
	}

	module.exports = getKandy();

/***/ },
/* 1 */
/***/ function(module, exports, __webpack_require__) {

	var __WEBPACK_AMD_DEFINE_FACTORY__, __WEBPACK_AMD_DEFINE_RESULT__;// UMD module definition as described by https://github.com/umdjs/umd
	(function (root, factory) {
	    if (true) {
	        // AMD. Register a named module.
	        !(__WEBPACK_AMD_DEFINE_FACTORY__ = (factory), __WEBPACK_AMD_DEFINE_RESULT__ = (typeof __WEBPACK_AMD_DEFINE_FACTORY__ === 'function' ? (__WEBPACK_AMD_DEFINE_FACTORY__.call(exports, __webpack_require__, exports, module)) : __WEBPACK_AMD_DEFINE_FACTORY__), __WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));
	    } else {
	        // Browser globals
	        root.fcs = factory();
	    }
	 }(this, function () {

	// Base64 by Kevin van Zonneveld - Public Domain
	// Original Source: http://kevin.vanzonneveld.net/

	function base64_encode (data) {
	    // http://kevin.vanzonneveld.net
	    // +   original by: Tyler Akins (http://rumkin.com)
	    // +   improved by: Bayron Guevara
	    // +   improved by: Thunder.m
	    // +   improved by: Kevin van Zonneveld (http://kevin.vanzonneveld.net)
	    // +   bugfixed by: Pellentesque Malesuada
	    // +   improved by: Kevin van Zonneveld (http://kevin.vanzonneveld.net)
	    // -    depends on: utf8_encode
	    // *     example 1: base64_encode('Kevin van Zonneveld');
	    // *     returns 1: 'S2V2aW4gdmFuIFpvbm5ldmVsZA=='

	    // mozilla has this native
	    // - but breaks in 2.0.0.12!
	    //if (typeof this.window['atob'] == 'function') {
	    //    return atob(data);
	    //}

	    var b64 = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/=";
	    var o1, o2, o3, h1, h2, h3, h4, bits, i = 0, ac = 0, enc="", tmp_arr = [];

	    if (!data) {
	        return data;
	    }

	    data = utf8_encode(data+'');

	    do { // pack three octets into four hexets
	        o1 = data.charCodeAt(i++);
	        o2 = data.charCodeAt(i++);
	        o3 = data.charCodeAt(i++);

	        bits = o1<<16 | o2<<8 | o3;

	        h1 = bits>>18 & 0x3f;
	        h2 = bits>>12 & 0x3f;
	        h3 = bits>>6 & 0x3f;
	        h4 = bits & 0x3f;

	        // use hexets to index into b64, and append result to encoded string
	        tmp_arr[ac++] = b64.charAt(h1) + b64.charAt(h2) + b64.charAt(h3) + b64.charAt(h4);
	    } while (i < data.length);

	    enc = tmp_arr.join('');

	    switch (data.length % 3) {
	        case 1:
	            enc = enc.slice(0, -2) + '==';
	        break;
	        case 2:
	            enc = enc.slice(0, -1) + '=';
	        break;
	    }

	    return enc;
	}



	function base64_decode (data) {
	    // http://kevin.vanzonneveld.net
	    // +   original by: Tyler Akins (http://rumkin.com)
	    // +   improved by: Thunder.m
	    // +      input by: Aman Gupta
	    // +   improved by: Kevin van Zonneveld (http://kevin.vanzonneveld.net)
	    // +   bugfixed by: Onno Marsman
	    // +   bugfixed by: Pellentesque Malesuada
	    // +   improved by: Kevin van Zonneveld (http://kevin.vanzonneveld.net)
	    // +      input by: Brett Zamir (http://brett-zamir.me)
	    // +   bugfixed by: Kevin van Zonneveld (http://kevin.vanzonneveld.net)
	    // -    depends on: utf8_decode
	    // *     example 1: base64_decode('S2V2aW4gdmFuIFpvbm5ldmVsZA==');
	    // *     returns 1: 'Kevin van Zonneveld'

	    // mozilla has this native
	    // - but breaks in 2.0.0.12!
	    //if (typeof this.window['btoa'] == 'function') {
	    //    return btoa(data);
	    //}

	    var b64 = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/=";
	    var o1, o2, o3, h1, h2, h3, h4, bits, i = 0, ac = 0, dec = "", tmp_arr = [];

	    if (!data) {
	        return data;
	    }

	    data += '';

	    do {  // unpack four hexets into three octets using index points in b64
	        h1 = b64.indexOf(data.charAt(i++));
	        h2 = b64.indexOf(data.charAt(i++));
	        h3 = b64.indexOf(data.charAt(i++));
	        h4 = b64.indexOf(data.charAt(i++));

	        bits = h1<<18 | h2<<12 | h3<<6 | h4;

	        o1 = bits>>16 & 0xff;
	        o2 = bits>>8 & 0xff;
	        o3 = bits & 0xff;

	        if (h3 == 64) {
	            tmp_arr[ac++] = String.fromCharCode(o1);
	        } else if (h4 == 64) {
	            tmp_arr[ac++] = String.fromCharCode(o1, o2);
	        } else {
	            tmp_arr[ac++] = String.fromCharCode(o1, o2, o3);
	        }
	    } while (i < data.length);

	    dec = tmp_arr.join('');
	    dec = utf8_decode(dec);

	    return dec;
	}


	function utf8_encode ( argString ) {
	    // http://kevin.vanzonneveld.net
	    // +   original by: Webtoolkit.info (http://www.webtoolkit.info/)
	    // +   improved by: Kevin van Zonneveld (http://kevin.vanzonneveld.net)
	    // +   improved by: sowberry
	    // +    tweaked by: Jack
	    // +   bugfixed by: Onno Marsman
	    // +   improved by: Yves Sucaet
	    // +   bugfixed by: Onno Marsman
	    // +   bugfixed by: Ulrich
	    // *     example 1: utf8_encode('Kevin van Zonneveld');
	    // *     returns 1: 'Kevin van Zonneveld'

	    var string = (argString+''); // .replace(/\r\n/g, "\n").replace(/\r/g, "\n");

	    var utftext = "";
	    var start, end;
	    var stringl = 0;

	    start = end = 0;
	    stringl = string.length;
	    for (var n = 0; n < stringl; n++) {
	        var c1 = string.charCodeAt(n);
	        var enc = null;

	        if (c1 < 128) {
	            end++;
	        } else if (c1 > 127 && c1 < 2048) {
	            enc = String.fromCharCode((c1 >> 6) | 192) + String.fromCharCode((c1 & 63) | 128);
	        } else {
	            enc = String.fromCharCode((c1 >> 12) | 224) + String.fromCharCode(((c1 >> 6) & 63) | 128) + String.fromCharCode((c1 & 63) | 128);
	        }
	        if (enc !== null) {
	            if (end > start) {
	                utftext += string.substring(start, end);
	            }
	            utftext += enc;
	            start = end = n+1;
	        }
	    }

	    if (end > start) {
	        utftext += string.substring(start, string.length);
	    }

	    return utftext;
	}

	function utf8_decode ( str_data ) {
	    // http://kevin.vanzonneveld.net
	    // +   original by: Webtoolkit.info (http://www.webtoolkit.info/)
	    // +      input by: Aman Gupta
	    // +   improved by: Kevin van Zonneveld (http://kevin.vanzonneveld.net)
	    // +   improved by: Norman "zEh" Fuchs
	    // +   bugfixed by: hitwork
	    // +   bugfixed by: Onno Marsman
	    // +      input by: Brett Zamir (http://brett-zamir.me)
	    // +   bugfixed by: Kevin van Zonneveld (http://kevin.vanzonneveld.net)
	    // *     example 1: utf8_decode('Kevin van Zonneveld');
	    // *     returns 1: 'Kevin van Zonneveld'

	    var tmp_arr = [], i = 0, ac = 0, c1 = 0, c2 = 0, c3 = 0;

	    str_data += '';

	    while ( i < str_data.length ) {
	        c1 = str_data.charCodeAt(i);
	        if (c1 < 128) {
	            tmp_arr[ac++] = String.fromCharCode(c1);
	            i++;
	        } else if ((c1 > 191) && (c1 < 224)) {
	            c2 = str_data.charCodeAt(i+1);
	            tmp_arr[ac++] = String.fromCharCode(((c1 & 31) << 6) | (c2 & 63));
	            i += 2;
	        } else {
	            c2 = str_data.charCodeAt(i+1);
	            c3 = str_data.charCodeAt(i+2);
	            tmp_arr[ac++] = String.fromCharCode(((c1 & 15) << 12) | ((c2 & 63) << 6) | (c3 & 63));
	            i += 3;
	        }
	    }

	    return tmp_arr.join('');
	}
	var Map = function() {
	    var items = {},
	        length = 0;

	    this.size = function() {
	        return length;
	    };

	    this.add = function(key, value) {
	        length++;
	        items[key] = value;
	        return this;
	    };

	    this.get = function(key) {
	        return items[key];
	    };

	    this.remove = function(key) {
	        length--;
	        return delete items[key];
	    };

	    this.clear = function() {
	        var variableKey;
	        for (variableKey in items) {
	            if (items.hasOwnProperty(variableKey)) {
	                if (delete items[variableKey]) {
	                    length--;
	                }
	            }
	        }
	    };

	    this.entries = function() {
	        return items;
	    };
	};

	function extend(target, object) {
	    var prop;
	    for (prop in object) {
	        if (object.hasOwnProperty(prop)) {
	            target[prop] = object[prop];
	        }
	    }
	    return target;
	}



	function addToServiceListImpl(instance, service, manager, _fcsConfig) {

	    if (!_fcsConfig.serviceManagerMap) {
	        _fcsConfig.serviceManagerMap = new Map();
	    }

	    if (!_fcsConfig.serviceManagerMap.get(instance)) {
	        _fcsConfig.serviceManagerMap.add(instance, new Map());
	    }

	    _fcsConfig.serviceManagerMap.get(instance).add(service, manager);
	}

	function addToServiceList(instance, service, manager) {
	    addToServiceListImpl(instance, service, manager, fcsConfig);
	}



	var GlobalBroadcaster = function() {
	    var MAX_PRIORITY = 10,
	        MIN_PRIORITY = 1,
	        topics = {},
	        subUid = -1;

	    function unsubscribeFromTopic(token) {
	        var m, i, j;
	        for (m in topics) {
	            if (topics[m] && topics.hasOwnProperty(m)) {
	                j = topics[m].length;
	                for (i = 0; i < j; i++) {
	                    if (topics[m][i].token === token) {
	                        topics[m].splice(i, 1);
	                        return token;
	                    }
	                }
	            }
	        }
	        return false;
	    }

	    function subscribeToTopic(topic, func, priority, temporary) {
	        var token, prio = MAX_PRIORITY,
	            temp = false;

	        if (typeof topic !== 'string') {
	            throw new Error("First parameter must be a string topic name.");
	        }

	        if (typeof func !== 'function') {
	            throw new Error("Second parameter must be a function.");
	        }

	        if (typeof priority !== 'undefined') {
	            if (typeof priority !== 'number') {
	                throw new Error("Priority must be a number.");
	            } else {
	                if (priority > MAX_PRIORITY ||
	                    priority < MIN_PRIORITY) {
	                    throw new Error("Priority must be between 1-10.");
	                } else {
	                    prio = priority;
	                }
	            }
	        }

	        if (temporary === true) {
	            temp = temporary;
	        }

	        if (!topics[topic]) {
	            topics[topic] = [];
	        }

	        token = (++subUid).toString();
	        topics[topic].push({
	            token: token,
	            prio: prio,
	            func: func,
	            temp: temp
	        });

	        topics[topic].sort(function(a, b) {
	            return parseFloat(b.prio) - parseFloat(a.prio);
	        });

	        return token;
	    }

	    function publishTopic(topic, args) {
	        var subscribers, len, _args, _topic;

	        if (arguments.length === 0) {
	            throw new Error("First parameter must be a string topic name.");
	        }

	        _args = Array.prototype.slice.call(arguments);
	        _topic = _args.shift();

	        subscribers = topics[_topic];
	        len = subscribers ? subscribers.length : 0;
	        while (len--) {
	            subscribers[len].func.apply(null, _args);
	            if (subscribers[len].temp) {
	                unsubscribeFromTopic(subscribers[len].token);
	            }
	        }
	    }

	    /*
	     *
	     * Publish events of interest
	     * with a specific topic name and arguments
	     * such as the data to pass along
	     *
	     * @param {string} topic - Topic name.
	     * @param {...*} [args] - arguments.
	     *
	     * @returns {undefined}
	     */
	    this.publish = publishTopic;

	    /*
	     *
	     * Subscribe to events of interest
	     * with a specific topic name and a
	     * callback function, to be executed
	     * when the topic/event is observed.
	     * Default priority 10.
	     * Priority must be between 1-10.
	     * Functions with lower priority
	     * will be executed first.
	     *
	     * @param {string} topic - Topic name.
	     * @param {type} func - function to be executed when the topic/event is observed
	     * @param {number} [priority] - function with higher priority will be executed first
	     * @param {boolean} [temporary] - if set to true, subscriber will unsubcribe automatically after first execution.
	     *
	     * @returns {string} token - reference to subscription
	     */
	    this.subscribe = subscribeToTopic;

	    /*
	     *
	     * Unsubscribe from a specific
	     * topic, based on a tokenized reference
	     * to the subscription
	     *
	     * @param {string} token - reference to subscription
	     *
	     * @returns {false|string} - returns token if successfull,
	     * otherwise returns false.
	     */
	    this.unsubscribe = unsubscribeFromTopic;
	};

	//@{fcs-jsl-prod}
	var globalBroadcaster = new GlobalBroadcaster();
	//@{fcs-jsl-prod}

	var CONSTANTS = {
	    "WEBRTC": {
	        "PLUGIN_ID": "fcsPlugin",
	        "MEDIA_STATE": {
	            NOT_FOUND: "notfound",
	            SEND_RECEIVE: "sendrecv",
	            SEND_ONLY: "sendonly",
	            RECEIVE_ONLY: "recvonly",
	            INACTIVE: "inactive"
	        },
	        "RTC_SIGNALING_STATE": {
	            STABLE: "stable",
	            HAVE_LOCAL_OFFER: "have-local-offer",
	            HAVE_REMOTE_OFFER: "have-remote-offer",
	            HAVE_LOCAL_PRANSWER: "have-local-pranswer",
	            HAVE_REMOTE_PRANSWER: "have-remote-pranswer",
	            CLOSED: "closed"
	        },
	        "RTC_SDP_TYPE": {
	            "OFFER": "offer",
	            "ANSWER": "answer",
	            "PRANSWER": "pranswer"
	        },
	        "ERROR": {
	            "ICE_ICELITE": "ICE_ICELITE"
	        }
	    },
	    "STRING": {
	        "NEW_LINE": "\n",
	        "CARRIAGE_RETURN": "\r",
	        "VIDEO": "video",
	        "AUDIO": "audio"
	    },
	    "SDP": {
	        "A_LINE": "a=",
	        "M_LINE": "m=",
	        "CRYPTO": "crypto",
	        "FINGERPRINT": "fingerprint",
	        "ICE_UFRAG": "ice-ufrag:",
	        "ICE_PWD": "ice-pwd:",
	        "NACK": "nack",
	        "NACKPLI": "nack pli",
	        "SETUP_ACTIVE": "a=setup:active",
	        "SETUP_PASSIVE": "a=setup:passive",
	        "SETUP_ACTPASS": "a=setup:actpass"
	    },
	    "HTTP_METHOD": {
	        "GET": "GET",
	        "POST": "POST",
	        "PUT": "PUT",
	        "DELETE": "DELETE",
	        "OPTIONS": "OPTIONS"
	    },
	    "WEBSOCKET": {
	        "PROTOCOL": {
	            "SECURE": "wss",
	            "NONSECURE": "ws"
	        },
	        "DEFAULT_PORT": "8581",
	        "STATUS": {
	            "OPENED": 1,
	            "ALREADY_OPENED": 2,
	            "CREATE_ERROR": 3,
	            "CONNECTION_ERROR": 4,
	            "NOT_FOUND": 5,
	            "CONNECTION_CLOSED": 6
	        }
	    },
	    "LONG_POLLING": {
	        "STATUS": {
	            "TRIGGERED_CONNECT": 1
	        }
	    },
	    "NOTIFICATION": {
	        "STATUS": {
	            "NOT_STARTED": 3,
	            "CONFIGURATION_ERROR": 4,
	            "STOP_FOR_LP_TO_WS_UPGRADE": 5
	        }
	    },
	    "EVENT": {
	        "XHR_REQUEST_NOT_INITIALIZED": "XHR_REQUEST_NOT_INITIALIZED",
	        "DEVICE_SUBSCRIPTION_STARTED": "DEVICE_SUBSCRIPTION_STARTED",
	        "DEVICE_SUBSCRIPTION_ENDED": "DEVICE_SUBSCRIPTION_ENDED",
	        "CONNECTION_REESTABLISHED": "CONNECTION_REESTABLISHED",
	        "CONNECTION_LOST": "CONNECTION_LOST",
	        "TOKEN_AUTH_STARTED": "TOKEN_AUTH_STARTED",
	        "BASIC_AUTH_STARTED": "BASIC_AUTH_STARTED",
	        "TOKEN_NOT_FOUND": "TOKEN_NOT_FOUND",
	        "SESSION_EXPIRED": "SESSION_EXPIRED",
	        "NOTIFICATION_CHANNEL_LOST": "NOTIFICATION_CHANNEL_LOST",
	        "FCS_SETUP_COMPLETED": "FCS_SETUP_COMPLETED",
	        "WEBSOCKET_CONNECTED": "WEBSOCKET_CONNECTED",
	        "WEBSOCKET_DISCONNECTED": "WEBSOCKET_DISCONNECTED",
	        "FORCE_CONNECTIVITY_CHECK": "FORCE_CONNECTIVITY_CHECK"
	    },
	    "SUBSCRIPTION_EVENT": {
	        "TOKEN_OR_SESSION_LOSS": "TOKEN_OR_SESSION_LOSS",
	        "SUBSCRIPTION_SUCCESS": "SUBSCRIPTION_SUCCESS",
	        "EXTEND_SUCCESS": "EXTEND_SUCCESS",
	        "EXTEND_FAILURE": "EXTEND_FAILURE",
	        "REGULAR_EXTEND_PROCESSING": "REGULAR_EXTEND_PROCESSING",
	        "STOP_SUCCESS": "STOP_SUCCESS",
	        "STOP_FAILURE": "STOP_FAILURE",
	        "CONNECTION_LOSS": "CONNECTION_LOSS",
	        "SET_NOTIFICATION_ONERROR": "SET_NOTIFICATION_ONERROR",
	        "SET_NOTIFICATION_ONSUCCESS": "SET_NOTIFICATION_ONSUCCESS",
	        "TRIGGER_LONG_POLLING": "TRIGGER_LONG_POLLING",
	        "RESTART_SUBSCRIPTION_REQUEST": "RESTART_SUBSCRIPTION_REQUEST"
	    },
	    "NOTIFICATION_EVENT": {
	        "NOTIFICATION_SUCCESS": "NOTIFICATION_SUCCESS",
	        "NOTIFICATION_FAILURE": "NOTIFICATION_FAILURE"
	    },
	    "CACHE": {
	        "NOTIFYURL": "NotificationUrl",
	        "NOTIFYID": "NotificationId",
	        "SUBSCRIBEURL": "SubscriptionUrl",
	        "SUBSCRIBEEXPIRY": "SubscriptionExpiry",
	        "SUBSCRIBEEXTENDINTERVAL": "SubscriptionExtendInterval",
	        "USERNAME": "USERNAME",
	        "PASSWORD": "PASSWORD",
	        "SESSION": "SESSION"
	    },
	    "TIMEOUT": {
	        "INTERVAL_TO_PREVENT_CONFLICTS": 5000,
	        "DEFAULT_CONNECTIVITY_CHECK_INTERVAL": 10000
	    }
	};



	var JQrestfulImpl = function(_globalBroadcaster) {

	    var DEFAULT_LONGPOLLING_TOLERANCE = 30000,
	        DEFAULT_AJAX_TIMEOUT = 40000,
	        XHR_READY_STATE = {
	            REQUEST_NOT_INITIALIZED: 0,
	            REQUEST_DONE: 4
	        };

	    function getLogger() {
	        return logManager.getLogger("jQrestful");
	    }

	    function composeAjaxRequestResponseLog(context, xhr, errorThrown, data) {
	        var responseLog = context;
	        if (data) {
	            responseLog.data = data;
	        }
	        if (errorThrown) {
	            responseLog.errorThrown = errorThrown;
	        }
	        if (xhr) {
	            responseLog.status = xhr.status;
	            responseLog.statusText = xhr.statusText;
	            responseLog.responseText = xhr.responseText;
	            responseLog.readyState = xhr.readyState;
	        }
	        return responseLog;
	    }

	    function parseError(x, e) {
	        var returnResult, statusCode;
	        getLogger().error("parseError:'" + e + "' Status:'" + x.status + "' ResponseText:'" + x.responseText + "'");

	        if (x.responseText && x.responseText.search("statusCode") !== -1) {
	            if (JSON.parse(x.responseText).subscribeResponse !== undefined) {
	                statusCode = JSON.parse(x.responseText).subscribeResponse.statusCode;
	            } else if (JSON.parse(x.responseText).authorizationResponse !== undefined) {
	                statusCode = JSON.parse(x.responseText).authorizationResponse.statusCode;
	            }
	        }

	        statusCode = statusCode ? statusCode : x.status;

	        switch (statusCode) {
	            case 401:
	                returnResult = fcs.Errors.AUTH;
	                break;
	            case 403:
	                returnResult = fcs.Errors.INCORRECT_LOGIN_PASS;
	                break;
	            case 19:
	                returnResult = fcs.Errors.LOGIN_LIMIT_CLIENT;
	                break;
	            case 20:
	                returnResult = fcs.Errors.LOGIN_LIMIT_TABLET;
	                break;
	            case 44:
	                returnResult = fcs.Errors.FORCE_LOGOUT_ERROR;
	                break;
	            case 46:
	                returnResult = fcs.Errors.TOKEN_NOT_FOUND;
	                break;
	            case 47:
	                returnResult = fcs.Errors.SESSION_EXPIRED;
	                break;
	            default:
	                returnResult = fcs.Errors.NETWORK;
	        }
	        return returnResult;
	    }

	    // TODO tolga: remove parseError when all of the responseTypes are added
	    function parseErrorStatusCode(x, e, responseType) {
	        getLogger().error("parseErrorStatusCode:'" + e + "' Status:'" + x.status + "' ResponseText:'" + x.responseText + "'");

	        if (x.responseText && x.responseText.search("statusCode") !== -1 && JSON.parse(x.responseText)[responseType] !== undefined) {

	            return JSON.parse(x.responseText)[responseType].statusCode;
	        }

	        return (x.status === 401 || x.status === 403) ? x.status : 400;
	    }


	    /*
	     * @ignore
	     */
	    this.call = function(method, callParams, successHandler, errorHandler, successParser, errorParser, responseType, headers) {
	        var data,
	            timeout = DEFAULT_AJAX_TIMEOUT,
	            url = callParams.url,
	            urlWithoutRestVersion = url.split("/rest/version/")[1],
	            resourceString,
	            logger = getLogger(),
	            xhr,
	            queryString,
	            finalHeaders,
	            headerKey,
	            responseLogContext,
	            handleSuccess,
	            handleError,
	            isSuccess,
	            modValues;

	        if (callParams && callParams.data) {
	            data = callParams.data;
	        }

	        if (fcsConfig.polling) {
	            timeout = fcsConfig.polling * 1000;
	            if (fcsConfig.longpollingTolerans) {
	                timeout = timeout + fcsConfig.longpollingTolerans;
	            } else {
	                timeout = timeout + DEFAULT_LONGPOLLING_TOLERANCE;
	            }
	        }

	        // do not log isAlive requests
	        if (urlWithoutRestVersion && urlWithoutRestVersion.indexOf("isAlive") === -1) {
	            // extracting rest resource from url.
	            // ".../rest/version/<ver>/<user/anonymous>/<userName>/restResource/..."
	            resourceString = urlWithoutRestVersion.split("/")[3];
	            if (!resourceString) {
	                // rest resource string not found, get last string in the url
	                resourceString = url.substring(url.lastIndexOf("/") + 1, url.length);
	            }
	            // remove "?" if exists
	            resourceString = resourceString.split("?")[0];

	            if (data && !data.imRequest) {
	                logger.info("Send ajax request: " + resourceString, data);
	            } else {
	                logger.info("Send ajax request: " + resourceString);
	            }
	        }

	        if (method === 'GET') {
	            // Take the data parameters and append them to the URL.
	            queryString = utils.serialize(data);

	            if (queryString.length > 0) {
	                if (url.indexOf('?') === -1) {
	                    url += '?' + queryString;
	                } else {
	                    url += '&' + queryString;
	                }
	            }

	            // Remove data so that we don't add it to the body.
	            data = null;
	        }

	        xhr = new XMLHttpRequest();

	        // TODO: Kadir Goktas
	        // listeners below are functional expect for IE9.
	        // we can replace xhr.onstatechange handler
	        // accordingly, once IE9 is deprecated.

	        xhr.onload = function() {
	            handleSuccess(xhr);
	        };
	        xhr.onabort = function() {
	            logger.trace("Ajax request aborted internally. not calling failure callback");
	        };
	        xhr.onerror = function() {
	            logger.error("Ajax request error! Handle the error");
	            handleError(xhr);
	        };

	        // ajax hook to modify url and headers
	        if (fcsConfig.ajaxHook) {
	            modValues = utils.callFunctionIfExist(fcsConfig.ajaxHook, xhr, window, {
	                type: method,
	                url: url,
	                headers: headers,
	                data: data
	            });
	            if (modValues) {
	                url = modValues.url ? modValues.url : url;
	                headers = modValues.headers ? modValues.headers : headers;
	            }
	        }

	        xhr.open(method, url, fcs.isAsync());
	        if (fcs.isAsync()) {
	            xhr.withCredentials = fcsConfig.cors ? true : false;
	            xhr.timeout = timeout;
	        }

	        finalHeaders = {
	            // Old implementation used jQuery without changing content type. Doing the same here for
	            // backwards compatibility.
	            'Content-Type': 'application/x-www-form-urlencoded',

	            // JQuery always adds this header by default. Adding here for backwards compatibility.
	            'X-Requested-With': 'XMLHttpRequest'
	        };

	        finalHeaders = extend(finalHeaders, headers);

	        // Set the headers.
	        for (headerKey in finalHeaders) {
	            if (finalHeaders.hasOwnProperty(headerKey)) {
	                xhr.setRequestHeader(headerKey, finalHeaders[headerKey]);
	            }
	        }

	        if (typeof data !== "string") {
	            data = JSON.stringify(data);
	        }

	        xhr.send(data);

	        // Used for logging information,
	        responseLogContext = {
	            type: method,
	            url: url,
	            dataType: "json",
	            async: fcs.isAsync(),
	            jsonp: false,
	            crossDomain: fcsConfig.cors ? true : false,
	            timeout: timeout
	        };

	        function checkIE9HackForAbortedAjaxRequest(xhr) {
	            // IE9 hack: identifying internally aborted ajax requests.
	            try {
	                isSuccess = (xhr.status >= 200 && xhr.status < 300) || xhr.status === 304;
	            } catch (err) {
	                // when an ajax request is aborted by javascript, accessing xhr.status will throw
	                // exception. "c00c023f" is the exact code that IE9 throws.
	                // but all exceptions are considered as same.
	                if (err instanceof Error) {
	                    if (err.description === "Could not complete the operation due to error c00c023f.") {
	                        logger.trace("Ajax request aborted internally. not calling failure callback");
	                    }
	                }
	                return -1;
	            }
	            return isSuccess;
	        }

	        handleSuccess = function(xhr) {

	            if (xhr.readyState === XHR_READY_STATE.REQUEST_DONE) {

	                isSuccess = checkIE9HackForAbortedAjaxRequest(xhr);
	                if (isSuccess === -1) {
	                    return;
	                }

	                // onload hack: need to handle both success and failure in xhr load event
	                if (!isSuccess) {
	                    handleError(xhr);
	                    return;
	                }

	                var val = {};
	                try {
	                    // Make sure that the response isn't empty before parsing. Empty is considered
	                    // an empty object.
	                    if (typeof xhr.responseText === 'string' && xhr.responseText.length) {
	                        val = JSON.parse(xhr.responseText);
	                    }

	                    // do not log success response for isAlive requests
	                    if (typeof xhr.responseURL === 'string' && xhr.responseURL.indexOf("isAlive") === -1) {
	                        logger.info("ajax success: " + xhr.status + " " + xhr.statusText,
	                            composeAjaxRequestResponseLog(responseLogContext, xhr, undefined, val));
	                    }
	                } catch (e) {
	                    if (e instanceof SyntaxError) {
	                        logger.error("Failed to parse json ajax response into object:" + xhr.responseText,
	                            composeAjaxRequestResponseLog(responseLogContext, xhr, undefined, val));
	                    } else {
	                        logger.error("Unknown error:" + xhr.status + " " + xhr.statusText,
	                            composeAjaxRequestResponseLog(responseLogContext, xhr, undefined, val));
	                    }

	                    handleError(xhr);
	                    return;
	                }

	                if (successParser && typeof successParser === 'function') {
	                    val = successParser(val);
	                }
	                if (successHandler && typeof successHandler === 'function') {
	                    successHandler(val);
	                }
	            }
	        };

	        handleError = function(xhr) {
	            // TODO: Error Thrown
	            logger.error("ajax error: " + xhr.status + " " + xhr.statusText,
	                composeAjaxRequestResponseLog(responseLogContext, xhr, xhr.statusText));

	            if (xhr.status === 410) {
	                logger.error("410 Gone received");
	                utils.callFunctionIfExist(fcs.notification.onGoneReceived);
	                return;
	            }

	            if (xhr.readyState === XHR_READY_STATE.REQUEST_NOT_INITIALIZED) {
	                _globalBroadcaster.publish(CONSTANTS.EVENT.XHR_REQUEST_NOT_INITIALIZED);
	                logger.debug("Ajax request cannot be sent, this is a connection problem.");
	            }

	            if (errorHandler && typeof errorHandler === 'function') {
	                //TODO after unit tests moved to addressbook class, responseType parameter should be removed
	                if (responseType === "addressBookResponse") {
	                    errorHandler(parseErrorStatusCode(xhr, xhr.statusText, responseType));
	                } else {
	                    if (errorParser && typeof errorParser === 'function') {
	                        errorHandler(errorParser(xhr, xhr.statusText));
	                    } else {
	                        errorHandler(parseError(xhr, xhr.statusText));
	                    }
	                }
	            } else {
	                logger.trace("Error handler is not defined or not a function");
	            }
	        };

	        // This code is similar to jQuery. It is done like this because the documentations says not
	        // to use onreadystatechange if in synchronous mode.
	        if (!fcs.isAsync()) {
	            // In sync mode, just call the callback
	            handleSuccess(xhr);
	        } else if (xhr.readyState === 4) {
	            // If the request already completed, just fire the callback asynchronously
	            setTimeout(function() {
	                handleSuccess(xhr);
	            });
	        } else {
	            // sucess and fail scenarios are handled with "load" and "error" event listeners
	            // onreadystatechange is only need for IE9 hack
	            xhr.onreadystatechange = function() {
	                if (checkIE9HackForAbortedAjaxRequest(xhr) === -1) {
	                    return;
	                }
	            };
	        }

	        return xhr;
	    };
	};

	//@{fcs-jsl-prod}
	var JQrestful = function(_globalBroadcaster) {
	    return new JQrestfulImpl(_globalBroadcaster || globalBroadcaster);
	};

	var jQueryAdapter = new JQrestful();
	//@{fcs-jsl-prod}



	var JqrestfullManagerImpl = function(_jQueryAdapter, _globalBroadcaster) {

	    var REQUEST_TYPE_PUT = "PUT",
	        REQUEST_TYPE_POST = "POST",
	        REQUEST_TYPE_GET = "GET",
	        REQUEST_TYPE_DELETE = "DELETE",
	        username, password, session, authname;

	    function onSubscriptionStarted(data) {
	        session = data.session;
	    }

	    // In order to delete previous session
	    function onSubscriptionEnded() {
	        session = null;
	    }

	    function onTokenAuth(data) {
	        username = data.username;
	    }

	    function onBasicAuth(data) {
	        username = data.username;
	        password = data.password;
	        authname = data.authname;
	    }

	    function manipulateHeader(header) {
	        if (!header) {
	            header = {};
	        }
	        if (!header.Accept) {
	            header.Accept = "application/json";
	        }
	        if (!header['Content-Type']) {
	            header['Content-Type'] = "application/json";
	        }

	        if (!getKandyUAT()) {
	            //Check whether auth or basic auth
	            if (session) {
	                header['x-session'] = session;
	                delete header.Authorization;
	            } else {
	                if (authname && password) {
	                    header.Authorization = "basic " + base64_encode(authname + ":" + password);
	                } else if (username && password) {
	                    header.Authorization = "basic " + base64_encode(username + ":" + password);
	                }
	                delete header['x-session'];
	            }
	        }
	        return header;
	    }

	    //TODO: requestTimeout, synchronous parameters should be refactored.
	    //TODO: Header parameter should be  the first one. This would be corrected in refactor
	    function sendRequest(method, callParams, successHandler, errorHandler, successParser, errorParser, responseType, header) {
	        var failureHandler = function(statusCode) {
	                if (statusCode === fcs.Errors.TOKEN_NOT_FOUND) {
	                    _globalBroadcaster.publish(CONSTANTS.EVENT.TOKEN_NOT_FOUND);
	                    session = null;
	                } else if (statusCode === fcs.Errors.SESSION_EXPIRED) {
	                    _globalBroadcaster.publish(CONSTANTS.EVENT.SESSION_EXPIRED);
	                    session = null;
	                }

	                if (errorHandler && typeof errorHandler === 'function') {
	                    errorHandler(statusCode);
	                }
	            },
	            kandyUAT = getKandyUAT();

	        if (kandyUAT) {
	            if (callParams.url.indexOf('?') === -1) {
	                callParams.url += '?key=' + kandyUAT;
	            } else {
	                callParams.url += '&key=' + kandyUAT;
	            }
	        }

	        return _jQueryAdapter.call(method, callParams, successHandler, failureHandler, successParser, errorParser, responseType, header);
	    }

	    function sendPostRequestTokenAuth(callParams, successHandler, errorHandler, successParser, errorParser, responseType, header, token) {
	        if (!header) {
	            header = {};
	        }
	        if (!header.Accept) {
	            header.Accept = "application/json";
	        }
	        if (!header['Content-Type']) {
	            header['Content-Type'] = "application/json";
	        }
	        //Check whether auth or basic auth
	        if (header['x-session']) {
	            delete header['x-session'];
	        }
	        if (header.Authorization) {
	            delete header.Authorization;
	        }
	        if (!header['x-token']) {
	            header['x-token'] = token;
	        }
	        return sendRequest(REQUEST_TYPE_POST, callParams, successHandler, errorHandler, successParser, errorParser, responseType, header);
	    }

	    this.call = function(method, callParams, successHandler, errorHandler, successParser, errorParser, responseType, header) {
	        header = manipulateHeader(header);
	        return sendRequest(method, callParams, successHandler, errorHandler, successParser, errorParser, responseType, header);
	    };

	    this.sendPostRequest = function(callParams, successHandler, errorHandler, successParser, errorParser, responseType, header, token) {
	        if (token) {
	            return sendPostRequestTokenAuth(callParams, successHandler, errorHandler, successParser, errorParser, responseType, header, token);
	        } else {
	            header = manipulateHeader(header);
	            return sendRequest(REQUEST_TYPE_POST, callParams, successHandler, errorHandler, successParser, errorParser, responseType, header);
	        }
	    };

	    this.sendGetRequest = function(callParams, successHandler, errorHandler, successParser, errorParser, responseType, header) {
	        header = manipulateHeader(header);
	        return sendRequest(REQUEST_TYPE_GET, callParams, successHandler, errorHandler, successParser, errorParser, responseType, header);
	    };

	    this.sendDeleteRequest = function(callParams, successHandler, errorHandler, successParser, errorParser, responseType, header) {
	        header = manipulateHeader(header);
	        return sendRequest(REQUEST_TYPE_DELETE, callParams, successHandler, errorHandler, successParser, errorParser, responseType, header);
	    };

	    this.sendPutRequest = function(callParams, successHandler, errorHandler, successParser, errorParser, responseType, header) {
	        header = manipulateHeader(header);
	        return sendRequest(REQUEST_TYPE_PUT, callParams, successHandler, errorHandler, successParser, errorParser, responseType, header);
	    };

	    _globalBroadcaster.subscribe(CONSTANTS.EVENT.TOKEN_AUTH_STARTED, onTokenAuth, 9);
	    _globalBroadcaster.subscribe(CONSTANTS.EVENT.BASIC_AUTH_STARTED, onBasicAuth, 10);
	    _globalBroadcaster.subscribe(CONSTANTS.EVENT.DEVICE_SUBSCRIPTION_STARTED, onSubscriptionStarted);
	    _globalBroadcaster.subscribe(CONSTANTS.EVENT.DEVICE_SUBSCRIPTION_ENDED, onSubscriptionEnded);

	    
	};

	//@{fcs-jsl-prod}
	var JqrestfullManager = function(_jQueryAdapter, _globalBroadcaster) {
	    return new JqrestfullManagerImpl(_jQueryAdapter || jQueryAdapter,
	        _globalBroadcaster || globalBroadcaster);
	};

	var server = new JqrestfullManager();
	//@{fcs-jsl-prod}


	var fcsConfig = {
	    polling: 30,
	    iceCandidateCollectionTimeoutInterval: 3000,
	    codecsToReplace: [{
	        name: 'VP8',
	        value: '100'
	    }],
	    pluginMode: {
	        mode: "auto"
	    }
	};

	var un = null,
	    pw = null,
	    authorizationName = null,
	    connected = true,
	    tkn = null,
	    tokenRealm = null,
	    kandyUAT = null;

	var fcs;

	function getDomain() {
	    return un.split('@')[1];
	}

	function getUser() {
	    return un;
	}

	function getAuthUser() {
	    if (authorizationName) {
	        return authorizationName;
	    } else {
	        return un;
	    }
	}

	function getUserToken() {
	    return tkn;
	}

	function getRealm() {
	    return tokenRealm;
	}

	function getKandyUAT() {
	    return kandyUAT;
	}

	function getVersion() {
	    return "4.2.0";
	}

	function isConnected() {
	    return connected;
	}

	function setConnected(connectionStatus) {
	    connected = connectionStatus === true ? true : false;
	}

	/**
	 * @name fcs
	 * @namespace
	 * @param _server
	 * @param _globalBroadcaster
	 * @param _window
	 */
	var CoreImpl = function(_server, _globalBroadcaster, _window) {

	        var dev = null,
	            pluginVer = null,
	            services = {},
	            async = true;

	        /**
	         * This function returns value of async paramater of $.ajax requests
	         *
	         * @name fcs#isAsync
	         * @function
	         * @returns {Boolean} true/false
	         * @since 3.0.0
	         *
	         * @example
	         * fcs.isAsync();
	         */
	        this.isAsync = function() {
	            return async;
	        };

	        /**
	         * This function sets async option of $.ajax() requests.
	         * If It is set to false, ajax requests will be sent synchronously
	         * otherwise ajax requests will be sent asynchronously.
	         *
	         * @name fcs#setAsync
	         * @function
	         * @param {Boolean} value
	         * @return {Boolean} true/false
	         * @since 3.0.0
	         *
	         * @example
	         * fcs.setAsync(false);
	         */
	        this.setAsync = function(value) {
	            async = value;
	        };

	        /**
	         * This function returns username of authenticated user in user@domain format.
	         *
	         * @name fcs#getUser
	         * @function
	         * @returns {string} Username of current user
	         * @since 3.0.0
	         *
	         * @example
	         * fcs.getUser();
	         */
	        this.getUser = getUser;

	        /**
	         * This function returns authorization name of authenticated user
	         *
	         * @name fcs#getAuthUser
	         * @function
	         * @returns {String} Authorization name of current user
	         * @since 3.0.0
	         *
	         * @example
	         * fcs.getAuthUser();
	         */
	        this.getAuthUser = getAuthUser;

	        /**
	         * This function returns current domain name of authenticated user
	         *
	         * @name fcs#getDomain
	         * @function
	         * @returns {string} Current domain name
	         * @since 3.0.0
	         *
	         * @example
	         * fcs.getDomain();
	         */
	        this.getDomain = getDomain;

	        /**
	         * This function returns the version of the JSL-API
	         *
	         * @name fcs#getVersion
	         * @function
	         * @returns {string} Version of the JSL-API
	         * @since 3.0.0
	         *
	         * @example
	         * fcs.getVersion();
	         */
	        this.getVersion = getVersion;

	        /**
	         * This fucntion returns current device.
	         *
	         * @name fcs#getDevice
	         * @function
	         * @returns {string} Device specified for communicating with the server
	         * @since 3.0.0
	         *
	         * @example
	         * fcs.getDevice();
	         */
	        this.getDevice = function() {
	            return dev;
	        };

	        /**
	         * This function sets the user as authentication mode and cancels device authentication (if such exists),
	         * as user and device modes are mutually exclusive.
	         * authname parameter is optional.
	         *
	         * @name fcs#setUserAuth
	         * @function
	         * @param {string} user User name to be used for communicating with the server
	         * @param {string} password Password to be used for communicating with the server
	         * @param {string} authname If provided authname is used instead of user name for authentication
	         *
	         * @since 3.0.0
	         *
	         * @example
	         * fcs.setUserAuth("Username", "Password","Authname");
	         */
	        this.setUserAuth = function(user, password, authname) {
	            un = user;
	            pw = password;
	            dev = null;
	            var data = {
	                'username': user,
	                'password': password
	            };
	            if ((typeof authname === 'string') && (authname.trim().length > 0)) {
	                data.authname = authname;
	                authorizationName = authname;
	            } else {
	                authorizationName = null;
	            }
	            _globalBroadcaster.publish(CONSTANTS.EVENT.BASIC_AUTH_STARTED, data);
	        };

	        /**
	         * This function sets the user as token mode authentication and cancels user authentication or/and device authentication (if such exists),
	         * token authentication has priority over other authentications
	         *
	         * @name fcs#setTokenAuth
	         * @function
	         * @param {string} user to be used for communicating with the server
	         * @param {string} token to be used for communicating with the server
	         *
	         * @since 3.0.0
	         *
	         * @example
	         * fcs.setTokenAuth("Username", "Token");
	         */
	        this.setTokenAuth = function(user, token) {
	            un = user;
	            tkn = token;
	            _globalBroadcaster.publish(CONSTANTS.EVENT.TOKEN_AUTH_STARTED, {
	                'username': user,
	                'token': token
	            });
	        };

	        /**
	         * This function sets the device as authentication mode and cancels user authentication (if such exists),
	         * as user and device modes are mutually exclusive.
	         *
	         * @name fcs#setDeviceAuth
	         * @function
	         * @since 3.0.0
	         * @param {string} deviceID The device to be used for communicating with the server
	         *
	         * @example
	         * fcs.setDeviceAuth("DeviceID");
	         */
	        this.setDeviceAuth = function(deviceID) {
	            dev = deviceID;
	            un = null;
	        };

	        /**
	         * This function sets the authentication realm for time limited token authentication.
	         *
	         * @name fcs.setRealm
	         * @function
	         * @since 3.0.4
	         * @param {string} realm The realm for the time limited token auth
	         *
	         * @example
	         * fcs.setRealm("realmname");
	         */
	        this.setRealm = function(realm) {
	            tokenRealm = realm;
	        };

	        /**
	         * This function sets the authentication UAT for kandy Authentication.
	         *
	         * @name fcs.setKandyUAT
	         * @function
	         * @since 3.0.4
	         * @param {string} uat The User Access Token
	         *
	         * @example
	         * fcs.setKandyUAT("uat");
	         */
	        this.setKandyUAT = function(uat) {
	            kandyUAT = uat;
	        };

	        /**
	         * List of Authentication Types.
	         * @see setDeviceAuth
	         * @see setUserAuth
	         * @name fcs#AuthenticationType
	         * @property {number} USER User authentication
	         * @property {number} DEVICE Device authentication
	         * @readonly
	         */
	        this.AuthenticationType = {
	            USER: 1,
	            DEVICE: 2
	        };

	        /**
	         * List of Error Types
	         *
	         * @name fcs#Errors
	         * @property {number} NETWORK Network failures
	         * @property {number} AUTH Authentication / Authorization failures
	         * @property {number} STATE Invalid state
	         * @property {number} PRIV Privilege failures
	         * @property {number} UNKNOWN Unknown failures
	         * @property {number} LOGIN_LIMIT Login limit exceeded
	         * @property {number} INCORRECT_LOGIN_PASS Incorrect identifier
	         * @property {number} INVALID_LOGIN Invalid username
	         * @property {number} TOKEN_NOT_FOUND Token provided is not valid
	         * @property {number} SESSION_EXPIRED Session generated from token is expired
	         * @property {number} VIDEO_SESSION_NOT_AVAILABLE Video Session is not available
	         * @property {number} PENDING_REQUEST There is a pending request.
	         * @property {number} NOT_ALLOWED_SERVICE Service is not allowed.
	         * @property {number} NOT_ALLOWED_METHOD Method is not allowed.
	         * @property {number} NOT_ALLOWED_INSTANCE Instance is not allowed.
	         * @property {number} INVALID_PARAMETER Parameter is invalid.
	         * @property {number} CONNECTION_ISSUE Connection problem.
	         * @property {number} MEDIA_NOT_FOUND Media not found error.
	         * @property {number} MEDIA_NOT_ALLOWED Media not allowed error.
	         * @property {number} CALL_FAILED Call failed.
	         * @property {number} CALL_ENDED Call ended.
	         * @readonly
	         * @example
	         * if (e === fcs.Errors.AUTH)
	         * {
	         *     console.log("Authentication error occured")
	         * }
	         */
	        this.Errors = {
	            NETWORK: 1,
	            AUTH: 2,
	            STATE: 3,
	            PRIV: 4,
	            UNKNOWN: 9,
	            LOGIN_LIMIT_CLIENT: 10,
	            INCORRECT_LOGIN_PASS: 11,
	            INVALID_LOGIN: 12,
	            // smartoffice2.0 specific
	            FORCE_LOGOUT_ERROR: 13,
	            // smartoffice2.0 specific
	            LOGIN_LIMIT_TABLET: 14,
	            TOKEN_NOT_FOUND: 15,
	            SESSION_EXPIRED: 16,
	            VIDEO_SESSION_NOT_AVAILABLE: 17,
	            PENDING_REQUEST: 18,
	            NOT_ALLOWED_SERVICE: 19,
	            NOT_ALLOWED_METHOD: 20,
	            NOT_ALLOWED_INSTANCE: 21,
	            INVALID_PARAMETER: 22,
	            CONNECTION_ISSUE: 23,
	            MEDIA_NOT_FOUND: 24,
	            MEDIA_NOT_ALLOWED: 25,
	            CALL_FAILED: 26,
	            CALL_ENDED: 27
	        };

	        /**
	         * @typedef modifiedValues
	         * @type Object
	         * @property {number} url Modified url to replace xhr original url
	         * @property {object} headers Mofied headers object to replace original xhr headers
	         * @since 3.1.2
	         */

	        /**
	         * Ajax hook to intercept outgoing xhr request to modify url and headers
	         *
	         * @since 3.1.2
	         *
	         * @callback ajaxHook
	         * @param {Object} xhr XMLHttpRequest object
	         * @param {window} window window object
	         * @param {object} params object containing parameters
	         * @param {string} [params.type] The HTTP method to use, such as "GET", "POST", "PUT", "DELETE", etc
	         * @param {string} [params.url] The URL to send the request to
	         * @param {string} [params.headers] Request headers
	         * @param {string} [params.data] Request body
	         *
	         * @return {modifiedValues} object containing modified url and headers
	         *
	         */

	        /**
	         * Configures plugin mode (as 'webrtc' or 'auto') and h264 status as browser-specific with version restriction (for Chrome and Firefox) or as general default values.
	         * @typedef {Object} fcsSetupConfigParamsPluginMode

	         * @property {string} [mode="auto"] General plugin mode. 'webrtc' for default webrtc plugin, 'auto' for the usage of native chrome and firefox or the usage of default webrtc plugin for the others.
	         * @property {boolean} [h264=false] General H264 codec status.
	         * @property {object} [chrome] Chrome-specific configurations
	         * @property {string} [chrome.mode] Chrome-specific plugin mode. Overrides the general one.
	         * @property {boolean} [chrome.h264] Chrome-specific H264 codec status. Overrides the general one.
	         * @property {string} [chrome.version] Version lowerbound for Chrome configurations. Ex: "40+". Includes all the versions if not given.
	         * @property {object} [firefox] Firefox-specific configurations
	         * @property {string} [firefox.mode] Firefox-specific plugin mode. Overrides the general one.
	         * @property {boolean} [firefox.h264] Firefox-specific H264 codec status. Overrides the general one.
	         * @property {string} [firefox.version] Version lowerbound for Firefox configurations. Ex: "40+". Includes all the versions if not given.
	         *
	         * @example
	         *
	         * pluginMode: {
	         *     mode: 'webrtc',
	         *     h264: false,
	         *     chrome: {
	         *         mode: 'auto'
	         *     },firefox: {
	         *         version: '38+',
	         *         mode: 'auto'
	         *     }
	         * }
	         */

	        /**
	         * Array of servers to be tried to for notification subscription.
	         * @typedef {Object[]} fcsSetupConfigParamsServers
	         *
	         * @property {string} [protocol=window.location.protocol] HTTP protocol to be used. Ex: Http, Https
	         * @property {string} [restUrl=window.location.hostname] The URL of REST server http://ip:port.
	         * @property {string} [restPort=window.location.port] The port of REST server http://ip:port.
	         * @property {string} [websocketProtocol=ws] Determines if the websocketProtocol is secure or non-secure.
	         * @property {string} [websocketIP=window.location.hostname] Holds the websocket connection's IP adress.
	         * @property {string} [websocketPort=8581] Holds the websocket connection's port value. By defult, it is 8581.
	         *
	         * @example
	         * "servers": [{
	         *     "protocol": "https",
	         *     "restUrl": "spidrdomain.com",
	         *     "restPort": "443",
	         *     "websocketProtocol": "wss",
	         *     "websocketIP": "spidrdomain.com",
	         *     "websocketPort": "443"
	         * }],
	         */

	        /**
	         * JSL library setup
	         * @typedef {Object} fcsSetupConfigParams
	         * @property {string} [notificationType=LONGPOLLING] The notification type to be used {@link fcs.notification#NotificationTypes}
	         * @property {string} [serverRetryNumber=5] Server retry number is used when websocket failure. The current websocket will be tried for the given parameter (Between 0 and 10)
	         * @property {string} [serverRetryInterval] Server retry time interval is the current failed websocket retry interval. Default value is 5000. (Between 1000 and 10000)
	         * @property {Object[]} [servers=[]] servers config {@link fcsSetupConfigParamsServers}.
	         * @property {string} [restUrl] Deprecated. please use {@link fcsSetupConfigParamsServers}
	         * @property {string} [restPort] Deprecated. please use {@link fcsSetupConfigParamsServers}
	         * @property {string} [websocketProtocol] Deprecated. please use {@link fcsSetupConfigParamsServers}
	         * @property {string} [websocketIP] Deprecated. please use {@link fcsSetupConfigParamsServers}
	         * @property {string} [websocketPort] Deprecated. please use {@link fcsSetupConfigParamsServers}
	         * @property {string} [protocol] Deprecated. please use {@link fcsSetupConfigParamsServers}
	         * @property {string} [polling=30] Polling time value in seconds.
	         * @property {string} [expires=3600] Expire time value in miliseconds.
	         * @property {string} [codecsToRemove] Audio codesc to be removed.
	         * @property {string} [codecsToRemoveForVideo] Video codesc to be removed.
	         * @property {string} [callAuditTimer=30000] Audit time value for calls.
	         * @property {boolean} [cors=false] True if Cross-Origin Request Sharing supported.
	         * @property {string} [services="IM, Presence, Call"] Defines the enabled services for client.
	         * @property {boolean} [serverProvidedTurnCredentials=false] Provide TURN server credentials from server or not.
	         * @property {number} [iceCandidateCollectionTimeoutInterval=3000] When provided (in milliseconds), ice candidate collection assumed to be completed if at least one candidate is received within the interval.
	         * @property {number} [relayCandidateCollectionTimeoutCycle] When provided, iceCandidateCollectionTimeoutInterval is restarted until receiving first relay candidate. if the provided cycle limit is reached, ice candidate collection assumed to be completed.
	         * @property {Object} [pluginMode] plugin mode config {@link fcsSetupConfigParamsPluginMode}.
	         * @property {string} [connectivityInterval=10000] Connectivity check interval time value. If it is 0 connectivity check is diabled. Recommended to use values greater than 10000, due to performance issues.
	         * @property {string} [websocketInterval=10000] Websocket health check interval. If the websocketInterval parameter value is 0, websocket health check will be disabled.
	         * @property {string} [pluginLogLevel="2"] The log level of webrtc plugin
	         * @property {string} [videoContainer] html node in which to inject the video
	         * @property {string} [remoteVideoContainer] html node in which to inject the remote video
	         * @property {string} [localVideoContainer] html node in which to inject the preview of the user camera
	         * @property {string} [iceserver=""] ice server ip address
	         * @property {boolean} [webrtcdtls=false] webrtc dtls status
	         * @property {string} [language="en"] language setting of the plugin
	         * @property {ajaxHook} [ajaxHook] ajax hook to intercept outgoing xhr request to modify url and headers
	         */

	        /**
	         * This function is used to set up JSL library
	         *
	         * @name fcs#setup
	         * @function
	         * @param {fcsSetupConfigParams} config configuration parameters
	         * @since 3.0.0
	         * @example
	         *
	         * fcs.setup(
	         *   {
	         *       notificationType: fcs.notification.NotificationTypes.WEBSOCKET,
	         *       "servers": [{
	         *           "protocol": "https",
	         *           "restUrl": "spidrdomain.com",
	         *           "restPort": "443",
	         *           "websocketProtocol": "wss",
	         *           "websocketIP": "spidrdomain.com",
	         *           "websocketPort": "443"
	         *       }],
	         *       callAuditTimer: 30000,
	         *       clientControlled : true,
	         *       pluginMode: {
	         *          mode: 'webrtc',
	         *          h264: false,
	         *          chrome: {
	         *              mode: 'auto'
	         *          },
	         *          firefox: {
	         *              version: '38+',
	         *              mode: 'auto'
	         *          }
	         *       },
	         *       connectivityInterval: '20000',
	         *       "iceserver": [{
	         *           "url": "turns:turn1.spidrdomain.com:443?transport=tcp",
	         *           "credential": ""
	         *           }, {
	         *              "url": "turns:turn2.spidrdomain.com:443?transport=tcp",
	         *              "credential": ""
	         *       }],
	         *       webrtcdtls: true,
	         *       videoContainer: document.getElementById("defaultVideoContainer")
	         *   }
	         * );
	         *
	         * // example for multiple server
	         *
	         * fcs.setup(
	         *   {
	         *       notificationType: fcs.notification.NotificationTypes.WEBSOCKET_ONLY,
	         *       servers: [{protocol: 'http',
	         *                   restUrl: '1.1.1.1',
	         *                   restPort: '8580',
	         *                   websocketProtocol: 'ws',
	         *                   websocketIP: '1.1.1.1',
	         *                   websocketPort: '8578'},
	         *                  {protocol: 'http',
	         *                   restUrl: '1.1.1.1',
	         *                   restPort: '8580',
	         *                   websocketProtocol: 'ws',
	         *                   websocketIP: '1.1.1.1',
	         *                   websocketPort: '8581'}],
	         *      serverRetryNumber: '2',
	         *      serverRetryInterval: '3000',
	         *       pluginMode: {
	         *          mode: 'webrtc',
	         *          h264: false,
	         *          chrome: {
	         *              mode: 'auto'
	         *          },
	         *          firefox: {
	         *              version: '38+',
	         *              mode: 'auto'
	         *          }
	         *       },
	         *       connectivityInterval: '20000'
	         *       websocketInterval: '20000',
	         *       iceserver: [{"url":"stun:206.165.51.69:3478"},
	         *                     {"url":"turn:206.165.51.69:3478",
	         *                       "credential":"dummyCredential",
	         *                       "password":"dummyPwd"}]
	         *       webrtcdtls: true,
	         *       videoContainer: document.getElementById("defaultVideoContainer")
	         *   }
	         * );
	         *
	         *
	         */
	        this.setup = function(configParams) {
	            var param, i, j, codecsToReplaceDefaultFound;
	            for (param in configParams) {
	                if (configParams.hasOwnProperty(param)) {
	                    if (param === "codecsToReplace") {
	                        for (i in configParams[param]) {
	                            if (configParams[param].hasOwnProperty(i)) {
	                                codecsToReplaceDefaultFound = false;
	                                for (j in fcsConfig[param]) {
	                                    if (fcsConfig[param].hasOwnProperty(j) &&
	                                        fcsConfig[param][j].name === configParams[param][i].name) {
	                                        codecsToReplaceDefaultFound = true;
	                                        fcsConfig[param][j].value = configParams[param][i].value;
	                                    }
	                                }

	                                if (!codecsToReplaceDefaultFound) {
	                                    fcsConfig[param].push(configParams[param][i]);
	                                }
	                            }
	                        }
	                    } else {
	                        fcsConfig[param] = configParams[param];
	                    }
	                }
	            }
	            _globalBroadcaster.publish(CONSTANTS.EVENT.FCS_SETUP_COMPLETED, fcsConfig);
	        };

	        /**
	         * Plugin required event will be fired in case that plug-in not found or version is outdated
	         *
	         * @name fcs#onPluginRequired
	         * @event
	         * @param {fcs.call#MediaErrors} event media initialization error
	         * @since 3.0.0
	         * @example
	         *
	         * fcs.onPluginRequired = function(error) {
	         *     switch (error) {
	         *         case fcs.call.MediaErrors.WRONG_VERSION:
	         *             // Media Plugin Version Not Supported
	         *             // Download plugin
	         *             break;
	         *         case fcs.call.MediaErrors.NEW_VERSION_WARNING:
	         *             // New Media Version Available Wanrning
	         *             break;
	         *         case fcs.call.MediaErrors.NOT_INITIALIZED:
	         *             // Media couldn't be initialized
	         *             break;
	         *         case fcs.call.MediaErrors.NOT_FOUND:
	         *             // Plugin couldn't be found!
	         *             // Download plugin
	         *             break;
	         *     }
	         * }
	         */

	        /**
	         * This function sets version of plugin
	         *
	         * @name fcs#setPluginVersion
	         * @function
	         * @param {string} version
	         * @since 3.0.0
	         * @example
	         *
	         * fcs.setPluginVersion(version);
	         */
	        this.setPluginVersion = function(version) {
	            pluginVer = version;
	        };

	        /**
	         * This function returns version of plugin
	         *
	         * @name fcs#getPluginVersion
	         * @function
	         * @returns {String} Version of Current Plugin
	         * @since 3.0.0
	         * @example
	         *
	         * fcs.getPluginVersion();
	         */
	        this.getPluginVersion = function() {
	            return pluginVer;
	        };

	        /**
	         * This function returns assigned services of authenticated user.
	         *
	         * @name fcs#getServices
	         * @function
	         * @returns {object} The assigned services of authenticated user
	         * @since 3.0.0
	         * @example
	         *
	         * fcs.getServices();
	         */
	        this.getServices = function() {
	            return services;
	        };

	        /**
	         * This function assigns determined services to current user
	         *
	         * @name fcs#setServices
	         * @function
	         * @param {array} serviceParam The list of assigned services for the user
	         * @since 3.0.0
	         * @example
	         * fcs.setServices(["CallControl", "RestfulClient"]);
	         */
	        this.setServices = function(serviceParam) {
	            var i;
	            // for each element in serviceParam array, we create the service with value "true" in "services" object
	            if (serviceParam) {
	                for (i = 0; i < serviceParam.length; i++) {
	                    switch (serviceParam[i]) {
	                        case "CallDisplay":
	                            services.callDisplay = true;
	                            break;
	                        case "CallDisposition":
	                            services.callDisposition = true;
	                            break;
	                        case "RestfulClient":
	                            services.restfulClient = true;
	                            break;
	                        case "call":
	                            services.callControl = true;
	                            services.remoteCallControl = false;
	                            break;
	                        case "CallControl":
	                            services.callControl = true;
	                            services.remoteCallControl = false;
	                            break;
	                        case "RCC":
	                            services.callControl = false;
	                            services.remoteCallControl = true;
	                            break;
	                        case "CallMe":
	                            services.callMe = true;
	                            break;
	                        case "Directory":
	                            services.directory = true;
	                            break;
	                        case "ClickToCall":
	                            services.clickToCall = true;
	                            break;
	                        case "Presence":
	                            services.presence = true;
	                            break;
	                        case "AddressBook":
	                            services.contacts = true;
	                            break;
	                        case "CallLog":
	                            services.history = true;
	                            break;
	                        case "Custom":
	                            services.custom = true;
	                            break;
	                        case "IM":
	                            services.IM = true;
	                            break;
	                        case "Route":
	                            services.routes = true;
	                            break;
	                        case "DataChannel":
	                            services.dataChannel = true;
	                            break;
	                        default:
	                            break;
	                    }
	                }
	            }
	        };

	        this.getUserLocale = function(onSuccess, onFailure) {
	            _server.sendGetRequest({
	                    "url": getWAMUrl(1, "/localization", false)
	                },
	                function(data) {
	                    utils.callFunctionIfExist(onSuccess, data);
	                },
	                onFailure
	            );
	        };


	        /**
	         * Returns network connectivity status.
	         *
	         * @name fcs#isConnected
	         * @function
	         *
	         * @returns {Boolean}, true if connection is up otherwise false.
	         */
	        this.isConnected = isConnected;

	        

	    },
	    fcs;

	//@{fcs-jsl-prod}
	var Core = function(_server, _globalBroadcaster, _window) {
	    return new CoreImpl(_server || server,
	        _globalBroadcaster || globalBroadcaster,
	        _window || window);
	};

	fcs = new Core();

	window.fcs = fcs;
	fcs.fcsConfig = fcsConfig;
	//@{fcs-jsl-prod}



	/**
	 *
	 * LogManager provides javascript logging framework.<br />
	 *
	 * <br />The logging level strategy is as follows:<br />
	 *
	 * <br />DEBUG: Used for development and detailed debugging logs<br />
	 * INFO: Messages that provide information about the high level flow<br />
	 * through. Contain basic information about the actions being performed<br />
	 * by the user and/or the system<br />
	 * WARN: Things that shouldn't happen but don't have any immediate effect, and should be flagged<br />
	 * ERROR: Errors and Exceptions<br />
	 * FATAL: Anything that causes the system to enter into an unstable and unusable state<br />
	 *
	 *
	 * @name logManager
	 * @namespace
	 * @memberOf fcs
	 *
	 * @version 4.2.0
	 * @since 3.0.0
	 *
	 */
	var LogManagerImpl = function() {
	    var loggers = {},
	        enabled = false,
	        Level = {
	            OFF: "OFF",
	            FATAL: "FATAL",
	            ERROR: "ERROR",
	            WARN: "WARN",
	            INFO: "INFO",
	            DEBUG: "DEBUG",
	            TRACE: "TRACE",
	            ALL: "ALL"
	        },
	        _logHandler = null;

	    /**
	     *
	     * Log object.
	     *
	     * @typedef {Object} logObject
	     * @readonly
	     * @since 3.0.0
	     *
	     * @property {String}  user - the user registered to fcs library.
	     * @property {String}  timestamp - the time stamp of the log.
	     * @property {String}  logger - the name of the logger.
	     * @property {String}  level - the level of message.
	     * @property {String}  message -  the message string.
	     * @property {Object}  args - the arguments.
	     *
	     */

	    /**
	     *
	     * Log handler function.
	     *
	     * @typedef {function} logHandler
	     * @param {string} loggerName Name of the logger
	     * @param {string} level Level of message
	     * @param {logObject} logObject Log object
	     * @since 3.0.0
	     */

	    /**
	     *
	     * Initializes logging using user-provided log handler.
	     * @name fcs.logManager#initLogging
	     * @since 3.0.0
	     * @function
	     *
	     * @param {logHandler} logHandler, Function that will receive log entries
	     * @param {boolean} enableDebug, Flag defining whether debugging should be enabled or not
	     * @returns {undefined}
	     *
	     * @example
	     *
	     * function jslLogHandler(loggerName, level, logObject) {
	     *     var LOG_LEVEL = fcs.logManager.Level,
	     *         msg = logObject.timestamp + " - " + loggerName + " - " + level + " - " + logObject.message;
	     *
	     *     switch(level) {
	     *         case LOG_LEVEL.DEBUG:
	     *             window.console.debug(msg, logObject.args);
	     *             break;
	     *         case LOG_LEVEL.INFO:
	     *             window.console.info(msg, logObject.args);
	     *             break;
	     *         case LOG_LEVEL.ERROR:
	     *             window.console.error(msg, logObject.args);
	     *             break;
	     *             default:
	     *             window.console.log(msg, logObject.args);
	     *     }
	     * }
	     *
	     * fcs.logManager.initLogging(jslLogHandler, true);
	     */
	    this.initLogging = function(logHandler, enableDebug) {
	        if (!logHandler || typeof logHandler !== 'function') {
	            return false;
	        }
	        _logHandler = logHandler;
	        enabled = enableDebug === true ? true : false;
	        return true;
	    };

	    /**
	     *
	     * Enumerates all possible log levels.
	     * @name fcs.logManager#Level
	     * @enum {string}
	     * @since 3.0.0
	     * @readonly
	     * @property {string} [OFF=OFF] string representation of the Off level.
	     * @property {string} [FATAL=FATAL]  string representation of the Fatal level.
	     * @property {string} [ERROR=ERROR] string representation of the Error level.
	     * @property {string} [WARN=WARN] string representation of the Warn level.
	     * @property {string} [INFO=INFO] string representation of the Info level.
	     * @property {string} [DEBUG=DEBUG] string representation of the Debug level.
	     * @property {string} [TRACE=TRACE] string representation of the Trace level.
	     * @property {string} [ALL=ALL] string representation of the All level.
	     */
	    this.Level = Level;

	    /**
	     * Returns true or false depending on whether logging is enabled.
	     *
	     * @name fcs.logManager#isEnabled
	     * @function
	     *
	     * @returns {Boolean}
	     * @since 3.0.0
	     *
	     * @example
	     *
	     * fcs.logManager.isEnabled();
	     *
	     */
	    this.isEnabled = function() {
	        return enabled;
	    };

	    function Logger(loggerName) {
	        var name = loggerName;

	        this.getName = function() {
	            return name;
	        };

	        function log(level, message, argument) {
	            if (enabled) {
	                var logObject = {};

	                logObject.user = getUser();
	                logObject.timestamp = new Date().getTime();
	                logObject.logger = name;
	                logObject.level = level;
	                logObject.message = message;
	                logObject.args = argument;


	                if (_logHandler) {
	                    try {
	                        _logHandler(logObject.logger, logObject.level, logObject);
	                    } catch (e) {
	                        return undefined;
	                    }
	                }
	            }
	            return false;
	        }

	        this.trace = function trace(msg, argument) {
	            return log(Level.TRACE, msg, argument);
	        };

	        this.debug = function debug(msg, argument) {
	            return log(Level.DEBUG, msg, argument);
	        };

	        this.info = function info(msg, argument) {
	            return log(Level.INFO, msg, argument);
	        };

	        this.warn = function warn(msg, argument) {
	            return log(Level.WARN, msg, argument);
	        };

	        this.error = function error(msg, argument) {
	            return log(Level.ERROR, msg, argument);
	        };

	        this.fatal = function fatal(msg, argument) {
	            return log(Level.FATAL, msg, argument);
	        };
	    }

	    this.getLogger = function(loggerName) {
	        var logger, _loggerName;
	        _loggerName = loggerName ? loggerName.trim().length !== 0 ? loggerName : "Default" : "Default";
	        if (loggers[_loggerName]) {
	            logger = loggers[_loggerName];
	        } else {
	            logger = new Logger(_loggerName);
	            loggers[logger.getName()] = logger;
	        }

	        return logger;
	    };
	};
	//@{fcs-jsl-prod}
	var LogManager = function() {
	    return new LogManagerImpl();
	};

	var logManager = new LogManager();
	fcs.logManager = logManager;
	//@{fcs-jsl-prod}



	var ServiceInvokeManager = function(_logManager, _fcsConfig, _fcsErrors) {
	    var logger = _logManager.getLogger("ServiceInvokeManager"),
	        serviceName, instance = null,
	        method = null,
	        service = null,
	        invokerSuccessCallback, invokerFailureCallback;

	    this.invoke = function(serviceInstance, serviceMethodName, data, onSuccess, onFailure) {

	        invokerSuccessCallback = onSuccess;
	        invokerFailureCallback = onFailure;

	        function invokeFailureCallback(reason) {
	            logger.error("Service mapping error : " + reason);
	            if (typeof invokerFailureCallback === 'function') {
	                invokerFailureCallback({
	                    errorText: reason
	                });
	                return;
	            } else {
	                return;
	            }
	        }
	        if (typeof data !== "object" || data === null) {
	            logger.info("Data parameter not object!");
	            if (!data) {
	                data = {};
	                logger.info("Data parameter undefined.Created object for data parameter.");
	            } else {
	                logger.error("Wrong parameter for data object " + data + " .The process cannot be made");
	                invokeFailureCallback(_fcsErrors.INVALID_PARAMETER);
	                return;
	            }
	        }
	        serviceName = data.serviceName ? data.serviceName : 'spidr';

	        instance = _fcsConfig.serviceManagerMap.get(serviceInstance);
	        if (!instance) {
	            invokeFailureCallback(_fcsErrors.NOT_ALLOWED_INSTANCE);
	            return;
	        }

	        if (typeof serviceName !== "string") {
	            invokeFailureCallback(_fcsErrors.NOT_ALLOWED_SERVICE);
	            return;
	        }

	        service = instance.get(serviceName);

	        if (!service) {
	            invokeFailureCallback(_fcsErrors.NOT_ALLOWED_SERVICE);
	            return;
	        }

	        method = service[serviceMethodName];

	        if (!method) {
	            invokeFailureCallback(_fcsErrors.NOT_ALLOWED_METHOD);
	            return;
	        }

	        logger.debug("Called Invoke Method - instance : " + serviceInstance + " service : " + serviceName + " method : " + serviceMethodName);
	        return method(data, invokerSuccessCallback, invokerFailureCallback);
	    };
	};

	//@{fcs-jsl-prod}
	var serviceInvokeManager = new ServiceInvokeManager(logManager, fcsConfig, fcs.Errors);
	//@{fcs-jsl-prod}



	function getUrl() {
	    var url = "";

	    if (!fcsConfig.protocol || !fcsConfig.restUrl || !fcsConfig.restPort) {
	        return url;
	    }
	    return url + fcsConfig.protocol + "://" + fcsConfig.restUrl + ":" + fcsConfig.restPort;
	}

	function getWAMUrl(version, url, authNeeded) {
	    if (authNeeded === false) {
	        // Authentcation is not needed.
	        return getUrl() + "/rest/version/" + (version ? version : "latest") + url;
	    } else {
	        // Authentcation is needed for the rest request
	        if (fcs.notification) {
	            return getUrl() + "/rest/version/" + (version ? version : "latest") + (fcs.notification.isAnonymous() ? "/anonymous/" : "/user/") + fcs.getUser() + url;
	        } else {
	            return getUrl() + "/rest/version/" + (version ? version : "latest") + "/user/" + fcs.getUser() + url;
	        }
	    }
	}

	function getAbsolutePath() {
	    var loc = window.location,
	        pathName = loc.pathname.substring(0, loc.pathname.lastIndexOf('/') + 1);
	    return loc.href.substring(0, loc.href.length - ((loc.pathname + loc.search + loc.hash).length - pathName.length));
	}



	var CookieStorage = function() {
	    // Get an object that holds all cookies
	    var cookies = (function() {
	            var cookies = {},
	                all = document.cookie,
	                list,
	                i = 0,
	                cookie, firstEq, name, value;
	            if (all === "") {
	                return cookies;
	            }

	            // Split into individual name=value pairs
	            list = all.split("; ");

	            for (; i < list.length; i += 1) {
	                cookie = list[i];
	                // Find the first = sign
	                firstEq = cookie.indexOf("=");
	                // Get cookie name
	                name = cookie.substring(0, firstEq);
	                // Get cookie value
	                value = cookie.substring(firstEq + 1);
	                // Decode the value
	                value = decodeURIComponent(value);

	                cookies[name] = value;
	            }
	            return cookies;
	        }()),

	        // Collect the cookie names in an array
	        keys = [],
	        key;
	    for (key in cookies) {
	        if (cookies.hasOwnProperty(key)) {
	            keys.push(key);
	        }

	    }
	    // Public API
	    this.length = keys.length;


	    // Return the name of the nth cookie, or null if n is out of range
	    this.key = function(n) {
	        if (n < 0 || n >= keys.length) {
	            return null;
	        }

	        return keys[n];
	    };

	    // Return the value of the named cookie, or null.
	    this.getItem = function(name) {
	        if (arguments.length !== 1) {
	            throw new Error("Provide one argument");
	        }

	        return cookies[name] || null;
	    };

	    this.setItem = function(key, value) {
	        if (arguments.length !== 2) {
	            throw new Error("Provide two arguments");
	        }

	        if (cookies[key] === undefined) { // If no existing cookie with this name
	            keys.push(key);
	            this.length++;
	        }

	        cookies[key] = value;

	        var cookie = key + "=" + encodeURIComponent(value),
	            today = new Date(),
	            expiry = new Date(today.getTime() + 30 * 24 * 3600 * 1000);
	        // Add cookie attributes to that string

	        cookie += "; max-age=" + expiry;


	        cookie += "; path=/";

	        // Set the cookie through the document.cookie property
	        document.cookie = cookie;
	    };

	    // Remove the specified cookie
	    this.removeItem = function(key) {
	        if (arguments.length !== 1) {
	            throw new Error("Provide one argument");
	        }

	        var i = 0,
	            max;
	        if (cookies[key] === undefined) { // If it doesn't exist, do nothing
	            return;
	        }

	        // Delete the cookie from our internal set of cookies
	        delete cookies[key];

	        // And remove the key from the array of names, too.
	        for (max = keys.length; i < max; i += 1) {
	            // When we find the one we want
	            if (keys[i] === key) {
	                // Remove it from the array.
	                keys.splice(i, 1);
	                break;
	            }
	        }

	        // Decrement cookie length
	        this.length--;

	        // Actually delete the cookie
	        document.cookie = key + "=; max-age=0";
	    };

	    // Remove all cookies
	    this.clear = function() {
	        var i = 0;
	        for (; i < keys.length; i++) {
	            document.cookie = keys[i] + "=; max-age=0";
	        }

	        // Reset our internal state
	        cookies = {};
	        keys = [];
	        this.length = 0;
	    };
	};


	//@{fcs-jsl-prod}
	var cache = (typeof window.localStorage !== 'undefined') ? window.localStorage : new CookieStorage();
	window.cache = cache;
	//@{fcs-jsl-prod}



	var Utils = function(_logManager) {
	    var logger = _logManager.getLogger("utils");

	    this.getProperty = function(obj, property) {
	        return ((typeof obj[property]) === 'undefined') ? null : obj[property];
	    };

	    this.callFunctionIfExist = function() {
	        var args = Array.prototype.slice.call(arguments),
	            func;
	        func = args.shift();
	        if (typeof(func) === 'function') {
	            try {
	                return func.apply(null, args);
	            } catch (e) {
	                logger.error("Exception occured:\n" + e.stack);
	            }
	        }
	    };

	    this.compose = function(base, extendme) {
	        var prop;
	        for (prop in base) {
	            if (typeof base[prop] === 'function' && !extendme[prop]) {
	                extendme[prop] = base[prop].bind(base);
	            }
	        }
	    };

	    this.parseAddress = function(address, contact) {
	        var displayName = "";

	        if (address.indexOf("sip:", 0) > -1) {
	            address = address.replace("sip:", "");
	        }

	        if (contact === undefined || contact === null) {
	            return (address.indexOf("@", 0) > -1) ? "sip:" + address : address;
	        }
	        if (contact.firstName && contact.firstName !== "") {
	            displayName += contact.firstName;
	        }
	        if (contact.lastName && contact.lastName !== "") {
	            if (displayName === "") {
	                displayName += contact.lastName;
	            } else {
	                displayName += " " + contact.lastName;
	            }
	        }
	        if (displayName === "") {
	            return (address.indexOf("@", 0) > -1) ? "sip:" + address : address;
	        }
	        return displayName + "<" + ((address.indexOf("@", 0) > -1) ? "sip:" + address : address) + ">";
	    };

	    this.getTimestamp = function() {
	        return new Date().getTime();
	    };

	    this.Queue = function() {

	        var items;

	        this.enqueue = function(item) {
	            if (typeof(items) === 'undefined') {
	                items = [];
	            }
	            items.push(item);
	        };

	        this.dequeue = function() {
	            return items.shift();
	        };

	        this.peek = function() {
	            return items[0];
	        };

	        this.size = function() {
	            return typeof(items) === 'undefined' ? 0 : items.length;
	        };
	    };

	    this.getQueue = function() {
	        return new this.Queue();
	    };

	    this.getInteger = function(val) {
	        if (isNaN(val) || val === null || val === undefined) {
	            return 0;
	        }
	        return parseInt(val);
	    };

	    /*
	     * Similar to http://api.jquery.com/jquery.param/
	     *
	     */
	    this.serialize = function(object) {
	        var encodedString = '',
	            prop;
	        for (prop in object) {
	            if (object.hasOwnProperty(prop)) {
	                if (encodedString.length > 0) {
	                    encodedString += '&';
	                }
	                encodedString += encodeURI(prop + '=' + object[prop]);
	            }
	        }
	        return encodedString;
	    };

	};

	/* jshint ignore:start */
	/*
	 * Function.prototype.bind function not supported in phantom.js (used for unit test specs),
	 * this fix, provides support for this function.
	 *
	 * TODO: This function should be checked in new release of phantom.js and
	 * should be removed if not necessary anymore
	 */
	if (!Function.prototype.bind) {
	    Function.prototype.bind = function(oThis) {
	        if (typeof this !== 'function') {
	            // closest thing possible to the ECMAScript 5
	            // internal IsCallable function
	            throw new TypeError('Function.prototype.bind - what is trying to be bound is not callable');
	        }

	        var aArgs = Array.prototype.slice.call(arguments, 1),
	            fToBind = this,
	            FNOP = function() {},
	            FBound = function() {
	                return fToBind.apply(this instanceof FNOP && oThis ? this : oThis,
	                    aArgs.concat(Array.prototype.slice.call(arguments)));
	            };

	        FNOP.prototype = this.prototype;
	        FBound.prototype = new FNOP();

	        return FBound;
	    };
	}
	/* jshint ignore:end */

	//@{fcs-jsl-prod}
	var utils = new Utils(logManager);
	//@{fcs-jsl-prod}

	/* global cache, base64_decode, base64_encode, utils*/

	var TurnCredentialsManagerImpl = function(_cache, _utils) {
	    var self = this,
	        CREDENTIALS_CACHE_KEY = "JSL/VHVybkNyZWRlbnRpYWxz";

	    self.get = function() {
	        return JSON.parse(base64_decode(_cache.getItem(CREDENTIALS_CACHE_KEY)));
	    };

	    self.save = function(data) {
	        _cache.setItem(CREDENTIALS_CACHE_KEY, base64_encode(JSON.stringify(data)));
	        _utils.callFunctionIfExist(self.onCredentialsReceived);
	    };

	    self.remove = function() {
	        _cache.removeItem(CREDENTIALS_CACHE_KEY);
	    };
	};

	//@{fcs-jsl-prod}
	var turnCredentialsManager = new TurnCredentialsManagerImpl(cache, utils);
	//@{fcs-jsl-prod}



	var SDPParserImpl = function(_logManager, _fcsConfig, _CONSTANTS) {
	    var logger = _logManager.getLogger("sdpParser"),
	        self, mediaDescriptions, sessionDescription,
	        nl = "\n",
	        lf = "\r";

	    this.init = function(sdpData) {
	        self = this;
	        self.sessionDescription = {};
	        self.mediaDescriptions = [];
	        self.sdp = sdpData;
	        self.parseSDP();
	        self.setSessionDescriptionAttributes();
	        self.setMediaDescriptionsAttributes();
	    };

	    this.parseSDP = function() {
	        var descriptions = [],
	            index = 1,
	            mediaDescription;
	        descriptions = self.sdp.split(/^(?=m=)/m);
	        self.sessionDescription.data = descriptions[0];
	        for (index; index < descriptions.length; index++) {
	            mediaDescription = {};
	            mediaDescription.data = descriptions[index];
	            self.mediaDescriptions.push(mediaDescription);
	        }
	    };

	    this.setSessionDescriptionAttributes = function() {
	        var line = 0,
	            sessionDescriptions = self.sessionDescription.data.split(/\r\n|\r|\n/),
	            connectionData;

	        for (line; line < sessionDescriptions.length; line++) {
	            if ((sessionDescriptions[line].match("^e="))) {
	                self.sessionDescription.email = sessionDescriptions[line].split('=')[1];
	            } else if ((sessionDescriptions[line].match("^c="))) {
	                connectionData = sessionDescriptions[line].split('=')[1];
	                self.sessionDescription.connection = connectionData;
	                self.sessionDescription.ip = connectionData.split(' ')[2];
	            }
	        }
	    };

	    this.setMediaDescriptionsAttributes = function() {
	        var line = 0,
	            mediaDescriptionIndex, mediaDescriptionAttributes, mediaData, connectionData;

	        for (mediaDescriptionIndex in self.mediaDescriptions) {
	            if (self.mediaDescriptions.hasOwnProperty(mediaDescriptionIndex)) {
	                mediaDescriptionAttributes = self.mediaDescriptions[mediaDescriptionIndex].data.split(/\r\n|\r|\n/);
	                this.mediaDescriptions[mediaDescriptionIndex].direction = "sendrecv";
	                for (line in mediaDescriptionAttributes) {
	                    if (mediaDescriptionAttributes.hasOwnProperty(line)) {
	                        //direction default sendrcv setle
	                        if ((mediaDescriptionAttributes[line].match("^m="))) {
	                            mediaData = mediaDescriptionAttributes[line].split('=')[1];
	                            self.mediaDescriptions[mediaDescriptionIndex].media = mediaData;
	                            self.mediaDescriptions[mediaDescriptionIndex].port = mediaData.split(' ')[1];
	                        } else if ((mediaDescriptionAttributes[line].match("^a=sendrecv")) || (mediaDescriptionAttributes[line].match("^a=sendonly")) || (mediaDescriptionAttributes[line].match("^a=recvonly")) || (mediaDescriptionAttributes[line].match("^a=inactive"))) {
	                            self.mediaDescriptions[mediaDescriptionIndex].direction = mediaDescriptionAttributes[line].split('=')[1];
	                        } else if ((mediaDescriptionAttributes[line].match("^c="))) {
	                            connectionData = mediaDescriptionAttributes[line].split('=')[1];
	                            self.mediaDescriptions[mediaDescriptionIndex].connection = connectionData;
	                            self.mediaDescriptions[mediaDescriptionIndex].ip = connectionData.split(' ')[2];
	                        }
	                    }
	                }
	            }
	        }

	    };

	    this.isHold = function(isRemote) {
	        var isHold = false,
	            ip, media_index = 0,
	            mediaDesc, direction;
	        for (media_index in self.mediaDescriptions) {
	            if (self.mediaDescriptions.hasOwnProperty(media_index)) {
	                mediaDesc = this.mediaDescriptions[media_index];
	                if (mediaDesc.ip) {
	                    ip = mediaDesc.ip;
	                } else {
	                    if (self.sessionDescription.ip) {
	                        ip = self.sessionDescription.ip;
	                    }
	                }

	                if (mediaDesc.port !== 0) {
	                    if ((mediaDesc.direction === "inactive") ||
	                        ((mediaDesc.direction === "sendonly") && isRemote) ||
	                        ((mediaDesc.direction === "recvonly") && !isRemote) ||
	                        (ip === "0.0.0.0")) {
	                        isHold = true;
	                    } else {
	                        isHold = false;
	                        break;
	                    }
	                }
	            }
	        }
	        return isHold;
	    };

	    this.isRemoteHold = function() {
	        return this.isHold(true);
	    };

	    this.isLocalHold = function() {
	        return this.isHold(false);
	    };

	    this.getSessionDescription = function() {
	        return self.sessionDescription;
	    };

	    this.getMediaDescriptions = function() {
	        return self.mediaDescriptions;
	    };

	    this.isSdpHas = function(pSdp, type) {
	        var result = false;

	        if (pSdp === null || pSdp === undefined) {
	            return result;
	        }

	        if (pSdp.indexOf(_CONSTANTS.SDP.M_LINE + type) !== -1) {
	            result = true;
	            return result;
	        }

	        return result;
	    };

	    this.isSdpHasAudio = function(pSdp) {
	        return this.isSdpHas(pSdp, _CONSTANTS.STRING.AUDIO);
	    };

	    this.isSdpHasVideo = function(pSdp) {
	        return this.isSdpHas(pSdp, _CONSTANTS.STRING.VIDEO);
	    };

	    this.isSdpHasUfrag = function(pSdp) {
	        var result = false;

	        if (pSdp === null || pSdp === undefined) {
	            return result;
	        }

	        if (pSdp.indexOf(_CONSTANTS.SDP.A_LINE + _CONSTANTS.SDP.ICE_UFRAG) !== -1) {
	            result = true;
	            return result;
	        }

	        return result;
	    };

	    this.isSdpHasMediaWithExpectedPort = function(pSdp, type, port) {
	        if (pSdp === null || pSdp === undefined) {
	            return false;
	        }
	        return pSdp.indexOf(_CONSTANTS.SDP.M_LINE + type + " " + port) !== -1;
	    };

	    this.isSdpHasAudioWithZeroPort = function(pSdp) {
	        return this.isSdpHasMediaWithExpectedPort(pSdp, _CONSTANTS.STRING.AUDIO, 0);
	    };

	    this.isSdpHasVideoWithZeroPort = function(pSdp) {
	        return this.isSdpHasMediaWithExpectedPort(pSdp, _CONSTANTS.STRING.VIDEO, 0);
	    };

	    this.isSdpHasAudioWithOnePort = function(pSdp) {
	        return this.isSdpHasMediaWithExpectedPort(pSdp, _CONSTANTS.STRING.AUDIO, 1);
	    };

	    this.isSdpHasVideoWithOnePort = function(pSdp) {
	        return this.isSdpHasMediaWithExpectedPort(pSdp, _CONSTANTS.STRING.VIDEO, 1);
	    };

	    this.isSdpHasAudioWithNinePort = function(pSdp) {
	        return this.isSdpHasMediaWithExpectedPort(pSdp, _CONSTANTS.STRING.AUDIO, 9);
	    };

	    this.isSdpHasVideoWithNinePort = function(pSdp) {
	        return this.isSdpHasMediaWithExpectedPort(pSdp, _CONSTANTS.STRING.VIDEO, 9);
	    };

	    this.replaceZeroVideoPortWithOne = function(pSdp) {
	        if (pSdp === null || pSdp === undefined) {
	            return pSdp;
	        }
	        if (this.isSdpHasVideoWithZeroPort(pSdp)) {
	            pSdp = pSdp.replace(_CONSTANTS.SDP.M_LINE + _CONSTANTS.STRING.VIDEO + " 0 ", _CONSTANTS.SDP.M_LINE + _CONSTANTS.STRING.VIDEO + " 1 ");
	        }
	        return pSdp;
	    };

	    this.getSdpDirection = function(pSdp, type) {
	        var substr = "",
	            descriptions = [],
	            index,
	            direction = _CONSTANTS.WEBRTC.MEDIA_STATE.INACTIVE,
	            logmsg;

	        logmsg = function(state) {
	            logger.info("getSdpDirection: type= " + type + " state= " + state);
	        };

	        if (!this.isSdpHas(pSdp, type)) {
	            logmsg(direction);
	            return direction;
	        }

	        if (this.isSdpHasMediaWithExpectedPort(pSdp, type, 0)) {
	            // return if media port is 0
	            logmsg(direction);
	            return direction;
	        }

	        descriptions = pSdp.split(/^(?=m=)/m);
	        for (index = 0; index < descriptions.length; index++) {
	            substr = descriptions[index];
	            if (substr.indexOf(_CONSTANTS.SDP.M_LINE + type) !== -1) {
	                if (substr.indexOf(_CONSTANTS.SDP.A_LINE + _CONSTANTS.WEBRTC.MEDIA_STATE.SEND_RECEIVE) !== -1) {
	                    direction = _CONSTANTS.WEBRTC.MEDIA_STATE.SEND_RECEIVE;
	                    logmsg(direction);
	                    return direction;
	                } else if (substr.indexOf(_CONSTANTS.SDP.A_LINE + _CONSTANTS.WEBRTC.MEDIA_STATE.SEND_ONLY) !== -1) {
	                    direction = _CONSTANTS.WEBRTC.MEDIA_STATE.SEND_ONLY;
	                    logmsg(direction);
	                    return direction;
	                } else if (substr.indexOf(_CONSTANTS.SDP.A_LINE + _CONSTANTS.WEBRTC.MEDIA_STATE.RECEIVE_ONLY) !== -1) {
	                    direction = _CONSTANTS.WEBRTC.MEDIA_STATE.RECEIVE_ONLY;
	                    logmsg(direction);
	                    return direction;
	                } else if (substr.indexOf(_CONSTANTS.SDP.A_LINE + _CONSTANTS.WEBRTC.MEDIA_STATE.INACTIVE) !== -1) {
	                    logmsg(direction);
	                    return direction;
	                }
	                direction = _CONSTANTS.WEBRTC.MEDIA_STATE.SEND_RECEIVE;
	                return direction;
	            }
	        }
	        direction = _CONSTANTS.WEBRTC.MEDIA_STATE.NOT_FOUND;
	        logmsg(direction);
	        return direction;
	    };

	    this.getAudioSdpDirection = function(pSdp) {
	        return this.getSdpDirection(pSdp, _CONSTANTS.STRING.AUDIO);
	    };

	    this.getVideoSdpDirection = function(pSdp) {
	        return this.getSdpDirection(pSdp, _CONSTANTS.STRING.VIDEO);
	    };

	    this.isAudioSdpDirectionInactive = function(pSdp) {
	        return this.getAudioSdpDirection(pSdp) === _CONSTANTS.WEBRTC.MEDIA_STATE.INACTIVE;
	    };

	    this.isAudioSdpDirectionSendrecv = function(pSdp) {
	        return this.getAudioSdpDirection(pSdp) === _CONSTANTS.WEBRTC.MEDIA_STATE.SEND_RECEIVE;
	    };

	    this.isAudioSdpDirectionSendonly = function(pSdp) {
	        return this.getAudioSdpDirection(pSdp) === _CONSTANTS.WEBRTC.MEDIA_STATE.SEND_ONLY;
	    };

	    this.isAudioSdpDirectionRecvonly = function(pSdp) {
	        return this.getAudioSdpDirection(pSdp) === _CONSTANTS.WEBRTC.MEDIA_STATE.RECEIVE_ONLY;
	    };

	    this.isSdpContainsAudioDirection = function(pSdp) {
	        return this.getAudioSdpDirection(pSdp) !== _CONSTANTS.WEBRTC.MEDIA_STATE.NOT_FOUND;
	    };

	    this.isVideoSdpDirectionInactive = function(pSdp) {
	        return this.getVideoSdpDirection(pSdp) === _CONSTANTS.WEBRTC.MEDIA_STATE.INACTIVE;
	    };

	    this.isVideoSdpDirectionSendrecv = function(pSdp) {
	        return this.getVideoSdpDirection(pSdp) === _CONSTANTS.WEBRTC.MEDIA_STATE.SEND_RECEIVE;
	    };

	    this.isVideoSdpDirectionSendonly = function(pSdp) {
	        return this.getVideoSdpDirection(pSdp) === _CONSTANTS.WEBRTC.MEDIA_STATE.SEND_ONLY;
	    };

	    this.isVideoSdpDirectionRecvonly = function(pSdp) {
	        return this.getVideoSdpDirection(pSdp) === _CONSTANTS.WEBRTC.MEDIA_STATE.RECEIVE_ONLY;
	    };

	    this.isSdpContainsVideoDirection = function(pSdp) {
	        return this.getVideoSdpDirection(pSdp) !== _CONSTANTS.WEBRTC.MEDIA_STATE.NOT_FOUND;
	    };

	    this.changeDirection = function(pSdp, directionBefore, directionAfter, type) {
	        var sdp = "",
	            substr, descriptions = [],
	            index,
	            msg = "changeDirection: before= " + directionBefore + " after= " + directionAfter;

	        if (!type) {
	            logger.error('changeDirection: called without a type.');
	        }

	        if (directionBefore === directionAfter) {
	            //no need to change direction
	            return pSdp;
	        }

	        if (directionBefore !== this.getSdpDirection(pSdp, type)) {
	            //Ignore changing the direction if the "directionBefore" and existing directions do not match
	            return pSdp;
	        }

	        descriptions = pSdp.split(/^(?=m=)/m);
	        for (index = 0; index < descriptions.length; index++) {
	            substr = descriptions[index];
	            if (substr.indexOf(_CONSTANTS.SDP.M_LINE + type) !== -1) {
	                if (substr.indexOf(_CONSTANTS.SDP.A_LINE + directionBefore) === -1) {
	                    substr = substr.concat(_CONSTANTS.SDP.A_LINE + directionAfter + lf + nl);
	                } else {
	                    substr = substr.replace(_CONSTANTS.SDP.A_LINE + directionBefore, _CONSTANTS.SDP.A_LINE + directionAfter);
	                }
	            }
	            sdp = sdp + substr;
	        }

	        return sdp;
	    };

	    this.updateSdpDirection = function(pSdp, type, direction) {
	        logger.info("updateSdpDirection: type= " + type + " direction= " + direction);
	        var beforeDirection = this.getSdpDirection(pSdp, type);
	        return this.changeDirection(pSdp, beforeDirection, direction, type);
	    };

	    this.updateAudioSdpDirection = function(pSdp, direction) {
	        logger.info("updateSdpDirection: type= " + _CONSTANTS.STRING.AUDIO + " direction= " + direction);
	        var beforeDirection = this.getSdpDirection(pSdp, _CONSTANTS.STRING.AUDIO);
	        return this.changeDirection(pSdp, beforeDirection, direction, _CONSTANTS.STRING.AUDIO);
	    };

	    this.updateVideoSdpDirection = function(pSdp, direction) {
	        logger.info("updateSdpDirection: type= " + _CONSTANTS.STRING.VIDEO + " direction= " + direction);
	        var beforeDirection = this.getSdpDirection(pSdp, _CONSTANTS.STRING.VIDEO);
	        return this.changeDirection(pSdp, beforeDirection, direction, _CONSTANTS.STRING.VIDEO);
	    };

	    this.updateAudioSdpDirectionToInactive = function(pSdp) {
	        return this.updateAudioSdpDirection(pSdp, _CONSTANTS.WEBRTC.MEDIA_STATE.INACTIVE);
	    };

	    this.updateVideoSdpDirectionToInactive = function(pSdp) {
	        return this.updateVideoSdpDirection(pSdp, _CONSTANTS.WEBRTC.MEDIA_STATE.INACTIVE);
	    };

	    this.isSdpHasDirection = function(pSdp) {
	        var sr_indx, so_indx, ro_indx, in_indx;
	        if (pSdp === null || pSdp === undefined) {
	            return false;
	        }

	        sr_indx = pSdp.indexOf(_CONSTANTS.SDP.A_LINE + _CONSTANTS.WEBRTC.MEDIA_STATE.SEND_RECEIVE, 0);
	        so_indx = pSdp.indexOf(_CONSTANTS.SDP.A_LINE + _CONSTANTS.WEBRTC.MEDIA_STATE.SEND_ONLY, 0);
	        ro_indx = pSdp.indexOf(_CONSTANTS.SDP.A_LINE + _CONSTANTS.WEBRTC.MEDIA_STATE.RECEIVE_ONLY, 0);
	        in_indx = pSdp.indexOf(_CONSTANTS.SDP.A_LINE + _CONSTANTS.WEBRTC.MEDIA_STATE.INACTIVE, 0);
	        return (sr_indx + 1) + (so_indx + 1) + (ro_indx + 1) + (in_indx + 1) === 0 ? false : true;
	    };

	    this.isSdpEnabled = function(pSdp, type) {
	        var direction, msg = "isSdpEnabled for type " + type + ": ",
	            result = false;
	        if (pSdp === null || pSdp === undefined) {
	            return false;
	        }

	        if (this.isSdpHasMediaWithExpectedPort(pSdp, type, 0)) {
	            // return if media port is 0
	            logger.info(msg + result);
	            return result;
	        }
	        if (type === _CONSTANTS.STRING.VIDEO) {
	            direction = this.getVideoSdpDirection(pSdp);
	            if (direction === _CONSTANTS.WEBRTC.MEDIA_STATE.RECEIVE_ONLY || direction === _CONSTANTS.WEBRTC.MEDIA_STATE.INACTIVE) {
	                logger.info(msg + result);
	                return result;
	            }
	        }
	        if (this.isSdpHas(pSdp, type)) {
	            result = true;
	        }
	        logger.info(msg + result);
	        return result;
	    };

	    this.isAudioSdpEnabled = function(pSdp) {
	        return this.isSdpEnabled(pSdp, _CONSTANTS.STRING.AUDIO);
	    };

	    this.isVideoSdpEnabled = function(pSdp) {
	        return this.isSdpEnabled(pSdp, _CONSTANTS.STRING.VIDEO);
	    };

	    this.isSdpVideoReceiveEnabled = function(pSdp) {
	        var direction, msg = "isSdpVideoReceiveEnabled: ",
	            result = false;
	        if (pSdp === null || pSdp === undefined) {
	            return false;
	        }

	        if (pSdp.indexOf(_CONSTANTS.SDP.M_LINE + _CONSTANTS.STRING.VIDEO + " 0") !== -1) {
	            logger.info(msg + result);
	            return result;
	        }

	        direction = this.getVideoSdpDirection(pSdp);
	        if (direction === _CONSTANTS.WEBRTC.MEDIA_STATE.SEND_ONLY || direction === _CONSTANTS.WEBRTC.MEDIA_STATE.INACTIVE) {
	            logger.info(msg + result);
	            return result;
	        }

	        if (pSdp.indexOf(_CONSTANTS.SDP.M_LINE + _CONSTANTS.STRING.VIDEO) !== -1) {
	            result = true;
	            logger.info(msg + result);
	            return result;
	        }

	        logger.info(msg + result);
	        return result;
	    };

	    this.updateH264Level = function(pSdp) {
	        var sdp = "",
	            substr = "",
	            descriptions = [],
	            index, reg = /\r\n|\r|\n/m,
	            video_arr, i, new_substr = "",
	            elm, elm_array;

	        descriptions = pSdp.split(/^(?=m=)/m);
	        for (index = 0; index < descriptions.length; index++) {
	            substr = descriptions[index];
	            if (substr.indexOf(_CONSTANTS.SDP.M_LINE + _CONSTANTS.STRING.VIDEO) !== -1) {
	                video_arr = substr.split(reg);
	                for (i = 0; i < video_arr.length; i++) {
	                    elm = video_arr[i];
	                    if (elm && elm.indexOf("a=rtpmap:") !== -1 && elm.indexOf("H264") !== -1) {
	                        elm_array = elm.split(/\:| /m);
	                        elm = elm + _CONSTANTS.STRING.CARRIAGE_RETURN + _CONSTANTS.STRING.NEW_LINE;
	                        elm = elm + "a=fmtp:" + elm_array[1] + " profile-level-id=428014;";
	                        elm = elm + _CONSTANTS.STRING.CARRIAGE_RETURN + _CONSTANTS.STRING.NEW_LINE;
	                        // Workaround for issue 1603.
	                    } else if (elm && elm !== "") {
	                        elm = elm + _CONSTANTS.STRING.CARRIAGE_RETURN + _CONSTANTS.STRING.NEW_LINE;
	                    }
	                    new_substr = new_substr + elm;
	                }
	                substr = new_substr;
	            }
	            sdp = sdp + substr;
	        }
	        return sdp;
	    };
	    /*
	     * Firefox only accepts 42E0xx and above profile-id-level.
	     * In order not to get setRemoteDescription failure we fix the H264 level
	     * This snippet changes all H264 levels with 4280xx to 42E0xx
	     */
	    this.updateH264LevelTo42E01F = function(pSdp, isH264Enabled) {
	        if (pSdp === null || pSdp === undefined) {
	            return pSdp;
	        }
	        if (isH264Enabled) {
	            logger.debug('Updating the H264 profile-level-id to 42e01f');
	            pSdp = pSdp.replace(/profile-level-id=4280/g, 'profile-level-id=42e0');
	        }
	        return pSdp;
	    };

	    this.isSdpVideoCandidateEnabled = function(pSdp) {
	        var msg = "isSdpVideoCandidateEnabled: ",
	            result = false;

	        if (this.isSdpHasVideoWithZeroPort(pSdp) ||
	            this.isVideoSdpDirectionInactive(pSdp)) {
	            logger.info(msg + result);
	            return result;
	        } else if (!this.isSdpHasVideo(pSdp)) {
	            result = true;
	            logger.info(msg + result);
	            return true;
	        }

	        logger.info(msg + result);
	        return result;
	    };

	    this.deleteFingerprintFromSdp = function(sdp, isDtlsEnabled) {
	        if (sdp === null || sdp === undefined) {
	            return sdp;
	        }
	        if (isDtlsEnabled) {
	            return sdp;
	        }
	        while (sdp.indexOf("a=fingerprint:") !== -1) {
	            sdp = sdp.replace(/(a=fingerprint:[\w\W]*?(:\r|\n))/, "");
	        }
	        while (sdp.indexOf("a=setup:") !== -1) {
	            sdp = sdp.replace(/(a=setup:[\w\W]*?(:\r|\n))/, "");
	        }
	        return sdp;
	    };

	    this.deleteCryptoFromSdp = function(sdp, isDtlsEnabled) {
	        if (sdp === null || sdp === undefined) {
	            return;
	        }
	        if (!isDtlsEnabled) {
	            return sdp;
	        }
	        while (sdp.indexOf("a=crypto:") !== -1) {
	            sdp = sdp.replace(/(a=crypto:[\w\W]*?(:\r|\n))/, "");
	        }
	        return sdp;
	    };

	    this.deleteCryptoZeroFromSdp = function(sdp) {
	        if (sdp === null || sdp === undefined) {
	            return sdp;
	        }

	        while (sdp.indexOf("a=crypto:0") !== -1) {
	            sdp = sdp.replace(/(a=crypto:0[\w\W]*?(:\r|\n))/, "");
	        }
	        return sdp;
	    };

	    /*
	     * updateAudioCodec: removes codecs listed in config file from codec list. Required for DTMF until the bug is fixed.
	     * @param {type} pSdp
	     */
	    this.updateAudioCodec = function(pSdp) {
	        var sdp = "",
	            substr = "",
	            descriptions = [],
	            index, reg = /\r\n|\r|\n/m,
	            audio_arr, i, new_substr = "",
	            elm,
	            remcodec, regExpCodec, codecsToRemove = [],
	            j;

	        codecsToRemove = _fcsConfig.codecsToRemove;
	        if (codecsToRemove === undefined) {
	            return pSdp;
	        }

	        descriptions = pSdp.split(/^(?=m=)/m);
	        for (index = 0; index < descriptions.length; index++) {
	            substr = descriptions[index];
	            if (this.isSdpHasAudio(substr)) {
	                audio_arr = substr.split(reg);
	                for (i = 0; i < audio_arr.length; i++) {
	                    elm = audio_arr[i];
	                    for (j = 0; j < codecsToRemove.length; j++) {
	                        remcodec = codecsToRemove[j];
	                        if (elm && this.isSdpHasAudio(elm)) {
	                            // remove audio codecs given in config file from m=audio line
	                            regExpCodec = new RegExp(" " + remcodec, "g");
	                            elm = elm.replace(regExpCodec, "");
	                            if (j === 0) {
	                                elm = elm + lf + nl;
	                            }
	                        } else if (elm && elm.indexOf("a=fmtp:" + remcodec) !== -1) {
	                            elm = elm.replace(/a=fmtp[\w\W]*/, "");
	                        } else if (elm && elm.indexOf("a=rtcp-fb:" + remcodec) !== -1) {
	                            elm = elm.replace(/a=rtcp-fb[\w\W]*/, "");
	                        } else if (elm && elm.indexOf("a=rtpmap:" + remcodec) !== -1) {
	                            elm = elm.replace(/a=rtpmap[\w\W]*/, "");
	                        } else if (elm && elm !== "" && j === 0) {
	                            elm = elm + lf + nl;
	                        }
	                    }
	                    new_substr = new_substr + elm;
	                }
	                substr = new_substr;
	            }
	            sdp = sdp + substr;
	        }
	        return sdp;
	    };

	    /*
	     * updateVideoCodec: removes codecs listed in config file from codec list. Required for PSTN call until the bug is fixed.
	     * @param {type} pSdp
	     */
	    this.updateVideoCodec = function(pSdp) {
	        var sdp = "",
	            substr = "",
	            descriptions = [],
	            index, reg = /\r\n|\r|\n/m,
	            video_arr, i, new_substr = "",
	            elm,
	            remcodec, regExpCodec, codecsToRemoveForVideo = [],
	            j;

	        codecsToRemoveForVideo = _fcsConfig.codecsToRemoveForVideo;
	        if (codecsToRemoveForVideo === undefined) {
	            return pSdp;
	        }

	        descriptions = pSdp.split(/^(?=m=)/m);
	        for (index = 0; index < descriptions.length; index++) {
	            substr = descriptions[index];
	            if (this.isSdpHasVideo(substr)) {
	                video_arr = substr.split(reg);
	                for (i = 0; i < video_arr.length; i++) {
	                    elm = video_arr[i];
	                    for (j = 0; j < codecsToRemoveForVideo.length; j++) {
	                        remcodec = codecsToRemoveForVideo[j];
	                        if (elm && this.isSdpHasVideo(elm)) {
	                            // remove video codecs given in config file from m=video line
	                            regExpCodec = new RegExp(" " + remcodec, "g");
	                            elm = elm.replace(regExpCodec, "");
	                            if (j === 0) {
	                                elm = elm + lf + nl;
	                            }
	                        } else if (elm && elm.indexOf("a=fmtp:" + remcodec) !== -1) {
	                            elm = elm.replace(/a=fmtp[\w\W]*/, "");
	                        } else if (elm && elm.indexOf("a=rtcp-fb:" + remcodec) !== -1) {
	                            elm = elm.replace(/a=rtcp-fb[\w\W]*/, "");
	                        } else if (elm && elm.indexOf("a=rtpmap:" + remcodec) !== -1) {
	                            elm = elm.replace(/a=rtpmap[\w\W]*/, "");
	                        } else if (elm && elm !== "" && j === 0) {
	                            elm = elm + lf + nl;
	                        }
	                    }
	                    new_substr = new_substr + elm;
	                }
	                substr = new_substr;
	            }
	            sdp = sdp + substr;
	        }
	        return sdp;
	    };

	    /*
	     * removeAudioCodec: removes given codec type from sdp.
	     * @param {type} pSdp
	     * @param {type} codecToRemove
	     */
	    this.removeAudioCodec = function(pSdp, codecToRemove) {
	        var sdp = "",
	            substr = "",
	            descriptions = [],
	            index, reg = /\r\n|\r|\n/m,
	            audio_arr, i,
	            new_substr = "",
	            elm, elm2, regExpCodec;

	        descriptions = pSdp.split(/^(?=m=)/m);
	        for (index = 0; index < descriptions.length; index++) {
	            substr = descriptions[index];
	            if (this.isSdpHasAudio(substr)) {
	                audio_arr = substr.split(reg);
	                for (i = 0; i < audio_arr.length; i++) {
	                    elm = audio_arr[i];
	                    if (elm && this.isSdpHasAudio(elm)) {
	                        // remove given audio codec from m=audio line
	                        regExpCodec = new RegExp(" " + codecToRemove + "($| )", "m");
	                        elm2 = audio_arr[i].split(/RTP[\w\W]*/);
	                        elm = elm.replace(/(\m=audio+)\s(\w+)/, "");
	                        elm = elm.trim();
	                        elm = elm.replace(regExpCodec, " ");
	                        elm = elm2[0] + elm + lf + nl;
	                        // Workaround for issue 1603.
	                    } else if (elm && elm.indexOf("a=fmtp:" + codecToRemove) !== -1) {
	                        elm = elm.replace(/a=fmtp[\w\W]*/, "");
	                    } else if (elm && elm.indexOf("a=rtpmap:" + codecToRemove) !== -1) {
	                        elm = elm.replace(/a=rtpmap[\w\W]*/, "");
	                    } else if (elm && elm.indexOf("a=rtcp-fb:" + codecToRemove) !== -1) {
	                        elm = elm.replace(/a=rtcp-fb[\w\W]*/, "");
	                    } else if (elm && elm !== "") {
	                        elm = elm + lf + nl;
	                    }
	                    new_substr = new_substr + elm;
	                }
	                substr = new_substr;
	            }
	            sdp = sdp + substr;
	        }
	        return sdp;
	    };

	    /*
	     * removeRTXCodec: this function will remove rtx video codec
	     */
	    this.removeRTXCodec = function(pSdp) {
	        var rtxPayloadType, vp8SSRC, rtxSSRC;
	        if (pSdp === null || pSdp === undefined) {
	            return pSdp;
	        }

	        vp8SSRC = this.getVp8Ssrc(pSdp);
	        logger.debug("vp8SSRC = " + vp8SSRC);

	        rtxSSRC = this.getRtxSsrc(pSdp);
	        logger.debug("rtxSSRC = " + rtxSSRC);

	        pSdp = this.removeSsrcId(pSdp, rtxSSRC);

	        pSdp = pSdp.replace(/(a=ssrc-group:FID[\w\W]*?(:\r|\n))/g, "");

	        if (pSdp.indexOf("rtx/90000") === -1) {
	            return pSdp;
	        }

	        rtxPayloadType = this.getRTXPayloadType(pSdp);

	        logger.debug("removeRTXCodec : Removing rtx video codec " + rtxPayloadType);
	        pSdp = this.removeVideoCodec(pSdp, rtxPayloadType);

	        return pSdp;
	    };

	    this.getVp8Ssrc = function(pSdp) {
	        var splitArray, ssrcGroupArray, ssrcArray, i, reg = /\r\n|\r|\n/m;
	        if (pSdp === null || pSdp === undefined) {
	            return -1;
	        }

	        if (pSdp.indexOf("a=ssrc-group:FID ") === -1) {
	            return -1;
	        }

	        splitArray = pSdp.split("a=ssrc-group:FID ");
	        ssrcGroupArray = splitArray[1].split(reg);
	        ssrcArray = ssrcGroupArray[0].split(" ");

	        for (i = 0; i < ssrcArray.length; i++) {
	            logger.debug("ssrcArray[" + i + "] : " + ssrcArray[i]);
	        }

	        return ssrcArray[0];
	    };

	    this.getRtxSsrc = function(pSdp) {
	        var splitArray, ssrcGroupArray, ssrcArray, i, reg = /\r\n|\r|\n/m;
	        if (pSdp === null || pSdp === undefined) {
	            return -1;
	        }

	        if (pSdp.indexOf("a=ssrc-group:FID ") === -1) {
	            return -1;
	        }

	        splitArray = pSdp.split("a=ssrc-group:FID ");
	        ssrcGroupArray = splitArray[1].split(reg);
	        ssrcArray = ssrcGroupArray[0].split(" ");

	        for (i = 0; i < ssrcArray.length; i++) {
	            logger.debug("ssrcArray[" + i + "] : " + ssrcArray[i]);
	        }

	        return ssrcArray[1];
	    };

	    /*
	     * removeSsrcId: removes given SSRC ID from sdp.
	     */
	    this.removeSsrcId = function(pSdp, ssrcId) {
	        var sdp = "",
	            reg = /\r\n|\r|\n/m,
	            ssrc_arr, i, new_substr = "",
	            elm;
	        if (pSdp === null || pSdp === undefined) {
	            return pSdp;
	        }

	        ssrc_arr = pSdp.split(reg);
	        for (i = 0; i < ssrc_arr.length; i++) {
	            elm = ssrc_arr[i];
	            if (elm && elm.indexOf("a=ssrc:" + ssrcId) !== -1) {
	                elm = elm.replace(/a=ssrc:[\w\W]*/, "");
	            } else if (elm && elm !== "") {
	                elm = elm + lf + nl;
	            }
	            new_substr = new_substr + elm;
	        }
	        sdp = new_substr;

	        return sdp;
	    };

	    /*
	     * removeG722Codec: this function will remove G722 audio codec
	     * @param {type} pSdp
	     */
	    this.removeG722Codec = function(pSdp) {
	        return pSdp;
	    };

	    this.getPayloadTypeOf = function(codecString, pSdp) {
	        var rtpMapNumber, rtpMapArray, payloadTypeArray = [],
	            index;

	        if (pSdp.indexOf(codecString) === -1) {
	            return -1;
	        }
	        rtpMapArray = pSdp.match(/(a=rtpmap[\w\W]*?(:\r|\n))/g);
	        for (index = 0; index < rtpMapArray.length; index++) {
	            if (rtpMapArray[index].search(new RegExp(codecString, 'i')) !== -1) {
	                /*jslint regexp: false*/
	                rtpMapNumber = rtpMapArray[index].match(/^[^\d]*(\d+)/g);
	                rtpMapNumber = rtpMapNumber[0].split(':');
	                payloadTypeArray.push(rtpMapNumber[1]);
	                /*jslint regexp: true*/
	            }
	        }

	        logger.debug("getPayloadTypeOf(" + codecString + ") = " + payloadTypeArray[0]);

	        if (payloadTypeArray.length < 2) {
	            // if codec has just one match, then returns it as String for compatibility of old methods
	            return payloadTypeArray[0];
	        } else {
	            return payloadTypeArray;
	        }
	    };

	    /*
	     * Replaces new telephone event code in pSdp with the oldCode
	     * This is needed for WebRTC engine compatibility
	     * If an offer has a different telephone event code than what is already negotiated in that session, webrtc engine gives error
	     * Ex: Negotitation is firstly done with 126, but then the call server sends an offer with 96
	     * @param {type} pSdp
	     * @param {type} oldCode
	     * @param {type} newCode
	     */
	    this.replaceTelephoneEventPayloadType = function(pSdp, oldCode, newCode) {
	        var finalsdp, regex, matches, tempAudioLine, descriptions, index, substr, partialsdp = "",
	            number = "";

	        if (!pSdp || (pSdp.indexOf("telephone-event") === -1)) {
	            return pSdp;
	        }

	        regex = /^\.*(a=rtpmap:)(\d*)( telephone-event[ \w+ ]*[ \/+ ]*[ \w+ ]*)\r\n?/m;

	        /* example: matches= ["a=rtpmap:96 telephone-event/8000\r\n", "a=rtpmap:", "96", " telephone-event/8000"] */

	        if (oldCode === newCode) { // telephone event has not changed
	            // nothing has changed, return without any changes
	            return pSdp;
	        }

	        // telephone event has changed
	        finalsdp = pSdp;

	        // replace rtpmap
	        regex = new RegExp("^\\.*a=rtpmap:" + newCode + " telephone-event[ \\/+ ]*([ \\w+ ]*)\\r\n", "m");
	        matches = finalsdp.match(regex);
	        if (matches !== null && matches.length >= 2 && matches[1] !== "") {
	            number = matches[1];
	        } else {
	            number = 8000;
	        }
	        finalsdp = finalsdp.replace(regex, 'a=rtpmap:' + oldCode + ' telephone-event/' + number + '\r\n');

	        // replace audio line
	        regex = new RegExp("^\\.*(m=audio )[ \\w+ ]*[ \\/+ ]*[ \\w+ ]*( " + newCode + ")", "mg");
	        matches = finalsdp.match(regex);

	        if (matches !== null && matches.length >= 1 && matches[0] !== "") {
	            tempAudioLine = matches[0];
	            tempAudioLine = tempAudioLine.replace(newCode, oldCode);
	            finalsdp = finalsdp.replace(regex, tempAudioLine);
	        }

	        // replace fmtp
	        // only audio section needs to be considered, do not change video section
	        descriptions = finalsdp.split(/^(?=m=)/m);
	        for (index = 0; index < descriptions.length; index++) {
	            substr = descriptions[index];
	            if (this.isSdpHasAudio(substr)) {
	                regex = new RegExp("^\\.*a=fmtp:" + newCode, "mg");
	                substr = substr.replace(regex, 'a=fmtp:' + oldCode);
	            }
	            partialsdp = partialsdp + substr;
	        }
	        if (partialsdp !== "") {
	            finalsdp = partialsdp;
	        }
	        logger.debug("replaceTelephoneEventPayloadType: newcode " + newCode + " is replaced with oldcode " + oldCode);
	        return finalsdp;
	    };

	    /*
	     * Replaces opus codec in pSdp with the default codec number 109
	     * (TODO: get the codec from config.json)
	     * This is needed for trancoder enabled peer-to-peer scenarios
	     * transcoder only accepts opus codec that it offers
	     * @param {type} pSdp
	     */
	    this.replaceOpusCodec = function(pSdp) {
	        var regex, matches, tempAudioLine, oldCodecNumber = "",
	            defaultCodecNumber = 109,
	            descriptions, index, substr, partialsdp = "";

	        if (!pSdp || (pSdp.indexOf("opus") === -1)) {
	            return pSdp;
	        }

	        regex = /^\.*(a=rtpmap:)(\d*)( opus)/m;
	        /* example: matches= ["a=rtpmap:109 opus/48000/2\r\n", "a=rtpmap:", "111", " opus/48000/2"] */

	        matches = pSdp.match(regex);
	        if (matches !== null && matches.length >= 3 && matches[2] !== "") {
	            oldCodecNumber = matches[2];
	        } else {
	            logger.warn("sdp has opus without codec number");
	        }
	        // replace rtpmap
	        pSdp = pSdp.replace(regex, 'a=rtpmap:' + defaultCodecNumber + ' opus');

	        // replace audio line
	        regex = new RegExp("^\\.*(m=audio )[ \\w+ ]*[ \\/+ ]*[ \\w+ ]*( " + oldCodecNumber + ")", "mg");
	        matches = pSdp.match(regex);

	        if (matches !== null && matches.length >= 1 && matches[0] !== "") {
	            tempAudioLine = matches[0];
	            tempAudioLine = tempAudioLine.replace(oldCodecNumber, defaultCodecNumber);
	            pSdp = pSdp.replace(regex, tempAudioLine);
	        }

	        // replace fmtp
	        // only audio section needs to be considered, do not change video section
	        descriptions = pSdp.split(/^(?=m=)/m);
	        for (index = 0; index < descriptions.length; index++) {
	            substr = descriptions[index];
	            if (this.isSdpHasAudio(substr)) {
	                regex = new RegExp("^\\.*a=fmtp:" + oldCodecNumber, "mg");
	                substr = substr.replace(regex, 'a=fmtp:' + defaultCodecNumber);
	            }
	            partialsdp = partialsdp + substr;
	        }
	        if (partialsdp !== "") {
	            pSdp = partialsdp;
	        }
	        logger.debug("replaceOpusCodec: new codec= " + defaultCodecNumber);
	        return pSdp;
	    };

	    this.getG7228000PayloadType = function(pSdp) {
	        return this.getPayloadTypeOf("G722/8000", pSdp);
	    };

	    this.getVP8PayloadType = function(pSdp) {
	        return this.getPayloadTypeOf("VP8/90000", pSdp);
	    };

	    this.getG72216000PayloadType = function(pSdp) {
	        return this.getPayloadTypeOf("G722/16000", pSdp);
	    };

	    this.getRTXPayloadType = function(pSdp) {
	        return this.getPayloadTypeOf("rtx/90000", pSdp);
	    };

	    this.getH264PayloadType = function(pSdp) {
	        return this.getPayloadTypeOf("H264/90000", pSdp);
	    };

	    this.isSdpHasTelephoneEventWithRate = function(pSdp, rate) {
	        if (pSdp === null || pSdp === undefined) {
	            return false;
	        }
	        return pSdp.indexOf("telephone-event/" + rate) !== -1;
	    };

	    this.isSdpHasTelephoneEvent = function(pSdp) {
	        if (pSdp === null || pSdp === undefined) {
	            return false;
	        }
	        return pSdp.indexOf("telephone-event/") !== -1;
	    };

	    this.isSdpHasVP8Codec = function(pSdp) {
	        if (pSdp === null || pSdp === undefined) {
	            return false;
	        }
	        return pSdp.indexOf("VP8/90000") !== -1;
	    };

	    this.isSdpHasH264Codec = function(pSdp) {
	        if (pSdp === null || pSdp === undefined) {
	            return false;
	        }
	        return pSdp.indexOf("H264/90000") !== -1;
	    };

	    /*
	     * checkSupportedVideoCodecs
	     *
	     * checks video codec support status and remove video m-line if no supported video codec is available
	     * @param {type} pSdp
	     * @param {type} localOfferSdp
	     */
	    this.checkSupportedVideoCodecs = function(pSdp, localOfferSdp, isH264Enabled) {
	        var newSdp;
	        if (pSdp === null || pSdp === undefined) {
	            return pSdp;
	        }
	        if (this.isVideoCodecsSupported(pSdp, isH264Enabled)) {
	            return pSdp;
	        } else {
	            if (localOfferSdp) {
	                newSdp = this.removeAllVideoCodecs(pSdp);
	                newSdp = this.addVP8Codec(newSdp, localOfferSdp);
	                newSdp = this.updateSdpVideoPort(newSdp, false);
	                newSdp = this.performVideoPortZeroWorkaround(newSdp);
	            } else {
	                //******************************************************
	                //Changing video port to 0 when there is no supported
	                //video codecs is not working in webrtc library
	                //******************************************************
	                if (!this.isSdpHasVP8Codec(pSdp)) {
	                    if (pSdp.indexOf(_CONSTANTS.SDP.M_LINE + _CONSTANTS.STRING.VIDEO + " 0 ", 0) !== -1) {
	                        newSdp = this.addVP8Codec(pSdp, newSdp);
	                    } else {
	                        //this is required for PCC and meetme with video
	                        newSdp = this.updateSdpVideoPort(pSdp, false);
	                        newSdp = this.addVP8Codec(newSdp, newSdp);
	                    }
	                } else {
	                    //this is required for PCC and meetme with video
	                    newSdp = this.removeVideoDescription(pSdp);
	                }
	            }

	            return newSdp;
	        }
	    };

	    /*
	     * isVideoCodecsSupported: this function checks supported video codecs are listed in m=video line
	     * Supported video codecs are :
	     *      VP8     default supported codec
	     *      H264    if h264 is enabled with plugin
	     *      @param {type} pSdp
	     */
	    this.isVideoCodecsSupported = function(pSdp, isH264Enabled) {
	        if (this.isSdpHasVP8Codec(pSdp)) {
	            return true;
	        }
	        if (isH264Enabled) {
	            if (this.isSdpHasH264Codec(pSdp)) {
	                return true;
	            }
	        }

	        return false;
	    };

	    this.removeAllVideoCodecs = function(pSdp) {
	        var regex, matches, codecs, newSdp, index;
	        if (pSdp === null || pSdp === undefined) {
	            return pSdp;
	        }

	        regex = new RegExp("^\\.*(m=video )(\\d*)( RTP/SAVPF )([ \\w+ ]*[ \\/+ ]*[ \\w+ ])\\r\n", "m");

	        newSdp = pSdp;
	        matches = newSdp.match(regex);

	        if (matches !== null && matches.length >= 5 && matches[0] !== "") {
	            codecs = matches[4].split(" ");
	            for (index = 0; index < codecs.length; index++) {
	                logger.debug("codec[" + index + "] : " + codecs[index]);
	                newSdp = this.removeVideoCodec(newSdp, codecs[index]);
	            }
	        }

	        return newSdp;
	    };

	    /*
	     * removeVideoCodec: removes given codec type from sdp.
	     * @param {type} pSdp
	     * @param {type} codecToRemove
	     */
	    this.removeVideoCodec = function(pSdp, codecToRemove) {
	        var sdp = "",
	            substr = "",
	            descriptions = [],
	            index, reg = /\r\n|\r|\n/m,
	            video_arr, i,
	            new_substr = "",
	            elm, regExpCodec;
	        if (pSdp === null || pSdp === undefined || !codecToRemove) {
	            return pSdp;
	        }

	        descriptions = pSdp.split(/^(?=m=)/m);
	        for (index = 0; index < descriptions.length; index++) {
	            substr = descriptions[index];
	            if (this.isSdpHasVideo(substr)) {
	                video_arr = substr.split(reg);
	                for (i = 0; i < video_arr.length; i++) {
	                    elm = video_arr[i];
	                    if (elm && this.isSdpHasVideo(elm)) {
	                        // remove given video codec from m=video line
	                        regExpCodec = new RegExp(" " + codecToRemove, "g");
	                        elm = elm.replace(regExpCodec, "");
	                        elm = elm + lf + nl;
	                        // Workaround for issue 1603.
	                    } else if (elm && elm.indexOf("a=fmtp:" + codecToRemove) !== -1) {
	                        elm = elm.replace(/a=fmtp[\w\W]*/, "");
	                    } else if (elm && elm.indexOf("a=rtpmap:" + codecToRemove) !== -1) {
	                        elm = elm.replace(/a=rtpmap[\w\W]*/, "");
	                    } else if (elm && elm.indexOf("a=rtcp-fb:" + codecToRemove) !== -1) {
	                        elm = elm.replace(/a=rtcp-fb[\w\W]*/, "");
	                    } else if (elm && elm !== "") {
	                        elm = elm + lf + nl;
	                    }
	                    new_substr = new_substr + elm;
	                }
	                substr = new_substr;
	            }
	            sdp = sdp + substr;
	        }
	        return sdp;
	    };

	    /*
	     * addVP8Codec: adds missing VP8 Codec
	     * @param {type} pSdp
	     * @param {type} offerSdp
	     */
	    this.addVP8Codec = function(pSdp, offerSdp) {
	        var sdp = "",
	            substr = "",
	            descriptions = [],
	            index,
	            reg = /\r\n|\r|\n/m,
	            video_arr, i, new_substr = "",
	            vp8PayloadType, codecType, elm,
	            videoUFRAGParam, videoPWDParam, ice_ufrag, ice_pwd;

	        if (this.isSdpHasVP8Codec(pSdp)) {
	            return pSdp;
	        }

	        descriptions = pSdp.split(/^(?=m=)/m);
	        for (index = 0; index < descriptions.length; index++) {
	            substr = descriptions[index];
	            if (this.isSdpHasVideo(substr)) {
	                if (offerSdp &&
	                    this.isSdpHasVideo(offerSdp) &&
	                    this.isSdpHasVP8Codec(offerSdp)) {
	                    vp8PayloadType = this.getVP8PayloadType(offerSdp);
	                    if (substr.indexOf("a=rtpmap:" + vp8PayloadType) !== -1) {
	                        this.removeSdpLineContainingText(substr, "a=rtpmap:" + vp8PayloadType);
	                    }
	                } else {
	                    codecType = 100;
	                    while (substr.indexOf("a=rtpmap:" + codecType) !== -1) {
	                        codecType = codecType + 1;
	                    }
	                    vp8PayloadType = codecType;
	                }
	                video_arr = substr.split(reg);
	                for (i = 0; i < video_arr.length; i++) {
	                    elm = video_arr[i];
	                    if (elm && this.isSdpHasVideo(elm)) {
	                        if (elm.indexOf(vp8PayloadType) === -1) {
	                            elm = elm + " " + vp8PayloadType;
	                        }
	                        elm = elm + lf + nl + "a=rtpmap:" + vp8PayloadType + " VP8/90000" + lf + nl;
	                    } else if (elm && elm !== "") {
	                        elm = elm + lf + nl;
	                    }
	                    new_substr = new_substr + elm;
	                }
	                substr = new_substr;
	            }
	            sdp = sdp + substr;
	        }

	        videoUFRAGParam = this.checkICEParams(sdp, "video", _CONSTANTS.SDP.ICE_UFRAG);
	        if (videoUFRAGParam < 2) {
	            ice_ufrag = this.getICEParams(sdp, _CONSTANTS.SDP.ICE_UFRAG, false);
	            if (ice_ufrag) {
	                sdp = this.restoreICEParams(sdp, "video", _CONSTANTS.SDP.ICE_UFRAG, ice_ufrag);
	            }
	        }
	        videoPWDParam = this.checkICEParams(sdp, "video", _CONSTANTS.SDP.ICE_PWD);
	        if (videoPWDParam < 2) {
	            ice_pwd = this.getICEParams(sdp, _CONSTANTS.SDP.ICE_PWD, false);
	            if (ice_pwd) {
	                sdp = this.restoreICEParams(sdp, "video", _CONSTANTS.SDP.ICE_PWD, ice_pwd);
	            }
	        }

	        return sdp;
	    };

	    this.removeSdpLineContainingText = function(pSdp, containing_text) {
	        var i, splitArray;

	        if (pSdp === null || pSdp === undefined || !containing_text) {
	            return pSdp;
	        }

	        splitArray = pSdp.split(nl);
	        pSdp = splitArray[0] + nl;
	        for (i = 1; i < splitArray.length - 1; i++) {
	            if (splitArray[i].indexOf(containing_text) !== -1) {
	                logger.debug("removed line which contains " + containing_text);
	            } else {
	                pSdp += splitArray[i] + nl;
	            }
	        }
	        return pSdp;
	    };

	    this.removeVideoDescription = function(pSdp) {
	        var sdp = "",
	            substr = "",
	            descriptions = [],
	            index;
	        if (pSdp === null || pSdp === undefined) {
	            return pSdp;
	        }

	        descriptions = pSdp.split(/^(?=m=)/m);
	        for (index = 0; index < descriptions.length; index++) {
	            substr = descriptions[index];
	            if (!this.isSdpHasVideo(substr)) {
	                sdp = sdp + substr;
	            } else {
	                logger.debug("removeVideoDescription : m=video description removed");
	            }
	        }
	        return sdp;
	    };

	    /*
	     * updateSdpVideoPort
	     * @param {type} pSdp
	     * @param {type} status
	     */
	    this.updateSdpVideoPort = function(pSdp, status) {
	        var r_sdp, port_text;
	        if (pSdp === null || pSdp === undefined) {
	            return pSdp;
	        }

	        logger.debug("updateSdpVideoPort: status= " + status);

	        r_sdp = pSdp;

	        if (status) {
	            port_text = _CONSTANTS.SDP.M_LINE + _CONSTANTS.STRING.VIDEO + " 1";
	        } else {
	            port_text = _CONSTANTS.SDP.M_LINE + _CONSTANTS.STRING.VIDEO + " 0";
	            r_sdp = this.updateSdpDirection(r_sdp, _CONSTANTS.STRING.VIDEO, _CONSTANTS.WEBRTC.MEDIA_STATE.INACTIVE);
	        }

	        if (this.isSdpHasVideo(r_sdp)) {
	            r_sdp = r_sdp.replace(/m=video [0-9]+/, port_text);
	        }

	        return r_sdp;
	    };

	    /*
	     * performVideoPortZeroWorkaround - apply this when term side sends an answer with video port 0
	     * @param {type} pSdp
	     */
	    this.performVideoPortZeroWorkaround = function(pSdp) {
	        if (pSdp === null || pSdp === undefined) {
	            return pSdp;
	        }

	        if (!this.isSdpHasVideoWithZeroPort(pSdp)) {
	            return pSdp;
	        }
	        pSdp = this.addSdpMissingCryptoLine(pSdp);
	        pSdp = this.replaceZeroVideoPortWithOne(pSdp);

	        //chrome38 fix
	        pSdp = this.updateVideoSdpDirectionToInactive(pSdp);

	        return pSdp;
	    };

	    // Issue      : Meetme conference failed due to a webrtc bug
	    //              When video is sent in SDP with 0 without a=crypto line(SDES) in SDP,
	    //              hold scenario for meetme failed.
	    // Workaround : Add dummy a=crypto or a=fingerprint line to solve the issue with a workaround
	    // Note       : fingerprint(DTLS enabled) may still fails on meetme. This is known issue as below:
	    //              https://code.google.com/p/webrtc/issues/detail?id=2316
	    //              Check with Chrome 37
	    this.addSdpMissingCryptoLine = function(sdp) {
	        var mediaSplit, audioLines, cryptLine = null,
	            reg = /\r\n|\r|\n/m,
	            i;

	        // If there is no "m=video 0" line, sdp should not be modified
	        if (sdp.indexOf(_CONSTANTS.SDP.M_LINE + _CONSTANTS.STRING.VIDEO + " 0 ", 0) === -1) {
	            return sdp;
	        }

	        mediaSplit = sdp.split(_CONSTANTS.SDP.M_LINE + _CONSTANTS.STRING.VIDEO);

	        audioLines = mediaSplit[0].split(reg);
	        for (i = 0; i < audioLines.length; i++) {
	            if ((audioLines[i].indexOf(_CONSTANTS.SDP.A_LINE + _CONSTANTS.SDP.CRYPTO) !== -1) || (audioLines[i].indexOf(_CONSTANTS.SDP.A_LINE + _CONSTANTS.SDP.FINGERPRINT) !== -1)) {
	                cryptLine = audioLines[i];
	                break;
	            }
	        }

	        if (cryptLine === null) {
	            return sdp;
	        }

	        if (mediaSplit[0].indexOf(_CONSTANTS.SDP.A_LINE + _CONSTANTS.SDP.CRYPTO) !== -1) {
	            if (mediaSplit[1].indexOf(_CONSTANTS.SDP.A_LINE + _CONSTANTS.SDP.CRYPTO, 0) === -1) {
	                mediaSplit[1] += cryptLine + "\n";
	                logger.debug("addSdpMissingCryptoLine : crypto line is added : " + cryptLine);
	            }
	        } else if (mediaSplit[0].indexOf(_CONSTANTS.SDP.A_LINE + _CONSTANTS.SDP.FINGERPRINT, 0) !== -1) {
	            if (mediaSplit[1].indexOf(_CONSTANTS.SDP.A_LINE + _CONSTANTS.SDP.FINGERPRINT, 0) === -1) {
	                //DTLS is enabled, even adding fingerprint line in SDP,
	                //meetme scenario fails. This is known issue and followed
	                //by webrtc for DTLS enabled scenarios :
	                //https://code.google.com/p/webrtc/issues/detail?id=2316
	                mediaSplit[1] += cryptLine + "\na=setup:passive\n";
	                logger.debug("addSdpMissingCryptoLine : dtls lines are added : " + cryptLine + "and a=setup:passive");
	                logger.debug("dtls enabled: known issue by webrtc may be fixed! Check it");
	            }
	        }
	        sdp = mediaSplit.join(_CONSTANTS.SDP.M_LINE + _CONSTANTS.STRING.VIDEO);
	        return sdp;
	    };

	    this.checkICEParams = function(pSdp, mediaType, type) {
	        var parse1, parse2;

	        if (pSdp === null || pSdp === undefined) {
	            return 0;
	        }

	        parse1 = pSdp.split('m=video');
	        if (parse1.length < 2) {
	            return 0;
	        }

	        switch (type) {
	            case _CONSTANTS.SDP.ICE_UFRAG:
	                if (mediaType === "audio") {
	                    parse2 = parse1[0].split('a=ice-ufrag:');
	                } else {
	                    parse2 = parse1[1].split('a=ice-ufrag:');
	                }
	                break;
	            case _CONSTANTS.SDP.ICE_PWD:
	                if (mediaType === "audio") {
	                    parse2 = parse1[0].split('a=ice-pwd:');
	                } else {
	                    parse2 = parse1[1].split('a=ice-pwd:');
	                }
	                break;
	            default:
	                return 0;
	        }

	        return parse2.length;
	    };

	    this.getICEParams = function(pSdp, type, isVideo) {
	        var parse1, parse2, parse3, param;
	        if (pSdp === null || pSdp === undefined) {
	            return;
	        }

	        switch (type) {
	            case _CONSTANTS.SDP.ICE_UFRAG:
	                parse1 = pSdp.split('a=ice-ufrag:');
	                break;
	            case _CONSTANTS.SDP.ICE_PWD:
	                parse1 = pSdp.split('a=ice-pwd:');
	                break;
	            default:
	                return undefined;
	        }

	        if (isVideo) {
	            if (parse1[2] !== undefined) { /*"....a=ice-....a=ice-...."*/
	                parse2 = parse1[2];
	                parse3 = parse2.split('a=');
	                param = parse3[0];
	                return param; /*return video ice params*/
	            } else {
	                return undefined;
	            }
	        } else {
	            if (parse1[1] !== undefined) { /*"....a=ice-....a=ice-...."*/
	                parse2 = parse1[1];
	                parse3 = parse2.split('a=');
	                param = parse3[0];
	                return param;
	            } else {
	                return undefined;
	            }
	        }
	    };

	    this.restoreICEParams = function(pSdp, mediaType, type, new_value) {
	        var sdp = "",
	            substr, index, parse1;
	        if (pSdp === null || pSdp === undefined) {
	            return pSdp;
	        }

	        parse1 = pSdp.split('m=video');
	        if (parse1.length < 2) {
	            return pSdp;
	        }

	        for (index = 0; index < parse1.length; index++) {
	            substr = parse1[index];
	            if (index === 0) {
	                if (mediaType === "audio") {
	                    substr = substr + 'a=' + type + new_value;
	                }
	                sdp = sdp + substr;
	            }
	            if (index === 1) {
	                if (mediaType === "video") {
	                    substr = substr + 'a=' + type + new_value;
	                }
	                sdp = sdp + 'm=video' + substr;
	            }
	        }
	        return sdp;
	    };

	    this.updateICEParams = function(pSdp, type, new_value) {
	        var sdp = "",
	            subsdp = "",
	            substr, index, num,
	            parse1, parse2, parse3;
	        if (pSdp === null || pSdp === undefined) {
	            return pSdp;
	        }

	        switch (type) {
	            case _CONSTANTS.SDP.ICE_UFRAG:
	                parse1 = pSdp.split('a=ice-ufrag:');
	                break;
	            case _CONSTANTS.SDP.ICE_PWD:
	                parse1 = pSdp.split('a=ice-pwd:');
	                break;
	            default:
	                return pSdp;
	        }

	        for (index = 0; index < parse1.length; index++) {
	            substr = parse1[index];
	            if (index === 2) {
	                parse2 = substr.split('a=');

	                for (num = 0; num < parse2.length; num++) {
	                    parse3 = parse2[num];
	                    if (num === 0) {
	                        parse2[num] = new_value;
	                        subsdp = subsdp + parse2[num];
	                    } else {
	                        subsdp = subsdp + 'a=' + parse2[num];
	                    }
	                }
	                substr = subsdp;
	                sdp = sdp + substr;
	            } else {
	                sdp = sdp + substr + 'a=' + type;
	            }
	        }
	        return sdp;
	    };

	    this.checkIceParamsLengths = function(newSdp, oldSdp) {
	        var ice_ufrag, ice_pwd;
	        ice_ufrag = this.getICEParams(newSdp, _CONSTANTS.SDP.ICE_UFRAG, true);
	        ice_pwd = this.getICEParams(newSdp, _CONSTANTS.SDP.ICE_PWD, true);

	        if (ice_ufrag && ice_ufrag.length < 4) { /*RFC 5245 the ice-ufrag attribute can be 4 to 256 bytes long*/
	            ice_ufrag = this.getICEParams(oldSdp, _CONSTANTS.SDP.ICE_UFRAG, true);
	            if (ice_ufrag) {
	                newSdp = this.updateICEParams(newSdp, _CONSTANTS.SDP.ICE_UFRAG, ice_ufrag);
	            }
	        }

	        if (ice_pwd && ice_pwd.length < 22) { /*RFC 5245 the ice-pwd attribute can be 22 to 256 bytes long*/
	            ice_pwd = this.getICEParams(oldSdp, _CONSTANTS.SDP.ICE_PWD, true);
	            if (ice_pwd) {
	                newSdp = this.updateICEParams(newSdp, _CONSTANTS.SDP.ICE_PWD, ice_pwd);
	            }
	        }
	        return newSdp;
	    };

	    /*
	     * isSdpVideoSendEnabled
	     * @param {type} pSdp
	     */
	    this.isSdpVideoSendEnabled = function(pSdp) {
	        var direction,
	            msg = "isSdpVideoSendEnabled: ",
	            result = false;
	        if (pSdp === null || pSdp === undefined) {
	            return false;
	        }

	        if (!this.isSdpEnabled(pSdp, _CONSTANTS.STRING.VIDEO)) {
	            logger.debug(msg + result);
	            return result;
	        }

	        direction = this.getSdpDirectionLogging(pSdp, _CONSTANTS.STRING.VIDEO, false);
	        if (direction === _CONSTANTS.WEBRTC.MEDIA_STATE.SEND_RECEIVE ||
	            direction === _CONSTANTS.WEBRTC.MEDIA_STATE.SEND_ONLY) {
	            result = true;
	            logger.debug(msg + result);
	            return result;
	        }

	        logger.debug(msg + result);
	        return result;
	    };

	    this.getSdpDirectionLogging = function(pSdp, type, logging) {
	        var substr = "",
	            descriptions = [],
	            index,
	            direction = _CONSTANTS.WEBRTC.MEDIA_STATE.INACTIVE,
	            logmsg;

	        logmsg = function(state) {
	            if (logging) {
	                logger.debug("getSdpDirection: type= " + type + " state= " + state);
	            }
	        };

	        if (pSdp.indexOf(_CONSTANTS.SDP.M_LINE + type) === -1) {
	            logmsg(direction);
	            return direction;
	        }

	        if (pSdp.indexOf(_CONSTANTS.SDP.M_LINE + type + " 0") !== -1) {
	            logmsg(direction);
	            return direction;
	        }

	        descriptions = pSdp.split(/^(?=m=)/m);
	        for (index = 0; index < descriptions.length; index++) {
	            substr = descriptions[index];
	            if (substr.indexOf(_CONSTANTS.SDP.M_LINE + type) !== -1) {
	                if (substr.indexOf(_CONSTANTS.SDP.A_LINE + _CONSTANTS.WEBRTC.MEDIA_STATE.SEND_RECEIVE) !== -1) {
	                    direction = _CONSTANTS.WEBRTC.MEDIA_STATE.SEND_RECEIVE;
	                    logmsg(direction);
	                    return direction;
	                } else if (substr.indexOf(_CONSTANTS.SDP.A_LINE + _CONSTANTS.WEBRTC.MEDIA_STATE.SEND_ONLY) !== -1) {
	                    direction = _CONSTANTS.WEBRTC.MEDIA_STATE.SEND_ONLY;
	                    logmsg(direction);
	                    return direction;
	                } else if (substr.indexOf(_CONSTANTS.SDP.A_LINE + _CONSTANTS.WEBRTC.MEDIA_STATE.RECEIVE_ONLY) !== -1) {
	                    direction = _CONSTANTS.WEBRTC.MEDIA_STATE.RECEIVE_ONLY;
	                    logmsg(direction);
	                    return direction;
	                } else if (substr.indexOf(_CONSTANTS.SDP.A_LINE + _CONSTANTS.WEBRTC.MEDIA_STATE.INACTIVE) !== -1) {
	                    logmsg(direction);
	                    return direction;
	                }
	                direction = _CONSTANTS.WEBRTC.MEDIA_STATE.SEND_RECEIVE;
	                return direction;
	            }
	        }
	        direction = _CONSTANTS.WEBRTC.MEDIA_STATE.NOT_FOUND;
	        logmsg(direction);
	        return direction;
	    };

	    /*
	     * remove only video ssrc from the sdp
	     * this is a workaround to hear audio in a peer-to-peer call
	     * @param {type} pSdp
	     */
	    this.deleteInactiveVideoSsrc = function(pSdp) {
	        var videoSdp = [];

	        if (this.isSdpHas(pSdp, _CONSTANTS.STRING.VIDEO)) {
	            videoSdp = pSdp.split(_CONSTANTS.SDP.M_LINE + _CONSTANTS.STRING.VIDEO);
	            if (videoSdp[1] !== null) {
	                videoSdp[1] = this.deleteSsrcFromSdp(videoSdp[1]);
	            }
	        } else {
	            return pSdp;
	        }
	        return videoSdp[0] + _CONSTANTS.SDP.M_LINE + _CONSTANTS.STRING.VIDEO + videoSdp[1];
	    };

	    /*
	     * deleteSsrcFromSdp - delete ssrc from the sdp, use it when there is video continuity issue
	     * @param {type} sdp
	     */
	    this.deleteSsrcFromSdp = function(sdp) {
	        if (sdp === null || sdp === undefined) {
	            return sdp;
	        }
	        while (sdp.indexOf("a=ssrc") !== -1) {
	            sdp = sdp.replace(/(a=ssrc[\w\W]*?(:\r|\n))/, "");
	        }
	        return sdp;
	    };

	    this.getTcpSetupAttribute = function(sdp) {
	        var setupAttribute;
	        if (sdp === null || sdp === undefined) {
	            return;
	        }

	        if (sdp.indexOf(_CONSTANTS.SDP.SETUP_ACTIVE) !== -1) {
	            setupAttribute = _CONSTANTS.SDP.SETUP_ACTIVE;
	        } else if (sdp.indexOf(_CONSTANTS.SDP.SETUP_PASSIVE) !== -1) {
	            setupAttribute = _CONSTANTS.SDP.SETUP_PASSIVE;
	        } else if (sdp.indexOf(_CONSTANTS.SDP.SETUP_ACTPASS) !== -1) {
	            setupAttribute = _CONSTANTS.SDP.SETUP_ACTPASS;
	        }

	        return setupAttribute;
	    };

	    this.setTcpSetupAttributeTo = function(sdp, newSetupAttribute, isDtlsEnabled) {
	        if (sdp === null || sdp === undefined) {
	            return sdp;
	        }
	        if (!isDtlsEnabled) {
	            return sdp;
	        }

	        if (newSetupAttribute !== _CONSTANTS.SDP.SETUP_ACTIVE) {
	            while (sdp.indexOf(_CONSTANTS.SDP.SETUP_ACTIVE) !== -1) {
	                logger.debug("a=setup:active to " + newSetupAttribute);
	                sdp = sdp.replace(_CONSTANTS.SDP.SETUP_ACTIVE, newSetupAttribute);
	            }
	        }

	        if (newSetupAttribute !== _CONSTANTS.SDP.SETUP_PASSIVE) {
	            while (sdp.indexOf(_CONSTANTS.SDP.SETUP_PASSIVE) !== -1) {
	                logger.debug("a=setup:passive to " + newSetupAttribute);
	                sdp = sdp.replace(_CONSTANTS.SDP.SETUP_PASSIVE, newSetupAttribute);
	            }
	        }

	        if (newSetupAttribute !== _CONSTANTS.SDP.SETUP_ACTPASS) {
	            while (sdp.indexOf(_CONSTANTS.SDP.SETUP_ACTPASS) !== -1) {
	                logger.debug("a=setup:passive to " + newSetupAttribute);
	                sdp = sdp.replace(_CONSTANTS.SDP.SETUP_ACTPASS, newSetupAttribute);
	            }
	        }
	        return sdp;
	    };

	    this.setTcpSetupAttributeToActpass = function(sdp, isDtlsEnabled) {
	        return this.setTcpSetupAttributeTo(sdp, _CONSTANTS.SDP.SETUP_ACTPASS, isDtlsEnabled);
	    };

	    /*
	     *
	     * @param {type} pSdp
	     * @param {type} oSdp
	     * @returns pSdp
	     */
	    this.checkAndRestoreICEParams = function(pSdp, oSdp) {
	        var audioUFRAGParam, audioPWDParam, videoUFRAGParam, videoPWDParam, ice_ufrag, ice_pwd;

	        audioUFRAGParam = this.checkICEParams(pSdp, _CONSTANTS.STRING.AUDIO, _CONSTANTS.SDP.ICE_UFRAG);
	        if (audioUFRAGParam < 2) {
	            ice_ufrag = this.getICEParams(oSdp, _CONSTANTS.SDP.ICE_UFRAG, false);
	            if (ice_ufrag) {
	                pSdp = this.restoreICEParams(pSdp, _CONSTANTS.STRING.AUDIO, _CONSTANTS.SDP.ICE_UFRAG, ice_ufrag);
	            }
	        }
	        audioPWDParam = this.checkICEParams(pSdp, _CONSTANTS.STRING.AUDIO, _CONSTANTS.SDP.ICE_PWD);
	        if (audioPWDParam < 2) {
	            ice_pwd = this.getICEParams(oSdp, _CONSTANTS.SDP.ICE_PWD, false);
	            if (ice_pwd) {
	                pSdp = this.restoreICEParams(pSdp, _CONSTANTS.STRING.AUDIO, _CONSTANTS.SDP.ICE_PWD, ice_pwd);
	            }
	        }
	        videoUFRAGParam = this.checkICEParams(pSdp, _CONSTANTS.STRING.VIDEO, _CONSTANTS.SDP.ICE_UFRAG);
	        if (videoUFRAGParam < 2) {
	            ice_ufrag = this.getICEParams(oSdp, _CONSTANTS.SDP.ICE_UFRAG, false);
	            if (ice_ufrag) {
	                pSdp = this.restoreICEParams(pSdp, _CONSTANTS.STRING.VIDEO, _CONSTANTS.SDP.ICE_UFRAG, ice_ufrag);
	            }
	        }
	        videoPWDParam = this.checkICEParams(pSdp, _CONSTANTS.STRING.VIDEO, _CONSTANTS.SDP.ICE_PWD);
	        if (videoPWDParam < 2) {
	            ice_pwd = this.getICEParams(oSdp, _CONSTANTS.SDP.ICE_PWD, false);
	            if (ice_pwd) {
	                pSdp = this.restoreICEParams(pSdp, _CONSTANTS.STRING.VIDEO, _CONSTANTS.SDP.ICE_PWD, ice_pwd);
	            }
	        }
	        return pSdp;
	    };

	    this.incrementVersion = function(pSdp) {
	        var oLineAsArray = [],
	            newoLine = "",
	            index, version, actualoLine;
	        logger.debug("incrementVersion");

	        if (pSdp === null || pSdp === undefined) {
	            return pSdp;
	        }

	        // o=- 937770930552268055 2 IN IP4 127.0.0.1
	        // o=mozilla...THIS_IS_SDPARTA-37.0.1 4294967295 0 IN IP4 0.0.0.0
	        // get o line
	        actualoLine = pSdp.match(/(o=[\w\W]*?(:\r|\n))/);

	        if (!actualoLine) {
	            return pSdp;
	        }

	        // get o line
	        oLineAsArray = actualoLine[0].split(" ");

	        //getting version and convering it to int
	        version = +oLineAsArray[2];
	        //incrementing the version
	        version = version + 1;

	        for (index = 0; index < oLineAsArray.length; index++) {
	            if (index !== 0) {
	                // prevents adding unnecessary space before the o line
	                newoLine = newoLine + " ";
	            }
	            if (index === 2) {
	                // 2nd index is version index
	                newoLine = newoLine + version;
	            } else {
	                newoLine = newoLine + oLineAsArray[index];
	            }
	        }

	        pSdp = pSdp.replace(actualoLine[0], newoLine);

	        return pSdp;
	    };

	    /*
	     * escalateSdpDirection for type:audio or video
	     * @param {type} pSdp
	     * @param {type} type
	     */
	    this.escalateSdpDirection = function(pSdp, type) {
	        var direction = this.getSdpDirectionLogging(pSdp, type, false);
	        logger.debug("escalateSdpDirection: type= " + type + " direction= " + direction);
	        if (direction === _CONSTANTS.WEBRTC.MEDIA_STATE.RECEIVE_ONLY) {
	            return this.changeDirection(pSdp, direction, _CONSTANTS.WEBRTC.MEDIA_STATE.SEND_RECEIVE, type);
	        } else if (direction === _CONSTANTS.WEBRTC.MEDIA_STATE.INACTIVE) {
	            return this.changeDirection(pSdp, direction, _CONSTANTS.WEBRTC.MEDIA_STATE.SEND_ONLY, type);
	        }
	        return pSdp;
	    };

	    /*
	     * deescalateSdpDirection for type:audio or video
	     * @param {type} pSdp
	     * @param {type} type
	     */
	    this.deescalateSdpDirection = function(pSdp, type) {
	        var direction = this.getSdpDirectionLogging(pSdp, type, false);
	        logger.debug("deescalateSdpDirection: type= " + type + " direction= " + direction);
	        if (direction === _CONSTANTS.WEBRTC.MEDIA_STATE.SEND_RECEIVE) {
	            return this.changeDirection(pSdp, direction, _CONSTANTS.WEBRTC.MEDIA_STATE.RECEIVE_ONLY, type);
	        } else if (direction === _CONSTANTS.WEBRTC.MEDIA_STATE.SEND_ONLY) {
	            return this.changeDirection(pSdp, direction, _CONSTANTS.WEBRTC.MEDIA_STATE.INACTIVE, type);
	        }
	        return pSdp;
	    };

	    this.isIceLite = function(pSdp) {
	        if (pSdp === null || pSdp === undefined) {
	            return false;
	        }
	        if (pSdp && pSdp.indexOf("a=ice-lite") !== -1) {
	            return true;
	        }
	        return false;
	    };

	    this.getSessionIdFromSdp = function(sdp) {
	        var oLine;

	        if (!sdp) {
	            return -1;
	        }
	        oLine = sdp.match(/(o=[\w\W]*?(:\r|\n))/);

	        if (!oLine) {
	            return -1;
	        }

	        oLine = oLine[0].split(" ");

	        if (oLine[1]) {
	            logger.info("getSessionIdFromSdp = " + oLine[1]);
	            return oLine[1];
	        } else {
	            logger.warn("getSessionIdFromSdp called with wrong sdp!!");
	            return -1;
	        }
	    };

	    /*
	     * Updates the version in tosdp with the one retrieved from fromsdp with incrementing
	     */
	    this.updateVersion = function(fromSdp, toSdp) {
	        var fromOline = [],
	            toOline = [],
	            newoLine = "",
	            index, version, actualtoOline = '';

	        if (fromSdp === null || fromSdp === undefined) {
	            return toSdp;
	        }

	        logger.debug(" updateVersion called...");

	        // o=- 937770930552268055 2 IN IP4 127.0.0.1
	        // get o line
	        fromOline = fromSdp.match(/(o=[\w\W]*?(:\r|\n))/);

	        if (!fromOline) {
	            return toSdp;
	        }

	        fromOline = fromOline[0].split(" ");

	        // get o line
	        actualtoOline = toSdp.match(/(o=[\w\W]*?(:\r|\n))/);
	        toOline = actualtoOline[0].split(" ");

	        if (fromOline) {
	            version = fromOline[2];
	        } else {
	            logger.warn("updateVersion called with wrong fromSdp!!");
	            return toSdp;
	        }

	        // convert to int and increment
	        version = (+version) + 1;

	        logger.debug(" updateVersion fromVersion incremented: " + version);

	        for (index = 0; index < toOline.length; index++) {
	            if (index !== 0) {
	                // prevents adding unnecessary space before the o line
	                newoLine = newoLine + " ";
	            }
	            if (index === 2) {
	                // 2nd index is version index
	                newoLine = newoLine + version;
	            } else {
	                newoLine = newoLine + toOline[index];
	            }
	        }
	        toSdp = toSdp.replace(actualtoOline[0], newoLine);

	        return toSdp;
	    };

	    // TODO: Method below assumes to receive only one video m-line, need to correct this logic.
	    this.copyCandidatesToTheNewLocalSdp = function(oldSdp, newSdp) {
	        var oldSplitSdp = [],
	            newSplitSdp = [],
	            oldVideoSdp, newVideoSdp,
	            oldAudioSdp, newAudioSdp;

	        oldSplitSdp = oldSdp.split(_CONSTANTS.SDP.M_LINE + _CONSTANTS.STRING.VIDEO);
	        newSplitSdp = newSdp.split(_CONSTANTS.SDP.M_LINE + _CONSTANTS.STRING.VIDEO);

	        oldAudioSdp = oldSplitSdp[0];
	        oldVideoSdp = oldSplitSdp[1] !== undefined ? _CONSTANTS.SDP.M_LINE + _CONSTANTS.STRING.VIDEO + oldSplitSdp[1] : undefined;
	        newAudioSdp = newSplitSdp[0];
	        newVideoSdp = newSplitSdp[1] !== undefined ? _CONSTANTS.SDP.M_LINE + _CONSTANTS.STRING.VIDEO + newSplitSdp[1] : undefined;

	        newAudioSdp = this.copyCandidates(oldAudioSdp, newAudioSdp);

	        if (oldVideoSdp !== undefined && newVideoSdp !== undefined) {
	            newVideoSdp = this.copyCandidates(oldVideoSdp, newVideoSdp);
	        }

	        if (newVideoSdp !== undefined) {
	            return newAudioSdp + newVideoSdp;
	        } else {
	            return newAudioSdp;
	        }
	    };

	    this.copyCandidates = function(oldSdp, newSdp) {
	        var mediaLines, reg = /\r\n|\r|\n/m,
	            i, port;

	        mediaLines = oldSdp.split(reg);

	        for (i = 0; i < mediaLines.length; i++) {
	            if (mediaLines[i].indexOf("a=candidate") !== -1 && newSdp.indexOf(("a=candidate") === -1)) {
	                newSdp += mediaLines[i] + "\r\n";
	            } else if (mediaLines[i].indexOf("c=IN") !== -1 && newSdp.indexOf(("c=IN IP4 0.0.0.0") !== -1)) {
	                newSdp = newSdp.replace(/(c=[\w\W]*?(:\r|\n))/, mediaLines[i] + "\r\n");
	            } else if ((mediaLines[i].indexOf("m=audio") !== -1) &&
	                (newSdp.indexOf(_CONSTANTS.SDP.M_LINE + _CONSTANTS.STRING.AUDIO + " 1 ") !== -1 ||
	                    newSdp.indexOf(_CONSTANTS.SDP.M_LINE + _CONSTANTS.STRING.AUDIO + " 9 ") !== -1)) {
	                port = mediaLines[i].split(" ")[1];

	                newSdp = newSdp.replace(/m=audio \d/, _CONSTANTS.SDP.M_LINE + _CONSTANTS.STRING.AUDIO + " " + port);
	            } else if ((mediaLines[i].indexOf("m=video") !== -1) &&
	                (newSdp.indexOf(_CONSTANTS.SDP.M_LINE + _CONSTANTS.STRING.VIDEO + " 1 ") !== -1 ||
	                    newSdp.indexOf(_CONSTANTS.SDP.M_LINE + _CONSTANTS.STRING.VIDEO + " 9 ") !== -1)) {
	                port = mediaLines[i].split(" ")[1];

	                newSdp = newSdp.replace(/m=video \d/, _CONSTANTS.SDP.M_LINE + _CONSTANTS.STRING.VIDEO + " " + port);
	            }
	        }
	        return newSdp;
	    };

	    /*
	     * getSdpFromObject
	     * There is a webrtc bug in Plugin.
	     * sendrecv direction changed to recvonly for offer type sdps
	     * This function is the workaround solution to get the correct sdp from the object
	     * until webrtc bug in plugin is fixed.
	     */
	    this.getSdpFromObject = function(oSdp) {
	        var sdp;
	        sdp = oSdp.sdp;

	        return sdp;
	    };

	    /*
	     * deleteGoogleIceFromSdp - delete google-ice option from the sdp
	     */
	    this.deleteGoogleIceFromSdp = function(sdp) {
	        if (sdp === null || sdp === undefined) {
	            return sdp;
	        }
	        sdp = sdp.replace(/(a=ice-options:google-ice[\w\W]*?(:\r|\n))/g, "");
	        return sdp;
	    };

	    this.respondToRemoteSdpDirections = function(localSdp, remoteSdp) {
	        localSdp = this.respondToRemoteMediaSdpDirection(localSdp, remoteSdp, _CONSTANTS.STRING.AUDIO);
	        localSdp = this.respondToRemoteMediaSdpDirection(localSdp, remoteSdp, _CONSTANTS.STRING.VIDEO);

	        return localSdp;
	    };

	    this.respondToRemoteMediaSdpDirection = function(localSdp, remoteSdp, type) {
	        var remoteDirection;

	        if (this.isSdpHas(remoteSdp, type)) {
	            remoteDirection = this.getSdpDirection(remoteSdp, type);

	            if (this.hasZeroConnectionIP(remoteSdp)) {
	                if (remoteDirection === _CONSTANTS.WEBRTC.MEDIA_STATE.SEND_RECEIVE) {
	                    localSdp = this.updateSdpDirection(localSdp, type, _CONSTANTS.WEBRTC.MEDIA_STATE.SEND_ONLY);
	                } else {
	                    localSdp = this.updateSdpDirection(localSdp, type, _CONSTANTS.WEBRTC.MEDIA_STATE.INACTIVE);
	                }
	            } else {
	                if (remoteDirection === _CONSTANTS.WEBRTC.MEDIA_STATE.SEND_ONLY) {
	                    logger.debug(type + " sendonly -> recvonly");
	                    localSdp = this.updateSdpDirection(localSdp, type, _CONSTANTS.WEBRTC.MEDIA_STATE.RECEIVE_ONLY);
	                } else if (remoteDirection === _CONSTANTS.WEBRTC.MEDIA_STATE.RECEIVE_ONLY) {
	                    logger.debug(type + " recvonly -> sendonly");
	                    localSdp = this.updateSdpDirection(localSdp, type, _CONSTANTS.WEBRTC.MEDIA_STATE.SEND_ONLY);
	                } else if (remoteDirection === _CONSTANTS.WEBRTC.MEDIA_STATE.SEND_RECEIVE) {
	                    logger.debug(type + " sendrecv -> sendrecv");
	                    localSdp = this.updateSdpDirection(localSdp, type, _CONSTANTS.WEBRTC.MEDIA_STATE.SEND_RECEIVE);
	                } else if (remoteDirection === _CONSTANTS.WEBRTC.MEDIA_STATE.INACTIVE) {
	                    logger.debug(type + " inactive -> inactive");
	                    localSdp = this.updateSdpDirection(localSdp, type, _CONSTANTS.WEBRTC.MEDIA_STATE.INACTIVE);
	                }
	            }
	        }
	        return localSdp;
	    };

	    this.hasCandidates = function(sdp, relayCandidateCycle, relayCandidateConfigCycle) {
	        var audioArray, videoArray, candidateParser;

	        if (this.checkRelayCandidateCollectionTimeout(relayCandidateCycle, relayCandidateConfigCycle)) {
	            return true;
	        }
	        candidateParser = this.getCandidateType(relayCandidateCycle, relayCandidateConfigCycle);
	        if (this.isSdpHasAudio(sdp)) {
	            audioArray = sdp.split("m=audio");
	            if (audioArray[1].indexOf(candidateParser) === -1) {
	                return false;
	            } else if (this.isSdpHasVideo(sdp) && !this.isVideoSdpDirectionInactive(sdp) && !this.isVideoSdpDirectionRecvonly(sdp)) {
	                videoArray = sdp.split("m=video");
	                if (videoArray[1].indexOf(candidateParser) === -1) {
	                    return false;
	                } else {
	                    return true;
	                }
	            } else {
	                return true;
	            }
	        }
	        return false;
	    };

	    this.getCandidateType = function(relayCandidateCycle, relayCandidateConfigCycle) {
	        var candidateParser;
	        if (relayCandidateCycle) {
	            if (relayCandidateCycle <= relayCandidateConfigCycle) {
	                candidateParser = "relay";
	            } else {
	                candidateParser = "a=candidate";
	            }
	        } else {
	            candidateParser = "a=candidate";
	        }
	        return candidateParser;
	    };

	    this.checkRelayCandidateCollectionTimeout = function(relayCandidateCycle, relayCandidateConfigCycle) {
	        if (relayCandidateCycle) {
	            if (relayCandidateCycle > relayCandidateConfigCycle) {
	                return true;
	            }
	        }
	        return false;
	    };

	    // spidr sends both fingerprint and crypto at incoming call to the term side
	    // delete the unnecessary one before setting remote description
	    this.deleteFingerprintOrCrypto = function(sdp, isDtlsEnabled) {
	        if (sdp === null || sdp === undefined) {
	            return sdp;
	        }
	        if (sdp.indexOf("a=crypto:") === -1 || sdp.indexOf("a=fingerprint:") === -1) {
	            return sdp;
	        }
	        sdp = this.deleteCryptoFromSdp(sdp, isDtlsEnabled);
	        sdp = this.deleteFingerprintFromSdp(sdp, isDtlsEnabled);

	        return sdp;
	    };

	    function addRtpmapForCodec(sdp, payload, rtpmapString) {
	        var audioCodecList;
	        if (sdp === null || sdp === undefined) {
	            return;
	        }

	        audioCodecList = sdp.match(/m=audio [\w\W]*?(\r|\n)/);
	        if (!audioCodecList) {
	            return sdp;
	        }

	        audioCodecList = audioCodecList[0].split(" ");
	        // shift "m=audio" out
	        // shift audio port out
	        // shift RTP/SAVPF out
	        audioCodecList.shift();
	        audioCodecList.shift();
	        audioCodecList.shift();

	        if (audioCodecList.indexOf(payload) === -1) {
	            return sdp;
	        }

	        if (sdp.indexOf(rtpmapString) !== -1) {
	            return sdp;
	        }

	        sdp = sdp.split(_CONSTANTS.SDP.M_LINE + _CONSTANTS.STRING.VIDEO);

	        sdp[0] = sdp[0] + rtpmapString + lf + nl;

	        if (sdp[1]) {
	            sdp = sdp[0] + _CONSTANTS.SDP.M_LINE + _CONSTANTS.STRING.VIDEO + sdp[1];
	        } else {
	            sdp = sdp[0];
	        }

	        return sdp;
	    }

	    /*
	     *  This is only required for Firefox Native webrtc.
	     *  If PCMU exists in codec list but its rtpmap is missing in sdp,
	     *  firefox native webrtc does not collect ice canditates.
	     *  Scenario: C2C when FF is originating client
	     *            (Broker without Transcoder config)
	     */
	    this.addRtpmapForPCMU = function(sdp) {
	        return addRtpmapForCodec(sdp, "0", "a=rtpmap:0 PCMU/8000");
	    };

	    /*
	     *  This is only required for Firefox Native webrtc.
	     *  If PCMA exists in codec list but its rtpmap is missing in sdp,
	     *  firefox native webrtc does not collect ice canditates.
	     *  Scenario: C2C when FF is originating client
	     *            (Broker without Transcoder config)
	     */
	    this.addRtpmapForPCMA = function(sdp) {
	        return addRtpmapForCodec(sdp, "8", "a=rtpmap:8 PCMA/8000");
	    };

	    /*
	     * This is only required for Firefox Native webRTC.
	     * Firefox native adds curly brackets to msid and cname properties(maybe more)
	     * This leads to problem in multi - peer to peer configurated lab.
	     * TODO : Unit test cases should be written
	     */
	    this.deleteCurlyBracketsSDP = function(sdp) {
	        if (sdp === null || sdp === undefined) {
	            return sdp;
	        }
	        logger.debug('Deleting curly brackets from sdp');
	        sdp = sdp.replace(/(\{|\})/g, "");
	        return sdp;
	    };

	    /*
	     * If inactive video m-line has bandwith attribute in SDP(occurs in Chrome to PCC call),
	     * Chrome's webRTC Engine rejects it
	     * This workaround removes the b:AS line
	     * TODO : Unit test cases should be written
	     */
	    this.deleteBandwidthLineFromSdp = function(sdp) {
	        if (sdp === null || sdp === undefined) {
	            return sdp;
	        }

	        if (this.isVideoSdpDirectionInactive(sdp)) {
	            logger.debug('Deleting b:AS line from SDP');
	            sdp = sdp.replace(/(b=AS:[\w\W]*?(:\r|\n))/g, '');
	        }
	        return sdp;
	    };
	    /*
	     * Firefox 38.0.1 does not accept uppercase opus codec and cause basic call problem with GCFIOS.
	     * The following is a workaround for this problem.
	     * Feel free to remove it when Firefox 38.0.1 is updated to 38.0.5.
	     */
	    this.setOpusCodecToLowerCase = function(sdp) {
	        if (sdp === null || sdp === undefined) {
	            return sdp;
	        }
	        logger.debug('Setting OPUS codec to lower case');
	        return sdp.replace('OPUS', 'opus');
	    };

	    /*
	     * Replaces audio m line of codec
	     * @sdp Sdp to be processed
	     * @prevValue previous telephony event value
	     * @newValue new telephony event value
	     * @returns processed SDP
	     */
	    this.replaceAudioMlineOfCodec = function(sdp, prevValue, newValue) {
	        if (this.isSdpHasAudio(sdp)) {
	            sdp = this.replaceMlineOfCodec(sdp, _CONSTANTS.STRING.AUDIO, prevValue, newValue);
	        }
	        return sdp;
	    };

	    /*
	     * Replaces video m line of codec
	     * @sdp Sdp to be processed
	     * @prevValue previous telephony event value
	     * @newValue new telephony event value
	     * @returns processed SDP
	     */
	    this.replaceVideoMlineOfCodec = function(sdp, prevValue, newValue) {
	        if (this.isSdpHasVideo(sdp)) {
	            sdp = this.replaceMlineOfCodec(sdp, _CONSTANTS.STRING.VIDEO, prevValue, newValue);
	        }
	        return sdp;
	    };

	    /*
	     * Replaces m line of codec
	     * @sdp Sdp to be processed
	     * @option m line to be processed
	     * @prevValue previous telephony event value
	     * @newValue new telephony event value
	     * @returns processed SDP
	     */
	    this.replaceMlineOfCodec = function(sdp, option, prevValue, newValue) {
	        var prevMline, newMline = '',
	            mLineRegex, index;
	        mLineRegex = new RegExp('m=' + option + ' [\\w\\W]*?(\\r|\\n)', 'g');
	        prevMline = sdp.match(mLineRegex);
	        prevMline = prevMline[0].split(' ');
	        for (index = 0; index < prevMline.length; index++) {
	            // index[1] is actual port and we should not change it.
	            if ((index !== 1) && prevMline[index] && (prevMline[index].indexOf(prevValue) !== -1)) {
	                prevMline[index] = prevMline[index].replace(prevValue, newValue);
	            }
	            // This if check is necessary in order not to put an space at the end of m line
	            if (index === (prevMline.length - 1)) {
	                newMline += prevMline[index];
	            } else {
	                newMline += prevMline[index] + ' ';
	            }
	        }
	        return sdp.replace(mLineRegex, newMline);
	    };

	    /*
	     * Replaces RTPMap of codec
	     * @sdp Sdp to be processed
	     * @prevValue previous telephony event value
	     * @newValue new telephony event value
	     * @returns processed SDP
	     */
	    this.replaceRTPMapOfCodec = function(sdp, prevValue, newValue) {
	        var regex = new RegExp('a=rtpmap:' + prevValue, 'g');
	        return sdp.replace(regex, 'a=rtpmap:' + newValue);
	    };

	    /*
	     * Replaces RTCP of codec
	     * @sdp Sdp to be processed
	     * @prevValue previous telephony event value
	     * @newValue new telephony event value
	     * @returns processed SDP
	     */
	    this.replaceRTCPOfCodec = function(sdp, prevValue, newValue) {
	        var regex = new RegExp('a=rtcp-fb:' + prevValue, 'g');
	        return sdp.replace(regex, 'a=rtcp-fb:' + newValue);
	    };

	    /*
	     * Replaces FMTP of codec
	     * @sdp Sdp to be processed
	     * @prevValue previous telephony event value
	     * @newValue new telephony event value
	     * @returns processed SDP
	     */
	    this.replaceFMTPOfCodec = function(sdp, prevValue, newValue) {
	        var regex = new RegExp('a=fmtp:' + prevValue, 'g');
	        return sdp.replace(regex, 'a=fmtp:' + newValue);
	    };

	    /*
	     * Replaces the codec with new value
	     * @sdp Sdp to be processed
	     * @codec Codec to be replaced
	     * @newValue new value of codec
	     */
	    this.replaceCodecValue = function(sdp, codec, newValue) {
	        var payloadType, prevValue;
	        payloadType = this.getPayloadTypeOf(codec, sdp);
	        if (payloadType) {
	            // If multiple payload types returned, change first of them
	            if (Array.isArray(payloadType)) {
	                prevValue = payloadType[0];
	            } else {
	                prevValue = payloadType;
	            }
	            // Since we don't know which m-line contains this codec, we apply in both m-lines
	            // If an m line does not have this codec, then it will simply return the sdp itself
	            sdp = this.replaceAudioMlineOfCodec(sdp, prevValue, newValue);
	            sdp = this.replaceVideoMlineOfCodec(sdp, prevValue, newValue);
	            sdp = this.replaceRTPMapOfCodec(sdp, prevValue, newValue);
	            sdp = this.replaceRTCPOfCodec(sdp, prevValue, newValue);
	            sdp = this.replaceFMTPOfCodec(sdp, prevValue, newValue);
	        }
	        return sdp;
	    };

	    /*
	     * Replaces codecs
	     * @sdp Sdp to be used
	     * @codecMap codecMap to be replaced
	     * @returns processed SDP
	     */
	    this.replaceCodecs = function(sdp, codecMap) {
	        var index;
	        if (codecMap && codecMap.length) {
	            for (index = 0; index < codecMap.length; index++) {
	                sdp = this.replaceCodecValue(sdp, codecMap[index].name, codecMap[index].value);
	            }
	        }
	        return sdp;
	    };

	    /*
	     * Removes H264 codec from SDP
	     * @sdp Sdp to be used
	     * @returns processed SDP
	     */
	    this.removeH264Codec = function(pSdp) {
	        if (pSdp === null || pSdp === undefined) {
	            return pSdp;
	        }
	        logger.debug("Removing H264 codec from SDP");
	        var h264PayloadType, index;

	        if (pSdp.indexOf("H264/90000") === -1) {
	            return pSdp;
	        }

	        h264PayloadType = this.getH264PayloadType(pSdp);

	        if (h264PayloadType !== -1) {
	            for (index = 0; index < h264PayloadType.length; index++) {
	                logger.debug("removeH264Codec : Removing H264/90000 video codec " + h264PayloadType[index]);
	                pSdp = this.removeVideoCodec(pSdp, h264PayloadType[index]);
	            }
	        }
	        return pSdp;
	    };

	    this.hasZeroConnectionIP = function(pSdp) {
	        if (pSdp === null || pSdp === undefined) {
	            return false;
	        }
	        if (pSdp.indexOf("c=IN IP4 0.0.0.0") !== -1) {
	            return true;
	        }
	        return false;
	    };

	    this.findZeroConnectionIPandModify = function(pSdp) {
	        var sdp = "",
	            substr = "",
	            descriptions = [],
	            index, type;

	        logger.debug("findZeroConnectionIPandModify received SDP: " + pSdp);
	        if (pSdp === null || pSdp === undefined) {
	            return pSdp;
	        }

	        descriptions = pSdp.split(/^(?=m=)/m);
	        for (index = 0; index < descriptions.length; index++) {
	            substr = descriptions[index];
	            if (this.isSdpHasVideo(substr)) {
	                type = _CONSTANTS.STRING.VIDEO;
	            } else {
	                type = _CONSTANTS.STRING.AUDIO;
	            }
	            if (this.hasZeroConnectionIP(substr) && this.getSdpDirection(pSdp, type) !== _CONSTANTS.WEBRTC.MEDIA_STATE.INACTIVE) {
	                substr = substr.replace("c=IN IP4 0.0.0.0", "c=IN IP4 1.1.1.1");
	            }
	            sdp = sdp + substr;
	        }
	        logger.debug("findZeroConnectionIPandModify updated SDP: " + sdp);
	        return sdp;
	    };

	    // this is needed to check
	    // if telephone-event payload changed
	    // fixed scenario: meetme is sending a different TE payload after call setup
	    this.hasCodecPayloadChanged = function(oldSdp, newSdp) {
	        if (!oldSdp || !newSdp) {
	            return false;
	        }

	        if (!this.isSdpHasTelephoneEvent(oldSdp) || !this.isSdpHasTelephoneEvent(newSdp)) {
	            return false;
	        }

	        var oldTEPayloadCodec = this.getPayloadTypeOf("telephone-event/8000", oldSdp),
	            newTEPayloadCodec = this.getPayloadTypeOf("telephone-event/8000", newSdp);

	        return oldTEPayloadCodec !== newTEPayloadCodec;
	    };

	    this.isVideoHasSsrc = function(sdp) {
	        var mLineRegex = new RegExp('m=[\\w\\W]*?(?=(m=|$))', 'g'),
	            mLines, videoLine, i;

	        if (!sdp) {
	            return false;
	        }

	        mLines = sdp.match(mLineRegex);
	        for (i = 0; i < mLines.length; i++) {
	            if (this.isSdpHasVideo(mLines[i])) {
	                videoLine = mLines[i];
	                break;
	            }
	        }

	        if (!videoLine) {
	            return false;
	        }

	        if (videoLine.indexOf("ssrc") !== -1) {
	            return true;
	        }

	        return false;
	    };

	    /*
	     * Checks and replaces APT value. Remove after Chrome 51 release.
	     * @sdp Sdp to be processed
	     * @option m line to be processed
	     * @returns processed SDP
	     */
	    this.checkandReplaceAPTValue = function(pSdp) {
	        var sdp = "",
	            substr = "",
	            descriptions = [],
	            index, reg = /\r\n|\r|\n/m,
	            substr_arr, i, new_substr = "",
	            elm, option, numOfAPT, APTIndex = 0,
	            mLineRegex, sdpMline, splitArray, APTValue;

	        descriptions = pSdp.split(/^(?=m=)/m);
	        for (index = 0; index < descriptions.length; index++) {
	            substr = descriptions[index];
	            if (substr.indexOf('apt=') !== -1) {
	                if (this.isSdpHasAudio(substr)) {
	                    option = 'audio';
	                } else if (this.isSdpHasVideo(substr)) {
	                    option = 'video';
	                }
	                numOfAPT = substr.split('apt=').length - 1;
	                mLineRegex = new RegExp('m=' + option + ' [\\w\\W]*?(\\r|\\n)', 'g');
	                sdpMline = pSdp.match(mLineRegex);
	                sdpMline = sdpMline[0].split(' ');

	                substr_arr = substr.split(reg);
	                for (i = 0; i < substr_arr.length; i++) {
	                    elm = substr_arr[i];
	                    if (elm && elm.indexOf('apt=') !== -1) {
	                        APTIndex++;
	                        splitArray = elm.split('apt=');
	                        APTValue = splitArray[1];

	                        for (index = 0; index < sdpMline.length; index++) {
	                            // index[1] is actual port and we should not check it.
	                            if ((index !== 1) && sdpMline[index] && (sdpMline[index].indexOf(APTValue) !== -1)) {
	                                // APT value is found in codec list. Return the original SDP.
	                                return pSdp;
	                            }
	                        }
	                        if (APTIndex === numOfAPT) {
	                            elm = elm.replace('apt=' + APTValue, 'apt=' + sdpMline[3] + lf + nl);
	                        }
	                    } else if (elm && elm !== "") {
	                        elm = elm + lf + nl;
	                    }
	                    new_substr = new_substr + elm;
	                }
	                substr = new_substr;
	            }
	            sdp = sdp + substr;
	        }
	        return sdp;
	    };
	};

	//@{fcs-jsl-prod}
	var SDPParser = function(_logManager, _fcsConfig, _CONSTANTS) {
	    return new SDPParserImpl(_logManager || logManager,
	        _fcsConfig || fcsConfig,
	        _CONSTANTS || CONSTANTS);
	};

	var sdpParser = new SDPParser();
	//@{fcs-jsl-prod}


	var WebRtcAdaptorModel = function() {
	    var self = this,
	        dtlsEnabled = false,
	        iceServerUrl = "",
	        containers = {
	            video: null,
	            localVideo: null,
	            remoteVideo: null,
	            defaultVideo: null
	        },
	        mediaConstraints = {
	            audio: false,
	            video: false
	        },
	        mediaSources = {
	            video: {
	                available: false
	            },
	            audio: {
	                available: false
	            },
	            screen: {
	                available: false,
	                width: "1024",
	                height: "768",
	                rate: 15
	            }
	        },
	        stats = {},
	        initialized = false,
	        rtcLibrary = {},
	        language,
	        logLevel = 4,
	        peerCount = 0,
	        pluginEnabled = false,
	        h264Enabled = false,
	        audioContext,
	        mediaStreamDestination,
	        screenStream,
	        localStreamMap = new Map(),
	        privateStreamMap = new Map(),
	        localMedia = {},
	        selectedMicrophoneId,
	        selectedSpeakerId,
	        selectedCameraId,
	        mediaSourceList;

	    self.getLocalMedia = function() {
	        return localMedia;
	    };

	    self.setLocalMedia = function(media) {
	        localMedia = media;
	    };

	    self.getLocalStreamMap = function() {
	        return localStreamMap;
	    };

	    self.getScreenStream = function() {
	        return screenStream;
	    };

	    self.setScreenStream = function(stream) {
	        screenStream = stream;
	    };

	    self.isH264Enabled = function() {
	        return h264Enabled;
	    };

	    self.setH264Enabled = function(enabled) {
	        h264Enabled = enabled === true ? true : false;
	    };

	    self.getIceServerUrl = function() {
	        return iceServerUrl;
	    };

	    self.setIceServerUrl = function(url) {
	        iceServerUrl = url;
	    };

	    self.isDtlsEnabled = function() {
	        return dtlsEnabled;
	    };

	    self.setDtlsEnabled = function(enabled) {
	        dtlsEnabled = enabled;
	    };

	    self.getVideoContainer = function() {
	        return containers.video;
	    };

	    self.setVideoContainer = function(container) {
	        containers.video = container;
	    };

	    self.getLocalVideoContainer = function() {
	        return containers.localVideo;
	    };

	    self.setLocalVideoContainer = function(container) {
	        containers.localVideo = container;
	    };

	    self.getRemoteVideoContainer = function() {
	        return containers.remoteVideo;
	    };

	    self.setRemoteVideoContainer = function(container) {
	        containers.remoteVideo = container;
	    };

	    self.getDefaultVideoContainer = function() {
	        return containers.defaultVideo;
	    };

	    self.setDefaultVideoContainer = function(container) {
	        containers.defaultVideo = container;
	    };

	    self.isInitialized = function() {
	        return initialized;
	    };

	    self.setInitialized = function(value) {
	        initialized = value === true ? true : false;
	    };

	    self.getRtcLibrary = function() {
	        return rtcLibrary;
	    };

	    self.setRtcLibrary = function(library) {
	        rtcLibrary = library;
	    };

	    self.getLogLevel = function() {
	        return logLevel;
	    };

	    self.setLogLevel = function(level) {
	        logLevel = level;
	    };

	    self.getLanguage = function() {
	        return language;
	    };

	    self.setLanguage = function(lang) {
	        language = lang;
	    };

	    self.getMediaAudio = function() {
	        return mediaConstraints.audio;
	    };

	    self.setMediaAudio = function(_audio) {
	        mediaConstraints.audio = _audio ? true : false;
	    };

	    self.getMediaVideo = function() {
	        return mediaConstraints.video;
	    };

	    self.setMediaVideo = function(_video) {
	        mediaConstraints.video = _video ? true : false;
	    };

	    self.getVideoWidth = function() {
	        return mediaSources.video.width;
	    };

	    self.setVideoWidth = function(_videoWidth) {
	        mediaSources.video.width = _videoWidth;
	    };

	    self.getVideoHeight = function() {
	        return mediaSources.video.height;
	    };

	    self.setVideoHeight = function(_videoHeight) {
	        mediaSources.video.height = _videoHeight;
	    };

	    self.getVideoSourceAvailable = function() {
	        return mediaSources.video.available || mediaSources.screen.available;
	    };

	    self.setVideoSourceAvailable = function(_videoSourceAvailable) {
	        mediaSources.video.available = _videoSourceAvailable;
	    };

	    self.getAudioSourceAvailable = function() {
	        return mediaSources.audio.available;
	    };

	    self.setAudioSourceAvailable = function(_audioSourceAvailable) {
	        mediaSources.audio.available = _audioSourceAvailable;
	    };

	    self.setMediaSources = function(mediaSourceInfo) {
	        if (mediaSourceInfo) {
	            self.setVideoSourceAvailable(mediaSourceInfo.videoSourceAvailable);
	            self.setAudioSourceAvailable(mediaSourceInfo.audioSourceAvailable);
	            self.setScreenSourceAvailable(mediaSourceInfo.screenSourceAvailable);
	            self.setMediaSourceList(mediaSourceInfo.sourceList);
	        }
	    };

	    self.getScreenSourceAvailable = function() {
	        return mediaSources.screen.available;
	    };

	    self.setScreenSourceAvailable = function(_videoSourceAvailable) {
	        mediaSources.screen.available = _videoSourceAvailable;
	    };

	    self.getScreenWidth = function() {
	        return mediaSources.screen.width;
	    };

	    self.setScreenWidth = function(_screenWidth) {
	        mediaSources.screen.width = _screenWidth;
	    };

	    self.getScreenHeight = function() {
	        return mediaSources.screen.height;
	    };

	    self.setScreenHeight = function(_screenHeight) {
	        mediaSources.screen.height = _screenHeight;
	    };

	    self.getScreenFrameRate = function() {
	        return mediaSources.screen.rate;
	    };

	    self.setScreenFrameRate = function(_screenRate) {
	        mediaSources.screen.rate = _screenRate;
	    };

	    self.getPeerCount = function() {
	        return peerCount;
	    };

	    self.setPeerCount = function(_peerCount) {
	        peerCount = _peerCount;
	    };

	    self.isPluginEnabled = function() {
	        return pluginEnabled;
	    };

	    self.setPluginEnabled = function(_isPluginEnabled) {
	        pluginEnabled = _isPluginEnabled;
	    };

	    self.initAudioContext = function() {
	        window.AudioContext = window.AudioContext || window.webkitAudioContext ||
	            window.mozAudioContext || window.oAudioContext || window.msAudioContext;
	        audioContext = new window.AudioContext();
	    };

	    self.getAudioContext = function() {
	        return audioContext;
	    };

	    self.initMediaStreamDestination = function() {
	        mediaStreamDestination = self.getAudioContext().createMediaStreamDestination();
	    };

	    self.getMediaStreamDestination = function() {
	        return mediaStreamDestination;
	    };

	    self.setSelectedMicrophoneId = function(_selectedMicrophoneId) {
	        selectedMicrophoneId = _selectedMicrophoneId;
	    };

	    self.getSelectedMicrophoneId = function() {
	        return selectedMicrophoneId;
	    };

	    self.setSelectedSpeakerId = function(_selectedSpeakerId) {
	        selectedSpeakerId = _selectedSpeakerId;
	    };

	    self.getSelectedSpeakerId = function() {
	        return selectedSpeakerId;
	    };

	    self.setSelectedCameraId = function(_selectedCameraId) {
	        selectedCameraId = _selectedCameraId;
	    };

	    self.getSelectedCameraId = function() {
	        return selectedCameraId;
	    };

	    self.getStreamById = function(id) {
	        return privateStreamMap.get(id);
	    };

	    self.removeStreamFromMap = function(id) {
	        privateStreamMap.remove(id);
	    };

	    self.getPrivateStreamMap = function() {
	        return privateStreamMap;
	    };

	    self.setMediaSourceList = function(_mediaSourceList) {
	        mediaSourceList = _mediaSourceList;
	    };

	    self.getMediaSourceList = function() {
	        return mediaSourceList;
	    };

	    self.getStats = function() {
	        return stats;
	    };

	    self.setStats = function(_stats) {
	        stats = _stats;
	    };
	};


	var WebRtcChromeAdaptorModel = function() {
	    var self = this,
	        mediaSourceId;

	    self.getMediaSourceId = function() {
	        return mediaSourceId;
	    };

	    self.setMediaSourceId = function(sourceId) {
	        mediaSourceId = sourceId;
	    };

	    self.isH264Enabled = function() {
	        return false;
	    };
	};

	//@{fcs-jsl-prod}
	WebRtcChromeAdaptorModel.prototype = new WebRtcAdaptorModel();
	//@{fcs-jsl-prod}


	var WebRtcFirefoxAdaptorModel = function() {
	    var self = this,
	        // Since Firefox supports H264 by default, this attribute set as true
	        h264Enabled = true;

	    self.isH264Enabled = function() {
	        return h264Enabled;
	    };

	    self.setH264Enabled = function(enabled) {
	        h264Enabled = enabled === true ? true : false;
	    };
	};

	//@{fcs-jsl-prod}
	WebRtcFirefoxAdaptorModel.prototype = new WebRtcAdaptorModel();
	//@{fcs-jsl-prod}


	var WebRtcPluginAdaptorModel = function() {
	    var self = this,
	        //this variable will be always set by a plugin adaptor.
	        pluginVersion = {
	            major: 0,
	            minor: 0,

	            min_revision: 0,
	            min_build: 0,

	            current_revision: 0,
	            current_build: 0
	        };

	    self.getPluginVersion = function() {
	        return pluginVersion;
	    };

	    self.setPluginVersion = function(version) {
	        pluginVersion = version;
	    };
	};

	//@{fcs-jsl-prod}
	WebRtcPluginAdaptorModel.prototype = new WebRtcAdaptorModel();
	//@{fcs-jsl-prod}


	var webRtcLibraryDecoratorImpl = function(target, _super, _utils) {
	    var libraryObjWrapper = {};

	    libraryObjWrapper.getUserMedia = target.getUserMedia;
	    libraryObjWrapper.showSettingsWindow = target.showSettingsWindow;
	    libraryObjWrapper.getURLFromStream = target.getURLFromStream;
	    libraryObjWrapper.enableH264 = target.enableH264;

	    libraryObjWrapper.createRTCSessionDescription = function(type, sdp) {
	        return target.createSessionDescription(type, sdp);
	    };

	    libraryObjWrapper.createRTCIceCandidate = function(candidate, type, number) {
	        return target.createIceCandidate(candidate, type, number);
	    };

	    libraryObjWrapper.createRTCPeerConnection = function(stunturn, constraints) {
	        return target.createPeerConnection(stunturn, constraints);
	    };

	    libraryObjWrapper.setLang = function(lang) {
	        target.setLanguage(lang || "en");
	    };

	    libraryObjWrapper.checkMediaSourceAvailability = function(callback) {
	        _utils.callFunctionIfExist(callback, {
	            videoSourceAvailable: (target.getVideoDeviceNames().length > 0) ? true : false,
	            audioSourceAvailable: (target.getAudioInDeviceNames().length > 0) ? true : false,
	            sourceList: [],
	            screenSourceAvailable: false
	        });
	    };

	    libraryObjWrapper.get_audioInDeviceCount = function() {
	        return target.getAudioInDeviceNames().length;
	    };

	    libraryObjWrapper.get_audioOutDeviceCount = function() {
	        return target.getAudioOutDeviceNames().length;
	    };

	    libraryObjWrapper.get_videoDeviceCount = function() {
	        return target.getVideoDeviceNames().length;
	    };

	    libraryObjWrapper.set_logSeverityLevel = function(level) {
	        target.logSeverityLevel = level;
	        return true;
	    };

	    libraryObjWrapper.get_logSeverityLevel = function() {
	        return target.logSeverityLevel;
	    };

	    libraryObjWrapper.enable_logCallback = function(handler) {
	        target.logCallback = handler;
	        return true;
	    };

	    libraryObjWrapper.disable_logCallback = function() {
	        target.logCallback = null;
	    };

	    libraryObjWrapper.setType = function(applicationType) {
	        target.type = applicationType;
	    };

	    libraryObjWrapper.getType = function() {
	        return target.type;
	    };

	    libraryObjWrapper.getVersion = function() {
	        return target.version;
	    };

	    libraryObjWrapper.setH264CodecStateChangeHandler = function(handler) {
	        target.onh264codecstatechange = handler;
	    };

	    libraryObjWrapper.getCurrentPluginVersionObject = function() {
	        var splittedPluginVersion = target.version.split("."),
	            currentPluginVersion;

	        currentPluginVersion = {
	            major: parseInt(splittedPluginVersion[0], 10),
	            minor: parseInt(splittedPluginVersion[1], 10),
	            revision: parseInt(splittedPluginVersion[2], 10),
	            build: parseInt(splittedPluginVersion[3], 10)
	        };
	        return currentPluginVersion;
	    };

	    libraryObjWrapper.detachWebAudioContextFromLocalMedia = function(localMedia) {
	        localMedia.audioContext.close();
	        localMedia.mediaStreamDestination.disconnect();
	    };

	    libraryObjWrapper.stopLocalMedia = function(localMedia) {
	        if (localMedia) {
	            libraryObjWrapper.stopStream(localMedia.stream);
	            libraryObjWrapper.stopStream(localMedia.originalStream);
	        }
	    };

	    libraryObjWrapper.stopStream = function(stream) {
	        if (stream && stream.stop) {
	            stream.stop();
	        }
	    };

	    libraryObjWrapper.createConstraints = function(audio, video) {
	        return {
	            'mandatory': {
	                'OfferToReceiveAudio': audio,
	                'OfferToReceiveVideo': video
	            }
	        };
	    };

	    libraryObjWrapper.updateStream = function(peer, call) {
	        peer.removeStream(peer.localStreams["0"]);
	        peer.addStream(call.localMedia.stream);
	    };

	    return libraryObjWrapper;
	};

	//@{fcs-jsl-prod}
	var webRtcLibraryDecorator = function(target, _super, _utils) {
	    return webRtcLibraryDecoratorImpl(target || {}, _super, _utils || utils);
	};

	//@{fcs-jsl-prod}


	var webRtcLibraryFirefoxDecoratorImpl = function(target, _super, _window, _navigator) {
	    _super(target);

	    target.getUserMedia = function(constraints, successCallback, failureCallback) {
	        if (_navigator.mediaDevices && _navigator.mediaDevices.getUserMedia) {
	            _navigator.mediaDevices.getUserMedia(constraints)
	                .then(successCallback)
	                .catch(failureCallback);
	        } else {
	            _navigator.mozGetUserMedia(constraints, successCallback, failureCallback);
	        }
	    };

	    target.createRTCSessionDescription = function(type, sdp) {
	        if (_window.RTCSessionDescription) {
	            return new _window.RTCSessionDescription({
	                "type": type,
	                "sdp": sdp
	            });
	        } else {
	            return new _window.mozRTCSessionDescription({
	                "type": type,
	                "sdp": sdp
	            });
	        }
	    };

	    target.createRTCIceCandidate = function(candidate) {
	        if (_window.RTCIceCandidate) {
	            return new _window.RTCIceCandidate(candidate);
	        } else {
	            return new _window.mozRTCIceCandidate(candidate);
	        }
	    };

	    target.createRTCPeerConnection = function(stunturn, constraints) {
	        if (_window.RTCPeerConnection) {
	            return new _window.RTCPeerConnection(stunturn, constraints);
	        } else {
	            return new _window.mozRTCPeerConnection(stunturn, constraints);
	        }
	    };

	    target.stopLocalMedia = function(localMedia) {
	        if (localMedia) {
	            target.stopStream(localMedia.stream);
	            target.stopStream(localMedia.originalStream);
	        }
	    };

	    target.stopStream = function(stream) {
	        if (stream && stream.stop) {
	            stream.stop();
	        }
	    };

	    target.createConstraints = function(audio, video) {
	        return {
	            'offerToReceiveAudio': audio,
	            'offerToReceiveVideo': video
	        };
	    };

	    target.updateStream = function(peer, call) {
	        return;
	        //        peer.removeTrack(peer.getSenders()[0]);
	        //        peer.addStream(call.localMedia.stream);
	    };
	};

	//@{fcs-jsl-prod}
	var webRtcLibraryFirefoxDecorator = function(target, _super, _window, _navigator) {
	    webRtcLibraryFirefoxDecoratorImpl(target || {},
	        _super || webRtcLibraryChromeDecorator,
	        _window || window,
	        _navigator || navigator);
	};

	//@{fcs-jsl-prod}


	var webRtcLibraryChromeDecoratorImpl = function(target, _super, _window, _navigator, _utils, _logManager) {
	    var logger = _logManager.getLogger("webRtcLibraryChromeDecoratorImpl"),
	        screenShareExtensionLoaded = false,
	        screenShareExtensionId;
	    _super(target);

	    target.getUserMedia = function(constraints, successCallback, failureCallback) {
	        _navigator.webkitGetUserMedia(constraints, successCallback, failureCallback);
	    };

	    target.getScreenMedia = function(constraints, onSuccess, onFailure) {

	        // Gets the user media.
	        function getSourceMedia(mediaSourceId) {
	            if(mediaSourceId) {
	                constraints.video.mandatory.chromeMediaSourceId = mediaSourceId;
	            }
	            constraints.audio = false;
	            constraints.video.mandatory.chromeMediaSource = 'desktop';
	            target.getUserMedia(constraints, onSuccess, onFailure);
	        }

	        // Determine which screensharing method should be used.
	        if (screenShareExtensionLoaded) {
	            // Retrieve the source id from the chrome extension.
	            _window.chrome.runtime.sendMessage(screenShareExtensionId, {
	                message: "chooseDesktopMedia"
	            },
	            // sendMessage success callback.
	            function(response) {
	                if(response && response.mediaSourceId) {
	                    getSourceMedia(response.mediaSourceId);
	                } else {
	                    _utils.callFunctionIfExist(onFailure);
	                }
	            });
	        } else if(constraints.video.mandatory.chromeMediaSourceId) {
	            // The source id was already provided by the app.
	            getSourceMedia();
	        } else {
	            // Neither screensharing method worked.
	            logger.debug('No extension ID or media source ID provided.');
	            _utils.callFunctionIfExist(onFailure);
	        }
	    };

	    target.initScreenSharing = function(onSuccess, onFailure, options) {
	        var screenSharingOpts = options.screenSharing;

	        if (screenSharingOpts && screenSharingOpts.chromeExtensionId) {
	            screenShareExtensionId = screenSharingOpts.chromeExtensionId;
	            try {
	                _window.chrome.runtime.sendMessage(screenShareExtensionId, {
	                    message: "version"
	                }, function(response) {
	                    if (response && response.version) {
	                        screenShareExtensionLoaded = true;
	                        _utils.callFunctionIfExist(onSuccess);
	                    } else {
	                        _utils.callFunctionIfExist(onFailure, fcs.call.MediaErrors.NO_SCREENSHARING_WARNING);
	                    }
	                });
	            } catch (error) {
	                _utils.callFunctionIfExist(onFailure, fcs.call.MediaErrors.NO_SCREENSHARING_WARNING);
	            }
	        } else {
	            // If there is no screensharing extension, screensharing can still work if the application
	            // provides the media source id on it's own. Consider this else case a success, since
	            // we don't want to say screensharing is not available.
	            _utils.callFunctionIfExist(onSuccess);
	        }
	    };

	    target.showSettingsWindow = function() {
	        return;
	    };

	    target.createRTCSessionDescription = function(type, sdp) {
	        return new _window.RTCSessionDescription({
	            "type": type,
	            "sdp": sdp
	        });
	    };

	    target.createRTCIceCandidate = function(candidate) {
	        return new _window.RTCIceCandidate(candidate);
	    };

	    target.getURLFromStream = function(stream) {
	        return _window.URL.createObjectURL(stream);
	    };

	    target.createRTCPeerConnection = function(stunturn, constraints) {
	        return new _window.webkitRTCPeerConnection(stunturn, constraints);
	    };

	    target.checkMediaSourceAvailability = function(callback) {
	        var i, videoSourceAvailable, audioSourceAvailable, sources = [];

	        function executeCallback(videoSourceAvailable, audioSourceAvailable) {
	            _utils.callFunctionIfExist(callback, {
	                videoSourceAvailable: videoSourceAvailable,
	                audioSourceAvailable: audioSourceAvailable,
	                sourceList: sources,
	                // Hardcode screensharing to be available, since there is
	                // no initialization needed for screensharing to be available.
	                screenSourceAvailable: true
	            });
	        }

	        function processMediaDevices(mediaSources) {
	            for (i = 0; i < mediaSources.length; i++) {
	                if (mediaSources[i].kind === "videoinput" || mediaSources[i].kind === "video") {
	                    // Video source is available such as webcam
	                    videoSourceAvailable = true;
	                } else if (mediaSources[i].kind === "audioinput" || mediaSources[i].kind === "audio") {
	                    // audio source is available such as mic
	                    audioSourceAvailable = true;
	                }
	                sources.push({
	                    id: mediaSources[i].deviceId || mediaSources[i].id,
	                    kind: mediaSources[i].kind,
	                    label: mediaSources[i].label
	                });
	            }
	            executeCallback(videoSourceAvailable, audioSourceAvailable);
	        }

	        if (_navigator.mediaDevices && _navigator.mediaDevices.enumerateDevices) {
	            _navigator.mediaDevices.enumerateDevices().then(processMediaDevices).catch(function(error) {
	                logger.error("Failed to enumerate devices. Error name: " + error.name + "Error message: " + error.message);
	                executeCallback(false, false);
	            });
	        } else {
	            _window.MediaStreamTrack.getSources(processMediaDevices);
	        }
	    };

	    target.detachWebAudioContextFromLocalMedia = function(localMedia) {
	        localMedia.audioContext.close();
	        if (localMedia.mediaStreamDestination.numberOfOutputs > 0) {
	            localMedia.mediaStreamDestination.disconnect();
	        }
	    };

	    target.stopLocalMedia = function(localMedia) {
	        if (localMedia) {
	            target.stopStream(localMedia.stream);
	            target.stopStream(localMedia.originalStream);
	        }
	    };

	    target.stopStream = function(stream) {
	        var i, tracks = [];
	        if (stream && stream.getTracks) {
	            tracks = stream.getTracks();
	        }
	        for (i in tracks) {
	            if (tracks.hasOwnProperty(i)) {
	                tracks[i].stop();
	            }
	        }
	    };

	    target.get_audioInDeviceCount = function() {
	        // Not Applicable for Chrome Native
	        return 1;
	    };

	    target.get_audioOutDeviceCount = function() {
	        // Not Applicable for Chrome Native
	        return 1;
	    };

	    target.get_videoDeviceCount = function() {
	        // Not Applicable for Chrome Native
	        return 1;
	    };

	    target.set_logSeverityLevel = function() {
	        // Not Applicable for Chrome Native
	        return false;
	    };

	    target.get_logSeverityLevel = function() {
	        // Not Applicable for Chrome Native
	        return;
	    };

	    target.enable_logCallback = function() {
	        // Not Applicable for Chrome Native
	        return;
	    };

	    target.disable_logCallback = function() {
	        // Not Applicable for Chrome Native
	        return;
	    };

	    target.createConstraints = function(audio, video) {
	        return {
	            'mandatory': {
	                'OfferToReceiveAudio': audio,
	                'OfferToReceiveVideo': video
	            }
	        };
	    };

	    target.updateStream = function(peer, call) {
	        peer.removeStream(peer.getLocalStreams()[0]);
	        peer.addStream(call.localMedia.stream);
	    };
	};

	//@{fcs-jsl-prod}
	var webRtcLibraryChromeDecorator = function(target, _super, _window, _navigator, _utils, _logManager) {
	    webRtcLibraryChromeDecoratorImpl(target || {},
	        _super || webRtcLibraryDecorator,
	        _window || window,
	        _navigator || navigator,
	        _utils || utils,
	        _logManager || logManager);
	};
	//@{fcs-jsl-prod}


	var WebRtcAdaptorImpl = function(_super, _decorator, _model, _logManager, _utils, _sdpParser, _mediaErrors, _cache, _fcs) {
	    /*
	     * ABE-832: On MAC OS, Safari browser version 6.1 doesn't recognize array
	     * indices of integer type. Therefore, all [0] calls are changed to ["0"].
	     * All other browser types function correctly with both integer and string
	     * indices.
	     *
	     * Right now, this only affects arrays coming from the plugin.
	     *
	     * That's why we use zero = "0". Using "0" directly didn't work because
	     * minification replaces it with 0.
	     */
	    var self = this,
	        logger = _logManager.getLogger("WebRtcAdaptorImpl"),
	        zero = "0";
	    logger = _logManager.getLogger("WebRtcAdaptorImpl");

	    logger.debug('WebRtcAdaptor initializing');

	    _utils.compose(_model, self);

	    // This is for MPV and Mobile SDK interop
	    //
	    // Just a wrapper for original setRemoteDescription to have single entry point
	    // if 'peer' parameter is not given, it just stores 'sdp' into 'stableRemoteSdp'
	    //
	    // main purpose:
	    // 1- store remote description for every setRemoteDescription request to webrtc engine
	    // 2- store remote description where it is not set to webrtc engine
	    self.setRemoteDescription = function(call, peer, type, sdp, onSuccess, onFailure) {
	        var remoteDesc;

	        function storeRemoteSdp() {
	            call.stableRemoteSdp = sdp;
	            logger.debug('stored stable remote sdp');
	            if (typeof onSuccess === 'function') {
	                onSuccess();
	            }
	        }

	        if (peer) {
	            remoteDesc = self.getRtcLibrary().createRTCSessionDescription(type, sdp);
	            peer.setRemoteDescription(remoteDesc, storeRemoteSdp, onFailure);
	        } else {
	            storeRemoteSdp();
	        }
	    };

	    self.isVideoDirectionsSendRecv = function(localSdp, remoteSdp) {
	        return _sdpParser.isVideoSdpDirectionSendrecv(localSdp) &&
	            _sdpParser.isVideoSdpDirectionSendrecv(remoteSdp);
	    };

	    self.isAudioDirectionsSendRecv = function(localSdp, remoteSdp) {
	        return _sdpParser.isAudioSdpDirectionSendrecv(localSdp) &&
	            _sdpParser.isAudioSdpDirectionSendrecv(remoteSdp);
	    };

	    self.isSdpDirectionsSendRecv = function(localSdp, remoteSdp) {
	        var isAudioSdpDirectionsSendRecv = self.isAudioDirectionsSendRecv(localSdp, remoteSdp);
	        if (_sdpParser.isSdpHasVideo(localSdp)) {
	            return isAudioSdpDirectionsSendRecv && self.isVideoDirectionsSendRecv(localSdp, remoteSdp);
	        }

	        return isAudioSdpDirectionsSendRecv;
	    };

	    self.oldSolutionNeeded = function(oldSdp, newSdp) {
	        var oldVideoLine = _sdpParser.isSdpHasVideo(oldSdp),
	            newVideoLine = _sdpParser.isSdpHasVideo(newSdp),
	            oldSessionId = _sdpParser.getSessionIdFromSdp(oldSdp),
	            newSessionId = _sdpParser.getSessionIdFromSdp(newSdp),
	            telephoneEventPayloadChanged = _sdpParser.hasCodecPayloadChanged(oldSdp, newSdp);

	        logger.debug('telephoneEventPayloadChanged: ' + telephoneEventPayloadChanged + ' session changed: ' + (oldSessionId !== newSessionId) + ' video line changed: ' + (oldVideoLine !== newVideoLine));
	        if (telephoneEventPayloadChanged || oldSessionId !== newSessionId || oldVideoLine !== newVideoLine) {
	            return true;
	        } else {
	            return false;
	        }
	    };

	    self.iceCredentialsChanged = function(oldSdp, newSdp) {
	        var oldVideoUfrag = _sdpParser.getICEParams(oldSdp, CONSTANTS.SDP.ICE_UFRAG, true),
	            newVideoUfrag = _sdpParser.getICEParams(newSdp, CONSTANTS.SDP.ICE_UFRAG, true);

	        logger.debug('ufrag changed: ' + (oldVideoUfrag !== newVideoUfrag));
	        if (oldVideoUfrag !== newVideoUfrag) {
	            return true;
	        } else {
	            return false;
	        }
	    };

	    /*
	     * update codecs accordingly
	     */
	    self.updateCodecs = function(call, oSdp) {
	        oSdp = _sdpParser.replaceCodecs(oSdp, call.codecsToReplace ? call.codecsToReplace : fcsConfig.codecsToReplace);
	        oSdp = _sdpParser.updateAudioCodec(oSdp);
	        oSdp = _sdpParser.updateVideoCodec(oSdp);
	        return oSdp;
	    };

	    /*
	     * Overrides configured codec values with originators value, in this case, webRtc is terminator side
	     */
	    self.overrideConfiguredCodecValues = function(call, sdp) {
	        var index, newValue;
	        call.codecsToReplace = call.codecsToReplace ? call.codecsToReplace : JSON.parse(JSON.stringify(fcsConfig.codecsToReplace));
	        if (call.codecsToReplace) {
	            for (index = 0; index < call.codecsToReplace.length; index++) {
	                newValue = _sdpParser.getPayloadTypeOf(call.codecsToReplace[index].name, sdp);
	                if (newValue && (newValue !== -1)) {
	                    // getPayloadTypeOf method could return
	                    // either array or string
	                    // In such case, arrays first element will be used
	                    if (Array.isArray(newValue)) {
	                        newValue = newValue[0];
	                    }
	                    call.codecsToReplace[index].value = newValue;
	                }
	            }
	        }
	    };

	    //This function is called internally when we make a new call or hold/unhold scenario
	    // Native implementation lies on webRtcAdaptor.js
	    self.addLocalStream = function(internalCall) {
	        var streamUrl, fireEvent = false,
	            isSendingLocalVideo = self.canOriginatorSendLocalVideo(internalCall);

	        if (internalCall.localMedia.stream) {
	            if (isSendingLocalVideo) {
	                streamUrl = self.getRtcLibrary().getURLFromStream(internalCall.localMedia.stream);

	                if (streamUrl) {
	                    if (self.getDefaultVideoContainer()) {
	                        fireEvent = self.useDefaultRenderer(streamUrl, true, true);
	                    } else if (self.getLocalVideoContainer()) {
	                        fireEvent = self.createStreamRenderer(streamUrl, self.getLocalVideoContainer(), {
	                            muted: true
	                        });
	                    } else {
	                        internalCall.call.localStreamURL = streamUrl;
	                        fireEvent = true;
	                    }
	                }
	            } else {
	                if (self.getDefaultVideoContainer()) {
	                    if (self.getDefaultVideoContainer().lastElementChild) {
	                        self.disposeStreamRenderer(self.getDefaultVideoContainer().lastElementChild);
	                    }
	                } else if (self.getLocalVideoContainer()) {
	                    self.disposeStreamRenderer(self.getLocalVideoContainer());
	                }
	            }

	            logger.debug("onLocalStreamAdded: " + streamUrl);
	            if (fireEvent) {
	                self.fireOnLocalStreamAddedEvent(internalCall, streamUrl);
	            }
	        }
	    };

	    // Native implementation lies on webRtcAdaptor.js

	    self.fireOnLocalStreamAddedEvent = function(call, streamUrl) {
	        if (call && call.call && call.call.onLocalStreamAdded) {
	            _utils.callFunctionIfExist(call.call.onLocalStreamAdded, streamUrl);
	        }
	    };

	    self.storeLocalStreamToCall = function(call, localStreamId) {
	        logger.debug("assigning local stream [" + localStreamId + "] to call: " + call.id);
	        if (call.localMedia) {
	            self.endLocalMedia(call.localMedia);
	        }
	        self.updateLocalStreamToCall(call, localStreamId);
	    };

	    self.updateLocalStreamToCall = function(call, localStreamId) {
	        call.localMedia = self.getLocalStreamMap().get(localStreamId);
	    };

	    self.performSdpWorkaroundsBeforeProcessingIncomingSdp = function(call) {
	        call.sdp = _sdpParser.deleteBandwidthLineFromSdp(call.sdp);
	        call.sdp = _sdpParser.removeG722Codec(call.sdp);
	    };

	    /*
	     * createNativeReOffer
	     */
	    self.createReOffer = function(call, onSuccess, onFailure, usePreviousMediaDirection, useIceServer) {
	        var peer = call.peer,
	            localDescObj, localAudioDirection, localVideoDirection,
	            prevLocalSdp = call.stableLocalSdp,
	            deleteVideoStream = false,
	            mediaVideo = self.getMediaVideo(),
	            data;

	        logger.debug("createReOffer:" + call.id);

	        if (!usePreviousMediaDirection) {
	            deleteVideoStream = !call.initialVideoState && _sdpParser.isSdpHasVideo(call.stableLocalSdp);
	            mediaVideo = mediaVideo && call.initialVideoState;
	        }

	        data = {
	            call: call,
	            mustCreatePeer: true,
	            deleteVideoStream: deleteVideoStream,
	            useIceServer: useIceServer
	        };
	        if (self.createNewPeerForCall(data)) {
	            peer = call.peer;
	        }

	        peer.createOffer(
	            function createReOfferCreateOfferSuccessCallback(oSdp) {

	                if (usePreviousMediaDirection) {
	                    localAudioDirection = _sdpParser.getAudioSdpDirection(prevLocalSdp);
	                    oSdp.sdp = _sdpParser.updateAudioSdpDirection(oSdp.sdp, localAudioDirection);
	                    localVideoDirection = _sdpParser.getVideoSdpDirection(prevLocalSdp);
	                    oSdp.sdp = _sdpParser.updateVideoSdpDirection(oSdp.sdp, localVideoDirection);
	                }

	                oSdp.sdp = _sdpParser.deleteCryptoZeroFromSdp(oSdp.sdp);
	                oSdp.sdp = _sdpParser.removeG722Codec(oSdp.sdp);
	                oSdp.sdp = _sdpParser.deleteCryptoFromSdp(oSdp.sdp, self.isDtlsEnabled());
	                oSdp.sdp = _sdpParser.setTcpSetupAttributeToActpass(oSdp.sdp, self.isDtlsEnabled());
	                oSdp.sdp = _sdpParser.updateVersion(prevLocalSdp, oSdp.sdp);
	                oSdp.sdp = self.updateCodecs(call, oSdp.sdp);

	                localDescObj = self.getRtcLibrary().createRTCSessionDescription(CONSTANTS.WEBRTC.RTC_SDP_TYPE.OFFER, oSdp.sdp);
	                peer.setLocalDescription(localDescObj, function createReOfferSetLocalDescriptionSuccessCallback() {
	                        logger.debug("createReOffer: setLocalDescription success" + call.id);
	                    }, function createReOfferSetLocalDescriptionFailureCallback(e) {
	                        logger.debug("createReOffer: setLocalDescription failed!!" + e + call.id);
	                        _utils.callFunctionIfExist(onFailure);
	                    });
	            },
	            function createReOfferCreateOfferFailureCallback(e) {
	                logger.error("createReOffer: createOffer failed!! " + e);
	                _utils.callFunctionIfExist(onFailure);
	            }, self.getRtcLibrary().createConstraints(self.getMediaAudio(), mediaVideo));
	    };

	    // Native implementation lies on webRtcAdaptor.js
	    self.getLocalAudioTrack = function(peer) {
	        logger.debug("getLocalAudioTrack");
	        var audioTracks;

	        if (peer.localStreams && peer.localStreams[zero].audioTracks) {
	            if (peer.localStreams[zero].audioTracks.length > 0) {
	                return peer.localStreams[zero].audioTracks[zero];
	            }
	        } else if (peer.getLocalStreams) {
	            audioTracks = peer.getLocalStreams()[zero].getAudioTracks();
	            if (audioTracks && audioTracks.length > 0) {
	                return audioTracks[zero];
	            }
	        }

	        return null;
	    };

	    // Native implementation lies on webRtcAdaptor.js
	    self.getLocalVideoTrack = function(peer) {
	        logger.debug("getLocalVideoTrack");
	        var streams;

	        if (peer.localStreams && peer.localStreams[zero].videoTracks) {
	            if (peer.localStreams[zero].videoTracks.length > 0) {
	                return peer.localStreams[zero].videoTracks[zero];
	            }
	        } else if (peer.getLocalStreams) {
	            streams = peer.getLocalStreams();
	            if (streams && streams[zero].getVideoTracks() && streams[zero].getVideoTracks().length > 0) {
	                return streams[zero].getVideoTracks()[zero];
	            }
	        }

	        return null;
	    };

	    self.getRemoteVideoTrack = function(peer) {
	        logger.debug("getRemoteVideoTrack");
	        var streams;

	        if (peer.remoteStreams && peer.remoteStreams["0"]) {
	            return peer.remoteStreams["0"].videoTracks;
	        } else if (peer.getRemoteStreams) {
	            streams = peer.getRemoteStreams();
	            if (streams && streams["0"]) {
	                return streams["0"].getVideoTracks();
	            }
	        }

	        return [];
	    };

	    self.muteAudioTrack = function(call, mute, userAction) {
	        var localAudioTrack;

	        if (!self.isInitialized()) {
	            logger.warn("muteAudioTrack: Plugin is not installed");
	            return;
	        }

	        if (!call.peer) {
	            return;
	        }

	        localAudioTrack = self.getLocalAudioTrack(call.peer);
	        if (localAudioTrack) {
	            logger.info("mute Audio Track [" + localAudioTrack.id + "], call [" + call.id + "] mute=" + mute);
	            localAudioTrack.enabled = !mute;
	            call.audioMuted = mute;
	            if (userAction) {
	                call.fcsUserAudioMuteState = mute;
	            }
	        }
	    };

	    self.muteVideoTrack = function(call, mute, userAction) {
	        var localVideoTrack;

	        if (!self.isInitialized()) {
	            logger.warn("muteVideoTrack: Plugin is not installed");
	            return;
	        }

	        if (!call.peer) {
	            return;
	        }

	        localVideoTrack = self.getLocalVideoTrack(call.peer);
	        if (localVideoTrack) {
	            logger.info("mute Video Track [" + localVideoTrack.id + "], call [" + call.id + "] mute=" + mute);
	            localVideoTrack.enabled = !mute;
	            call.videoMuted = mute;
	            if (userAction) {
	                call.fcsUserVideoMuteState = mute;
	            }
	        }
	    };

	    self.isAudioMuted = function(call) {
	        if (call && call.audioMuted) {
	            return call.audioMuted;
	        }
	        return false;
	    };

	    self.restoreMuteStateOfCall = function(call) {
	        var previousMuteStateOfAudio = false,
	            previousMuteStateOfVideo = false;
	        if (!call.peer) {
	            return;
	        }

	        if (call.fcsUserAudioMuteState) {
	            previousMuteStateOfAudio = call.fcsUserAudioMuteState;
	        }

	        if (call.fcsUserVideoMuteState) {
	            previousMuteStateOfVideo = call.fcsUserVideoMuteState;
	        }

	        logger.debug("previous audio mute state of call: " + previousMuteStateOfAudio);
	        logger.debug("previous video mute state of call: " + previousMuteStateOfVideo);
	        self.muteAudioTrack(call, previousMuteStateOfAudio);
	        self.muteVideoTrack(call, previousMuteStateOfVideo);
	    };

	    /*
	     * Native implementation lies on webRtcAdaptor.js
	     * Mutes audio and video tracks (to be used during Hold)
	     *
	     * @ignore
	     * @name rtc.mute
	     * @function
	     * @param {Object} call internalCall
	     * @param {boolean} mute true to mute, false to unmute
	     */
	    self.muteOnHold = function(call, mute) {
	        self.muteAudioTrack(call, mute);
	        self.muteVideoTrack(call, mute);
	    };

	    // Native implementation lies on webRtcAdaptor.js
	    // initNativeMedia
	    self.initMedia = function(onSuccess, onFailure, options) {
	        self.setInitialized(true);
	        _decorator(self.getRtcLibrary());

	        function setMediaSources() {
	            self.getRtcLibrary().checkMediaSourceAvailability(function mediaSourceCallback(mediaSourceInfo) {
	                self.setMediaSources(mediaSourceInfo);
	            });
	        }

	        self.getRtcLibrary().initScreenSharing(function() {
	            // Regardless of success or error, set the media sources.
	            setMediaSources();

	            _utils.callFunctionIfExist(onSuccess);
	        }, function(error) {
	            // Regardless of success or error, set the media sources.
	            setMediaSources();

	            utils.callFunctionIfExist(onFailure, error);
	        }, options);
	    };

	    /*
	     * Native implementation lies on webRtcAdaptor.js
	     * performNativeVideoStartWorkaround - term side cannot see orig's video
	     */
	    self.performVideoStartWorkaround = function(call, onSuccess, onFail) {
	        var peer = call.peer,
	            remoteAudioState, remoteVideoState, callSdpWithNoSsrc, localSdp;

	        if (!_sdpParser.isSdpHasVideo(call.sdp)) {
	            self.setRemoteDescription(call, null, null, call.sdp, onSuccess, onFail);
	            return;
	        }

	        logger.debug("Workaround to play video");

	        localSdp = call.stableLocalSdp ? call.stableLocalSdp : call.peer.localDescription.sdp;
	        call.sdp = _sdpParser.addSdpMissingCryptoLine(call.sdp);

	        remoteAudioState = _sdpParser.getAudioSdpDirection(call.sdp);
	        remoteVideoState = _sdpParser.getVideoSdpDirection(call.sdp);

	        call.sdp = _sdpParser.updateAudioSdpDirectionToInactive(call.sdp);
	        call.sdp = _sdpParser.updateVideoSdpDirectionToInactive(call.sdp);

	        call.sdp = _sdpParser.setTcpSetupAttributeToActpass(call.sdp, self.isDtlsEnabled());

	        // In Peer-Peer call, in order to remove remote stream properly,
	        // ssrc lines should be deleted so that workaround below will
	        // first remove the remote stream and then re-add it according to
	        // actuall call sdp.
	        // In Non Peer-Peer call, ther is no ssrc line in sdp so it is safe
	        // to keep method below.
	        callSdpWithNoSsrc = _sdpParser.deleteSsrcFromSdp(call.sdp);

	        self.setRemoteDescription(call, peer, CONSTANTS.WEBRTC.RTC_SDP_TYPE.OFFER, callSdpWithNoSsrc,
	            function pvswFirstSetRemoteDescriptionSuccessCallback() {
	                logger.debug("performVideoStartWorkaround: first setRemoteDescription success");

	                // restore original values
	                call.sdp = _sdpParser.updateAudioSdpDirection(call.sdp, remoteAudioState);
	                call.sdp = _sdpParser.updateVideoSdpDirection(call.sdp, remoteVideoState);

	                self.setRemoteDescription(call, peer, CONSTANTS.WEBRTC.RTC_SDP_TYPE.OFFER, call.sdp,
	                    function pvswSecondSetRemoteDescriptionSuccessCallback() {
	                        logger.debug("performVideoStartWorkaround: second setRemoteDescription success");
	                        peer.createAnswer(
	                            function pvswCreateAnswerSuccessCallback(obj) {
	                                if (remoteAudioState === CONSTANTS.WEBRTC.MEDIA_STATE.INACTIVE) {
	                                    obj.sdp = _sdpParser.updateAudioSdpDirectionToInactive(obj.sdp);
	                                }

	                                if (remoteVideoState === CONSTANTS.WEBRTC.MEDIA_STATE.INACTIVE) {
	                                    obj.sdp = _sdpParser.updateVideoSdpDirectionToInactive(obj.sdp);
	                                } else if (self.canOriginatorSendLocalVideo(call)) {
	                                    obj.sdp = _sdpParser.updateVideoSdpDirection(obj.sdp, CONSTANTS.WEBRTC.MEDIA_STATE.SEND_RECEIVE);
	                                } else {
	                                    obj.sdp = _sdpParser.updateVideoSdpDirection(obj.sdp, CONSTANTS.WEBRTC.MEDIA_STATE.RECEIVE_ONLY);
	                                }

	                                obj.sdp = _sdpParser.checkAndRestoreICEParams(obj.sdp, call.sdp);

	                                obj.sdp = _sdpParser.setTcpSetupAttributeTo(obj.sdp, call.localTcpSetupAttribute, self.isDtlsEnabled());

	                                obj.sdp = _sdpParser.updateVersion(localSdp, obj.sdp);

	                                peer.setLocalDescription(
	                                    self.getRtcLibrary().createRTCSessionDescription(CONSTANTS.WEBRTC.RTC_SDP_TYPE.ANSWER, obj.sdp),
	                                    function pvswSetLocalDescriptionSuccessCallback() {
	                                        logger.debug("performVideoStartWorkaround: setlocalDescription success");
	                                        _utils.callFunctionIfExist(onSuccess);
	                                    },
	                                    function pvswSetLocalDescriptionFailureCallback(e) {
	                                        logger.debug("performVideoStartWorkaround: setlocalDescription failed!!" + e);
	                                        _utils.callFunctionIfExist(onFail, "performVideoStartWorkaround: setlocalDescription failed!!");
	                                    });
	                            },
	                            function pvswCreateAnswerFailureCallback(e) {
	                                logger.debug("performVideoStartWorkaround: createAnswer failed!! " + e);
	                                _utils.callFunctionIfExist(onFail, "Session cannot be created");
	                            }, self.getRtcLibrary().createConstraints(self.getMediaAudio(), self.getMediaVideo()));
	                    },
	                    function pvswSecondSetRemoteDescriptionFailureCallback(e) {
	                        logger.debug("performVideoStartWorkaround: second setRemoteDescription failed!!" + e);
	                        _utils.callFunctionIfExist(onFail, "performVideoStartWorkaround: second setRemoteDescription failed!!");
	                    });
	            },
	            function pvswFirstSetRemoteDescriptionFailureCallback(e) {
	                logger.debug("performVideoStartWorkaround: first setRemoteDescription failed!!" + e);
	                _utils.callFunctionIfExist(onFail, "performVideoStartWorkaround: first setRemoteDescription failed!!");
	            });
	    };

	    /*
	     * Native implementation lies on webRtcAdaptor.js
	     */
	    self.getUserMedia = function(params) {
	        self.getRtcLibrary().checkMediaSourceAvailability(function mediaSourceCallback(mediaSourceInfo) {
	            var mediaInfo, mediaStreamSource, constraints = {
	                    audio: false,
	                    video: false
	                },
	                localMedia;
	            self.setMediaSources(mediaSourceInfo);

	            if (mediaSourceInfo) {
	                if (!mediaSourceInfo.audioSourceAvailable) {
	                    logger.debug("Failed to get access to local media.");
	                    _utils.callFunctionIfExist(params.onFailure, _mediaErrors.NOT_FOUND);
	                    return;
	                }
	            }

	            if (self.getMediaVideo() && self.getVideoSourceAvailable()) {
	                constraints.video = params.options.videoConstraints;
	            }
	            if (self.getMediaAudio() && self.getAudioSourceAvailable()) {
	                constraints.audio = params.options.audioConstraints;
	            }

	            logger.debug("getUserMedia - constraints: ", constraints);
	            self.getRtcLibrary().getUserMedia(constraints, function getUserMediaSuccessCallback(stream) {
	                self.initAudioContext();
	                mediaStreamSource = self.getAudioContext().createMediaStreamSource(stream);
	                self.initMediaStreamDestination();
	                mediaStreamSource.connect(self.getMediaStreamDestination());

	                if (stream.getVideoTracks() && stream.getVideoTracks()[zero]) {
	                    self.getMediaStreamDestination().stream.addTrack(stream.getVideoTracks()[zero]);
	                }

	                localMedia = {
	                    audioContext: self.getAudioContext(),
	                    mediaStreamDestination: self.getMediaStreamDestination(),
	                    stream: self.getMediaStreamDestination().stream,
	                    originalStream: stream
	                };
	                self.setLocalMedia(localMedia);
	                self.getLocalStreamMap().add(localMedia.stream.id, localMedia);
	                self.setInitialized(true);

	                mediaInfo = {
	                    audio: self.getMediaAudio(),
	                    video: self.getMediaVideo(),
	                    id: localMedia.stream.id,
	                    originalStream: stream,
	                    streamURL: self.getRtcLibrary().getURLFromStream(stream)
	                };

	                logger.debug("user has granted access to local media: ", localMedia);
	                _utils.callFunctionIfExist(params.onSuccess, mediaInfo);
	            }, function getUserMediaFailureCallback(error) {
	                logger.debug("Failed to get access to local media. Error code was " + error.code);
	                _utils.callFunctionIfExist(params.onFailure, _mediaErrors.NOT_ALLOWED);
	            });
	        });
	    };

	    self.replaceVideoStream = function(newStream) {
	        var mediaStreamDestination = self.getMediaStreamDestination(),
	            mediaStream,
	            mediaStreamId,
	            videoTracks,
	            i = 0;

	        if (mediaStreamDestination) {
	            mediaStream = mediaStreamDestination.stream;
	            if (mediaStream) {
	                mediaStreamId = mediaStream.id;
	                videoTracks = mediaStream.getVideoTracks();
	                for (; i < videoTracks.length; ++i) {
	                    mediaStream.removeTrack(videoTracks[i]);
	                }

	                if (newStream && newStream.getVideoTracks() && newStream.getVideoTracks()[zero]) {
	                    mediaStream.addTrack(newStream.getVideoTracks()[zero]);
	                }
	            }
	        }

	        return {
	            audio: self.getMediaAudio(),
	            video: self.getMediaVideo(),
	            id: mediaStreamId
	        };
	    };

	    /*
	     * Native implementation lies on webRtcAdaptor.js
	     */
	    self.startScreenMedia = function(onSuccess, onFailure, onEnded) {
	        self.getRtcLibrary().checkMediaSourceAvailability(function mediaSourceCallback(mediaSourceInfo) {
	            var video_constraints;
	            self.setMediaSources(mediaSourceInfo);
	            if (self.getScreenSourceAvailable()) {
	                video_constraints = {
	                    mandatory: {
	                        "maxFrameRate": self.getScreenFrameRate(),
	                        "maxWidth": self.getScreenWidth(),
	                        "maxHeight": self.getScreenHeight()
	                    }
	                };

	                self.getRtcLibrary().getScreenMedia({
	                    video: video_constraints
	                }, function(stream) {
	                    var mediaInfo = self.replaceVideoStream(stream),
	                        oldStream = self.getScreenStream();

	                    // If there is an old screen stream, just stop it but prevent the stop from happening
	                    if (oldStream) {
	                        oldStream.onended = null;
	                        self.getRtcLibrary().stopStream(oldStream);
	                    }

	                    stream.onended = onEnded;
	                    self.setScreenStream(stream);

	                    logger.debug("user granted access to local media.");
	                    utils.callFunctionIfExist(onSuccess, mediaInfo);

	                }, function() {
	                    logger.debug("Failed to get access to screen media.");
	                    utils.callFunctionIfExist(onFailure, fcs.call.MediaErrors.NOT_ALLOWED);
	                }, onEnded);
	            } else {
	                utils.callFunctionIfExist(onFailure, fcs.call.MediaErrors.NOT_FOUND);
	            }
	        });
	    };

	    self.stopScreenMedia = function() {
	        var screenStream = self.getScreenStream();

	        self.replaceVideoStream(self.getLocalMedia().originalStream);

	        if (screenStream) {
	            self.getRtcLibrary().stopStream(screenStream);
	            self.setScreenStream(null);
	        }
	    };

	    self.createDataChannelOffer = function(call, successCallback, failureCallback, sendInitialVideo, mandatorySettings) {
	        logger.debug("createOffer: sendInitialVideo= " + sendInitialVideo + " state= " + call.peer.signalingState);
	        var peer = call.peer;

	        if (!mandatorySettings) {
	            mandatorySettings = {
	                'mandatory': {
	                    'OfferToReceiveAudio': self.getMediaAudio(),
	                    'OfferToReceiveVideo': self.getMediaVideo()
	                }
	            };
	        }

	        peer.createOffer(
	            function createOfferSuccessCallback(oSdp) {
	                peer.setLocalDescription(
	                    self.getRtcLibrary().createRTCSessionDescription(CONSTANTS.WEBRTC.RTC_SDP_TYPE.OFFER, oSdp.sdp),
	                    function createOfferSetLocalDescriptionSuccessCallback() {
	                        //Due to stun requests, successCallback will be called by onNativeIceCandidate()
	                    },
	                    function createOfferSetLocalDescriptionFailureCallback(error) {
	                        logger.error("createOffer: setLocalDescription failed : " + error);
	                        _utils.callFunctionIfExist(failureCallback, "createOffer: setLocalDescription failed");
	                    });
	            },
	            function createOfferFailureCallback(e) {
	                logger.error("createOffer: createOffer failed!! " + e);
	                _utils.callFunctionIfExist(failureCallback);
	            }, mandatorySettings);
	    };

	    // createNativeOffer, Native implementation lies on webRtcAdaptor.js
	    self.createOffer = function(call, successCallback, failureCallback, sendInitialVideo) {
	        logger.debug("createOffer: sendInitialVideo= " + sendInitialVideo + " state= " + call.peer.signalingState);
	        var peer = call.peer;

	        call.peer.addStream(call.localMedia.stream);

	        peer.createOffer(
	            function createOfferSuccessCallback(oSdp) {
	                sendInitialVideo = sendInitialVideo && self.getVideoSourceAvailable();
	                if (sendInitialVideo) {
	                    oSdp.sdp = _sdpParser.updateVideoSdpDirection(oSdp.sdp, CONSTANTS.WEBRTC.MEDIA_STATE.SEND_RECEIVE);
	                } else {
	                    oSdp.sdp = _sdpParser.updateVideoSdpDirection(oSdp.sdp, CONSTANTS.WEBRTC.MEDIA_STATE.RECEIVE_ONLY);
	                }

	                oSdp.sdp = _sdpParser.deleteCryptoZeroFromSdp(oSdp.sdp);

	                oSdp.sdp = _sdpParser.removeG722Codec(oSdp.sdp);

	                oSdp.sdp = _sdpParser.deleteCryptoFromSdp(oSdp.sdp, self.isDtlsEnabled());
	                oSdp.sdp = _sdpParser.setTcpSetupAttributeToActpass(oSdp.sdp, self.isDtlsEnabled());

	                oSdp.sdp = self.updateCodecs(call, oSdp.sdp);

	                peer.setLocalDescription(
	                    self.getRtcLibrary().createRTCSessionDescription(CONSTANTS.WEBRTC.RTC_SDP_TYPE.OFFER, oSdp.sdp),
	                    function createOfferSetLocalDescriptionSuccessCallback() {
	                        //Due to stun requests, successCallback will be called by onNativeIceCandidate()
	                    },
	                    function createOfferSetLocalDescriptionFailureCallback(error) {
	                        logger.error("createOffer: setLocalDescription failed : " + error);
	                        _utils.callFunctionIfExist(failureCallback, "createOffer: setLocalDescription failed");
	                    });
	            },
	            function createOfferFailureCallback(e) {
	                logger.error("createOffer: createOffer failed!! " + e);
	                _utils.callFunctionIfExist(failureCallback);
	            }, self.getRtcLibrary().createConstraints(self.getMediaAudio(), self.getMediaVideo()));
	    };

	    /*
	     *  Native implementation lies on webRtcAdaptor.js
	     *  createNativeAnswer to be used when native webrtc is enabled.
	     *  @param {type} call
	     *  @param {type} successCallback
	     *  @param {type} failureCallback
	     *  @param {type} isVideoEnabled
	     */
	    self.createAnswer = function(call, successCallback, failureCallback, isVideoEnabled) {
	        logger.debug("createAnswer: isVideoEnabled= " + isVideoEnabled + " state= " + call.peer.signalingState);
	        var peer = call.peer;

	        call.peer.addStream(call.localMedia.stream);
	        call.sdp = _sdpParser.checkSupportedVideoCodecs(call.sdp, null, self.isH264Enabled());
	        call.sdp = _sdpParser.changeDirection(call.sdp, CONSTANTS.WEBRTC.MEDIA_STATE.INACTIVE, CONSTANTS.WEBRTC.MEDIA_STATE.SEND_RECEIVE, CONSTANTS.STRING.AUDIO);
	        call.sdp = _sdpParser.deleteFingerprintOrCrypto(call.sdp, self.isDtlsEnabled());

	        if (!_sdpParser.isSdpVideoSendEnabled(call.sdp)) {
	            // delete ssrc only from video, keep audio ssrc to hear audio
	            call.sdp = _sdpParser.deleteInactiveVideoSsrc(call.sdp);
	        }
	        self.setRemoteDescription(call, peer, CONSTANTS.WEBRTC.RTC_SDP_TYPE.OFFER, call.sdp,
	            function createAnswerSetRemoteDescriptionSuccessCallback() {
	                call.remoteVideoState = _sdpParser.getSdpDirection(call.sdp, CONSTANTS.STRING.VIDEO);

	                peer.createAnswer(
	                    function(oSdp) {
	                        isVideoEnabled = isVideoEnabled && self.getVideoSourceAvailable() && _sdpParser.isSdpHasVideo(call.sdp);

	                        if (isVideoEnabled) {
	                            if (_sdpParser.isSdpVideoSendEnabled(call.sdp)) {
	                                oSdp.sdp = _sdpParser.updateSdpDirection(oSdp.sdp, CONSTANTS.STRING.VIDEO, CONSTANTS.WEBRTC.MEDIA_STATE.SEND_RECEIVE);
	                            } else {
	                                if (_sdpParser.getVideoSdpDirection(call.sdp) !== CONSTANTS.WEBRTC.MEDIA_STATE.INACTIVE) {
	                                    oSdp.sdp = _sdpParser.updateSdpDirection(oSdp.sdp, CONSTANTS.STRING.VIDEO, CONSTANTS.WEBRTC.MEDIA_STATE.SEND_ONLY);
	                                } else {
	                                    oSdp.sdp = _sdpParser.updateSdpDirection(oSdp.sdp, CONSTANTS.STRING.VIDEO, CONSTANTS.WEBRTC.MEDIA_STATE.INACTIVE);
	                                }
	                            }
	                        } else {
	                            if (_sdpParser.isSdpVideoSendEnabled(call.sdp)) {
	                                oSdp.sdp = _sdpParser.updateSdpDirection(oSdp.sdp, CONSTANTS.STRING.VIDEO, CONSTANTS.WEBRTC.MEDIA_STATE.RECEIVE_ONLY);
	                            } else {
	                                oSdp.sdp = _sdpParser.updateSdpDirection(oSdp.sdp, CONSTANTS.STRING.VIDEO, CONSTANTS.WEBRTC.MEDIA_STATE.INACTIVE);
	                            }
	                        }

	                        self.muteOnHold(call, false);

	                        // createAnswer generates an sdp without ice params
	                        // copy ice params to the local sdp
	                        // scenario: incoming video call from pcc in brokeronly config
	                        oSdp.sdp = _sdpParser.checkAndRestoreICEParams(oSdp.sdp, call.sdp);

	                        peer.setLocalDescription(
	                            self.getRtcLibrary().createRTCSessionDescription(CONSTANTS.WEBRTC.RTC_SDP_TYPE.ANSWER, oSdp.sdp),
	                            function createAnswerSetLocalDescriptionSuccessCallback() {
	                                //Due to stun requests, successCallback will be called by onNativeIceCandidate()
	                            },
	                            function createAnswerSetLocalDescriptionFailureCallback(e) {
	                                logger.error("createAnswer: setLocalDescription failed : " + e);
	                                _utils.callFunctionIfExist(failureCallback, "createNativeAnswer setLocalDescription failed");
	                            });
	                    },
	                    function createAnswerFailureCallback(e) {
	                        logger.error("createAnswer: failed!! Error: " + e);
	                        _utils.callFunctionIfExist(failureCallback, "Session cannot be created");
	                    }, self.getRtcLibrary().createConstraints(self.getMediaAudio(), self.getMediaVideo()));
	            },
	            function createAnswerSetRemoteDescriptionFailureCallback(e) {
	                logger.error("createAnswer: setremotedescription failed!! Error: " + e);
	            });
	    };

	    /*
	     * Native implementation lies on webRtcAdaptor.js
	     * createNativeUpdate to be used when the video start or stop
	     */
	    self.createUpdate = function(call, successCallback, failureCallback, isVideoStart, useIceServer) {
	        logger.debug("createUpdate: isVideoStart= " + isVideoStart + " state= " + call.peer.signalingState);
	        var peer = call.peer,
	            localDesc, localSdp = call.stableLocalSdp;

	        if (self.createNewPeerForCall({
	                call: call,
	                mustCreatePeer: call.isRemoteEndFirefox,
	                useIceServer: useIceServer
	            })) {
	            peer = call.peer;
	        }
	        self.getRtcLibrary().updateStream(peer, call);

	        peer.createOffer(function createUpdateCreateOfferSuccessCallback(obj) {
	            isVideoStart = isVideoStart && self.getVideoSourceAvailable();
	            if (isVideoStart) {
	                obj.sdp = _sdpParser.updateVideoSdpDirection(obj.sdp, CONSTANTS.WEBRTC.MEDIA_STATE.SEND_RECEIVE);
	            } else {
	                if (_sdpParser.isVideoSdpDirectionInactive(call.stableRemoteSdp)) {
	                    obj.sdp = _sdpParser.updateVideoSdpDirectionToInactive(obj.sdp);
	                } else {
	                    obj.sdp = _sdpParser.updateVideoSdpDirection(obj.sdp, CONSTANTS.WEBRTC.MEDIA_STATE.RECEIVE_ONLY);
	                }
	            }
	            obj.sdp = self.updateCodecs(call, obj.sdp);

	            if ((_sdpParser.isIceLite(call.sdp) && self.isVideoDirectionsSendRecv(peer.localDescription.sdp, peer.remoteDescription.sdp)) &&
	                !call.isRemoteEndFirefox &&
	                !self.iceCredentialsChanged(localSdp, obj.sdp)) {
	                logger.debug("createUpdate new solution ");
	                successCallback(obj.sdp);
	            } else {
	                logger.debug("createUpdate old solution ");

	                obj.sdp = _sdpParser.updateVersion(localSdp, obj.sdp);
	                obj.sdp = _sdpParser.setTcpSetupAttributeToActpass(obj.sdp, self.isDtlsEnabled());
	                obj.sdp = _sdpParser.deleteCryptoZeroFromSdp(obj.sdp);
	                obj.sdp = _sdpParser.removeG722Codec(obj.sdp);
	                obj.sdp = _sdpParser.deleteCryptoFromSdp(obj.sdp, self.isDtlsEnabled());

	                localDesc = self.getRtcLibrary().createRTCSessionDescription(CONSTANTS.WEBRTC.RTC_SDP_TYPE.OFFER, obj.sdp);

	                peer.setLocalDescription(localDesc, function createUpdateCreateOfferSetLocalDescriptionSuccessCallback() {
	                    logger.debug("createUpdate setLocalDescription success. iceConnectionState: " + peer.iceConnectionState + " iceGatheringState: " + peer.iceGatheringState);
	                    if (peer.iceGatheringState === "complete") {
	                        if (call.successCallback) {
	                            logger.debug("createUpdate iceGatheringState completed " + peer.localDescription.sdp);
	                            _utils.callFunctionIfExist(successCallback, peer.localDescription.sdp);
	                        }
	                    }
	                }, function crateUpdateCreateOfferSetLocalDescriptionFailureCallback(e) {
	                    logger.debug("createUpdate: createOffer setLocalDescription failed: " + e);
	                    _utils.callFunctionIfExist(failureCallback);
	                });
	            }
	        }, function createUpdateCrateOfferFailureCallback(e) {
	            logger.debug("createUpdate: createOffer failed!!: " + e);
	            failureCallback();
	        }, self.getRtcLibrary().createConstraints(self.getMediaAudio(), self.getMediaVideo()));
	    };

	    /*
	     * Reverts RTC engine's state
	     */
	    self.revertRtcState = function(call, successCallback, failureCallback) {
	        var peer = call.peer,
	            obj, localSdp = call.stableLocalSdp,
	            remoteSdp = call.stableRemoteSdp,
	            rtcState = peer.signalingState;
	        remoteSdp = _sdpParser.deleteGoogleIceFromSdp(remoteSdp);
	        switch (rtcState) {
	            case CONSTANTS.WEBRTC.RTC_SIGNALING_STATE.STABLE:
	            case CONSTANTS.WEBRTC.RTC_SIGNALING_STATE.HAVE_LOCAL_OFFER:
	                localSdp = _sdpParser.setTcpSetupAttributeToActpass(localSdp, self.isDtlsEnabled());
	                obj = self.getRtcLibrary().createRTCSessionDescription(CONSTANTS.WEBRTC.RTC_SDP_TYPE.OFFER, localSdp);
	                peer.setLocalDescription(obj,
	                    function revertRtcStateLocalDescriptionSuccessCallback() {
	                        logger.debug("revertRtcState[stable|local_offer]: setLocalDescription success");
	                        remoteSdp = _sdpParser.setTcpSetupAttributeTo(remoteSdp, call.remoteTcpSetupAttribute, self.isDtlsEnabled());
	                        self.setRemoteDescription(call, peer, CONSTANTS.WEBRTC.RTC_SDP_TYPE.ANSWER, remoteSdp,
	                            function revertRtcStateRemoteDescriptionSuccessCallback() {
	                                logger.debug("revertRtcState[stable|local_offer]: setRemoteDescription success");
	                                if (peer.iceGatheringState === "complete") {
	                                    _utils.callFunctionIfExist(successCallback);
	                                }
	                            },
	                            function revertRtcStateRemoteDescriptionFailureCallback(error) {
	                                logger.error("revertRtcState[stable|local_offer]: setRemoteDescription failed: " + error);
	                                _utils.callFunctionIfExist(failureCallback, call);
	                            });
	                    },
	                    function revertRtcStateLocalDescriptionFailureCallback(error) {
	                        logger.error("revertRtcState[stable|local_offer]: setLocalDescription failed: " + error);
	                        _utils.callFunctionIfExist(failureCallback, call);
	                    });
	                break;
	            case CONSTANTS.WEBRTC.RTC_SIGNALING_STATE.HAVE_REMOTE_OFFER:
	                remoteSdp = _sdpParser.setTcpSetupAttributeToActpass(remoteSdp, self.isDtlsEnabled());
	                self.setRemoteDescription(call, peer, CONSTANTS.WEBRTC.RTC_SDP_TYPE.OFFER, remoteSdp,
	                    function revertRtcStateRemoteDescriptionSuccessCallback() {
	                        logger.debug("revertRtcState[remote_offer]: setLocalDescription success");
	                        localSdp = _sdpParser.setTcpSetupAttributeTo(localSdp, call.localTcpSetupAttribute, self.isDtlsEnabled());
	                        obj = self.getRtcLibrary().createRTCSessionDescription(CONSTANTS.WEBRTC.RTC_SDP_TYPE.ANSWER, localSdp);
	                        peer.setLocalDescription(obj,
	                            function revertRtcStateLocalDescriptionSuccessCallback() {
	                                logger.debug("revertRtcState[remote_offer]: setRemoteDescription success");
	                                if (peer.iceGatheringState === "complete") {
	                                    _utils.callFunctionIfExist(successCallback);
	                                }
	                            },
	                            function revertRtcStateLocalDescriptionFailureCallback(error) {
	                                logger.error("revertRtcState[remote_offer]: setRemoteDescription failed: " + error);
	                                _utils.callFunctionIfExist(failureCallback, call);
	                            });
	                    },
	                    function revertRtcStateRemoteDescriptionFailureCallback(error) {
	                        logger.error("revertRtcState[remote_offer]: setLocalDescription failed: " + error);
	                        _utils.callFunctionIfExist(failureCallback, call);
	                    });
	                break;
	            default:
	                logger.debug("revertRtcState: not applicible for state: " + rtcState);
	        }
	    };

	    /*
	     * Native implementation lies on webRtcAdaptor.js
	     * createNativeHoldUpdate to be used when native webrtc is enabled
	     */
	    self.createHoldUpdate = function(call, hold, remote_hold_status, successCallback, failureCallback, useIceServer) {
	        logger.debug("createHoldUpdate: local hold= " + hold + " remote hold= " + remote_hold_status + " state= " + call.peer.signalingState);
	        var peer = call.peer,
	            localDescObj,
	            localSdp;

	        localSdp = call.stableLocalSdp;

	        if (self.createNewPeerForCall({
	                call: call,
	                mustCreatePeer: call.isRemoteEndFirefox,
	                useIceServer: useIceServer
	            })) {
	            peer = call.peer;
	        }

	        peer.createOffer(function createHoldUpdateCreateOfferSuccessCallback(obj) {

	            if (hold) {
	                if (!remote_hold_status) {
	                    obj.sdp = _sdpParser.updateAudioSdpDirection(obj.sdp, CONSTANTS.WEBRTC.MEDIA_STATE.SEND_ONLY);
	                    obj.sdp = _sdpParser.updateVideoSdpDirection(obj.sdp, CONSTANTS.WEBRTC.MEDIA_STATE.SEND_ONLY);
	                } else {
	                    obj.sdp = _sdpParser.updateAudioSdpDirectionToInactive(obj.sdp);
	                    obj.sdp = _sdpParser.updateVideoSdpDirectionToInactive(obj.sdp);
	                }
	            } else if (remote_hold_status) {
	                obj.sdp = _sdpParser.updateAudioSdpDirection(obj.sdp, CONSTANTS.WEBRTC.MEDIA_STATE.SEND_RECEIVE);
	                obj.sdp = _sdpParser.updateVideoSdpDirection(obj.sdp, CONSTANTS.WEBRTC.MEDIA_STATE.SEND_RECEIVE);
	            } else {
	                obj.sdp = _sdpParser.updateAudioSdpDirection(obj.sdp, CONSTANTS.WEBRTC.MEDIA_STATE.SEND_RECEIVE);
	                if (self.canOriginatorSendLocalVideo(call)) {
	                    obj.sdp = _sdpParser.updateVideoSdpDirection(obj.sdp, CONSTANTS.WEBRTC.MEDIA_STATE.SEND_RECEIVE);
	                } else {
	                    obj.sdp = _sdpParser.updateVideoSdpDirection(obj.sdp, CONSTANTS.WEBRTC.MEDIA_STATE.RECEIVE_ONLY);
	                }
	            }
	            obj.sdp = self.updateCodecs(call, obj.sdp);

	            if ((_sdpParser.isIceLite(call.sdp) && self.isSdpDirectionsSendRecv(peer.localDescription.sdp, peer.remoteDescription.sdp)) &&
	                !call.isRemoteEndFirefox &&
	                !self.iceCredentialsChanged(localSdp, obj.sdp)) {
	                logger.debug("createHoldUpdate new solution ");
	                _utils.callFunctionIfExist(successCallback, obj.sdp);
	            } else {
	                logger.debug("createHoldUpdate old solution ");

	                obj.sdp = _sdpParser.updateVersion(localSdp, obj.sdp);
	                obj.sdp = _sdpParser.deleteCryptoZeroFromSdp(obj.sdp);
	                obj.sdp = _sdpParser.setTcpSetupAttributeToActpass(obj.sdp, self.isDtlsEnabled());

	                //ABE-11044 workaround. Remove after Chrome 51 release.
	                obj.sdp = _sdpParser.checkandReplaceAPTValue(obj.sdp);

	                localDescObj = self.getRtcLibrary().createRTCSessionDescription(CONSTANTS.WEBRTC.RTC_SDP_TYPE.OFFER, obj.sdp);

	                peer.setLocalDescription(localDescObj, function createHoldUpdateSetLocalDescriptionSuccessCallback() {
	                    logger.debug("createHoldUpdate setLocalDescription success. iceConnectionState: " + peer.iceConnectionState + " iceGatheringState: " + peer.iceGatheringState);
	                    if (peer.iceGatheringState === "complete") {
	                        if (call.successCallback) {
	                            logger.debug("createHoldUpdate iceGatheringState completed " + peer.localDescription.sdp);
	                            _utils.callFunctionIfExist(successCallback, peer.localDescription.sdp);
	                        }
	                    }
	                }, function createHoldUpdateSetLocalDescriptionFailureCallback(error) {
	                    logger.error("createHoldUpdate: setLocalDescription failed: " + error.message);
	                    _utils.callFunctionIfExist(failureCallback);
	                });
	            }
	        }, function createHoldUpdateCreateOfferFailureCallback(error) {
	            logger.error("createHoldUpdate: createOffer failed: " + error.message);
	            _utils.callFunctionIfExist(failureCallback);
	        }, self.getRtcLibrary().createConstraints(self.getMediaAudio(), self.getMediaVideo()));
	    };

	    // Native implementation lies on webRtcAdaptor.js
	    // processNativeHold
	    self.processHold = function(call, hold, local_hold_status, successCallback, failureCallback, useIceServer) {
	        logger.debug("processHold: local hold= " + local_hold_status + " remote hold= " + hold + " state= " + call.peer.signalingState);
	        var peer = call.peer,
	            audioDirection, videoDirection,
	            peerRemoteSdp, peerLocalSdp, inactiveRemoteSdp, data;
	        peerLocalSdp = call.stableLocalSdp;

	        audioDirection = _sdpParser.getAudioSdpDirection(call.sdp);
	        videoDirection = _sdpParser.getVideoSdpDirection(call.sdp);

	        if ((_sdpParser.isIceLite(call.sdp) && self.isSdpDirectionsSendRecv(peer.localDescription.sdp, peer.remoteDescription.sdp)) &&
	            !call.isRemoteEndFirefox &&
	            !self.oldSolutionNeeded(call.prevRemoteSdp, call.sdp)) {
	            logger.debug("processHold  new solution");
	            if (hold) {
	                logger.debug("processHold: Remote HOLD");
	                peerLocalSdp = _sdpParser.respondToRemoteSdpDirections(peerLocalSdp, call.sdp);
	                self.muteOnHold(call, true);
	            } else if (!local_hold_status) {
	                logger.debug("processHold: Remote UNHOLD: direction left as it is");

	                if (_sdpParser.isSdpVideoSendEnabled(call.sdp)) {
	                    if (self.canOriginatorSendLocalVideo(call)) {
	                        peerLocalSdp = _sdpParser.updateVideoSdpDirection(peerLocalSdp, CONSTANTS.WEBRTC.MEDIA_STATE.SEND_RECEIVE);
	                    } else {
	                        peerLocalSdp = _sdpParser.updateVideoSdpDirection(peerLocalSdp, CONSTANTS.WEBRTC.MEDIA_STATE.RECEIVE_ONLY);
	                    }
	                } else {
	                    if (self.canOriginatorSendLocalVideo(call) && !_sdpParser.isVideoSdpDirectionInactive(call.sdp)) {
	                        peerLocalSdp = _sdpParser.updateVideoSdpDirection(peerLocalSdp, CONSTANTS.WEBRTC.MEDIA_STATE.SEND_ONLY);
	                    } else {
	                        peerLocalSdp = _sdpParser.updateVideoSdpDirection(peerLocalSdp, CONSTANTS.WEBRTC.MEDIA_STATE.INACTIVE);
	                    }
	                }
	                //change audio's direction to sendrecv for ssl attendees in a 3wc
	                peerLocalSdp = _sdpParser.changeDirection(peerLocalSdp, CONSTANTS.WEBRTC.MEDIA_STATE.RECEIVE_ONLY, CONSTANTS.WEBRTC.MEDIA_STATE.SEND_RECEIVE, CONSTANTS.STRING.AUDIO);
	                self.muteOnHold(call, false);
	            } else if (local_hold_status && !hold) {
	                logger.debug("processHold: Remote UNHOLD on local hold");

	                if (audioDirection === CONSTANTS.WEBRTC.MEDIA_STATE.INACTIVE) {
	                    peerLocalSdp = _sdpParser.updateAudioSdpDirectionToInactive(peerLocalSdp);
	                } else {
	                    peerLocalSdp = _sdpParser.updateAudioSdpDirection(peerLocalSdp, CONSTANTS.WEBRTC.MEDIA_STATE.SEND_ONLY);
	                }

	                if (self.canOriginatorSendLocalVideo(call)) {
	                    peerLocalSdp = _sdpParser.updateVideoSdpDirection(peerLocalSdp, CONSTANTS.WEBRTC.MEDIA_STATE.SEND_ONLY);
	                } else {
	                    peerLocalSdp = _sdpParser.updateVideoSdpDirectionToInactive(peerLocalSdp);
	                }
	                self.muteOnHold(call, true);
	            }
	            self.setRemoteDescription(call, null, null, call.sdp);
	            peerLocalSdp = _sdpParser.setTcpSetupAttributeTo(peerLocalSdp, call.localTcpSetupAttribute, self.isDtlsEnabled());
	            _utils.callFunctionIfExist(successCallback, peerLocalSdp);
	        } else {
	            logger.debug("processHold  old solution");

	            if (!local_hold_status && !hold) {
	                self.muteOnHold(call, false);
	            }
	            call.sdp = _sdpParser.setTcpSetupAttributeToActpass(call.sdp, self.isDtlsEnabled());

	            // This is required for PCC and meetme with video.
	            // PCC and meetme(Media Server) not supperted VP8/VP9 codec.
	            // so video calls can not be established
	            // local video should be set to false
	            if (!(_sdpParser.isVideoCodecsSupported(call.sdp, self.isH264Enabled())) && !(_sdpParser.isSdpHasVP8Codec(call.sdp)) && (call.sdp.indexOf(CONSTANTS.SDP.M_LINE + CONSTANTS.STRING.VIDEO + " 0 ", 0) === -1)) {
	                self.setOriginatorSendLocalVideo(call, false);
	            }

	            call.sdp = _sdpParser.checkSupportedVideoCodecs(call.sdp, null, self.isH264Enabled());

	            call.sdp = _sdpParser.performVideoPortZeroWorkaround(call.sdp);
	            call.sdp = _sdpParser.checkAndRestoreICEParams(call.sdp, peerLocalSdp);

	            peerRemoteSdp = call.prevRemoteSdp;

	            // chrome38 fix
	            inactiveRemoteSdp = _sdpParser.updateAudioSdpDirectionToInactive(call.sdp);
	            inactiveRemoteSdp = _sdpParser.updateVideoSdpDirectionToInactive(inactiveRemoteSdp);

	            data = {
	                call: call,
	                mustCreatePeer: call.isRemoteEndFirefox,
	                oldSdp: call.prevRemoteSdp,
	                newSdp: call.sdp,
	                useIceServer: useIceServer
	            };
	            if (self.createNewPeerForCall(data)) {
	                peer = call.peer;
	            }

	            if (_sdpParser.isSdpHasVideo(call.prevRemoteSdp) && (!_sdpParser.isSdpHasVideo(call.sdp))) {
	                self.setOriginatorSendLocalVideo(call, call.sdp, false);
	            }

	            inactiveRemoteSdp = _sdpParser.deleteSsrcFromSdp(inactiveRemoteSdp);

	            // 1st setRemoteDescription to make webrtc remove the audio and/or video streams
	            // 2nd setRemote will add the audio stream back so that services like MOH can work
	            // This code will also run in UnHold scenario, and it will remove & add video stream
	            self.setRemoteDescription(call, peer, CONSTANTS.WEBRTC.RTC_SDP_TYPE.OFFER, inactiveRemoteSdp, function processHoldSetFirstRemoteDescriptionSuccessCallback() {
	                call.sdp = _sdpParser.updateAudioSdpDirection(call.sdp, CONSTANTS.WEBRTC.MEDIA_STATE.SEND_RECEIVE);
	                //updateSdp.sdp = updateSdpDirection(updateSdp.sdp, video, videoDirection);

	                if (_sdpParser.getVideoSdpDirection(call.sdp) === CONSTANTS.WEBRTC.MEDIA_STATE.INACTIVE ||
	                    _sdpParser.getVideoSdpDirection(call.sdp) === CONSTANTS.WEBRTC.MEDIA_STATE.RECEIVE_ONLY) {
	                    call.sdp = _sdpParser.deleteInactiveVideoSsrc(call.sdp);
	                }
	                self.setRemoteDescription(call, peer, CONSTANTS.WEBRTC.RTC_SDP_TYPE.OFFER, call.sdp, function processHoldSetSecondRemoteDescriptionSuccessCallback() {
	                    if (!hold && !local_hold_status && (videoDirection === CONSTANTS.WEBRTC.MEDIA_STATE.INACTIVE)) {
	                        call.remoteVideoState = CONSTANTS.WEBRTC.MEDIA_STATE.RECEIVE_ONLY;
	                    } else {
	                        call.remoteVideoState = _sdpParser.getVideoSdpDirection(call.sdp);
	                    }
	                    peer.createAnswer(function processHoldCreateAnswerSuccessCallback(obj) {
	                        logger.debug("processHold: isSdpEnabled audio= " + _sdpParser.isAudioSdpEnabled(obj.sdp));
	                        logger.debug("processHold: isSdpEnabled video= " + _sdpParser.isVideoSdpEnabled(obj.sdp));

	                        if (hold) {
	                            logger.debug("processHold: Remote HOLD");
	                            obj.sdp = _sdpParser.respondToRemoteSdpDirections(obj.sdp, call.sdp);
	                        } else if (!local_hold_status) {
	                            logger.debug("processHold: Remote UNHOLD: direction left as it is");

	                            if (_sdpParser.isSdpVideoSendEnabled(call.sdp)) {
	                                if (self.canOriginatorSendLocalVideo(call)) {
	                                    obj.sdp = _sdpParser.updateVideoSdpDirection(obj.sdp, CONSTANTS.WEBRTC.MEDIA_STATE.SEND_RECEIVE);
	                                } else {
	                                    obj.sdp = _sdpParser.updateVideoSdpDirection(obj.sdp, CONSTANTS.WEBRTC.MEDIA_STATE.RECEIVE_ONLY);
	                                }
	                            } else {
	                                if (self.canOriginatorSendLocalVideo(call) && !_sdpParser.isVideoSdpDirectionInactive(call.sdp)) {
	                                    obj.sdp = _sdpParser.updateVideoSdpDirection(obj.sdp, CONSTANTS.WEBRTC.MEDIA_STATE.SEND_ONLY);
	                                } else {
	                                    obj.sdp = _sdpParser.updateVideoSdpDirection(obj.sdp, CONSTANTS.WEBRTC.MEDIA_STATE.INACTIVE);
	                                }
	                            }
	                            //change audio's direction to sendrecv for ssl attendees in a 3wc
	                            obj.sdp = _sdpParser.changeDirection(obj.sdp, CONSTANTS.WEBRTC.MEDIA_STATE.RECEIVE_ONLY, CONSTANTS.WEBRTC.MEDIA_STATE.SEND_RECEIVE, CONSTANTS.STRING.AUDIO);
	                        } else if (local_hold_status && !hold) {
	                            logger.debug("processHold: Remote UNHOLD on local hold");

	                            if (audioDirection === CONSTANTS.WEBRTC.MEDIA_STATE.INACTIVE) {
	                                obj.sdp = _sdpParser.updateAudioSdpDirectionToInactive(obj.sdp);
	                            } else {
	                                obj.sdp = _sdpParser.updateAudioSdpDirection(obj.sdp, CONSTANTS.WEBRTC.MEDIA_STATE.SEND_ONLY);
	                            }

	                            if (self.canOriginatorSendLocalVideo(call)) {
	                                obj.sdp = _sdpParser.updateVideoSdpDirection(obj.sdp, CONSTANTS.WEBRTC.MEDIA_STATE.SEND_ONLY);
	                            } else {
	                                obj.sdp = _sdpParser.updateVideoSdpDirectionToInactive(obj.sdp);
	                            }
	                        }

	                        obj.sdp = _sdpParser.updateVersion(peerLocalSdp, obj.sdp);
	                        obj.sdp = _sdpParser.checkIceParamsLengths(obj.sdp, call.sdp);
	                        obj.sdp = _sdpParser.checkAndRestoreICEParams(obj.sdp, call.sdp);
	                        if (_sdpParser.isSdpHasVideoWithZeroPort(obj.sdp) && self.getDefaultVideoContainer()) {
	                            self.useDefaultRenderer(false, false, false);
	                        }

	                        obj.sdp = _sdpParser.setTcpSetupAttributeTo(obj.sdp, call.localTcpSetupAttribute, self.isDtlsEnabled());

	                        peer.setLocalDescription(obj, function processHoldSetLocalDescriptionSuccessCallback() {
	                            logger.debug("processHold: setLocalDescription success!! " + "iceConnectionState: " + peer.iceConnectionState + " iceGatheringState: " + peer.iceGatheringState);
	                            if (peer.iceGatheringState === "complete") {
	                                if (call.successCallback) {
	                                    logger.debug("processHold iceGatheringState completed " + peer.localDescription.sdp);
	                                    _utils.callFunctionIfExist(successCallback, peer.localDescription.sdp);
	                                }
	                            }
	                        }, function processHoldSetLocalDescriptionFailureCallback(e) {
	                            logger.error("processHold: setLocalDescription failed!! " + e);
	                            _utils.callFunctionIfExist(failureCallback, "Session cannot be created");
	                        });
	                    }, function processHoldCreateAnswerFailureCallback(e) {
	                        logger.error("processHold: createAnswer failed!!: " + e);
	                        _utils.callFunctionIfExist(failureCallback, "Session cannot be created");
	                    }, self.getRtcLibrary().createConstraints(self.getMediaAudio(), self.getMediaVideo()));
	                }, function processHoldSetSecondRemoteDescriptionFailureCallback(e) {
	                    logger.error("processHold: second setRemoteDescription failed!! " + e);
	                    _utils.callFunctionIfExist(failureCallback, "Session cannot be created");
	                });
	            }, function processHoldSetFirstRemoteDescriptionFailureCallback(e) {
	                logger.debug("processHold: first setRemoteDescription failed!! " + e);
	                _utils.callFunctionIfExist(failureCallback, "Session cannot be created");
	            });
	        }
	    };

	    // Native implementation lies on webRtcAdaptor.js
	    // processNativeUpdate
	    self.processUpdate = function (call, successCallback, failureCallback, local_hold_status, useIceServer) {
	        logger.debug("processUpdate: state= " + call.peer.signalingState);
	        var peer = call.peer,
	                remoteAudioState, remoteVideoState, remoteVideoDirection, localVideoDirection, callSdpWithNoSsrc,
	                localDescObj, peerLocalSdp, remoteDescriptionMainProcess, data;
	        peerLocalSdp = call.stableLocalSdp;

	        if ((_sdpParser.isIceLite(call.sdp) && self.isVideoDirectionsSendRecv(peer.localDescription.sdp, peer.remoteDescription.sdp)) &&
	            !call.isRemoteEndFirefox &&
	            !self.oldSolutionNeeded(call.prevRemoteSdp, call.sdp)) {
	            logger.debug("processUpdate  new solution");

	            if (_sdpParser.isSdpVideoSendEnabled(call.sdp)) {
	                if (self.canOriginatorSendLocalVideo(call)) {
	                    peerLocalSdp = _sdpParser.updateVideoSdpDirection(peerLocalSdp, CONSTANTS.WEBRTC.MEDIA_STATE.SEND_RECEIVE);
	                } else {
	                    peerLocalSdp = _sdpParser.updateVideoSdpDirection(peerLocalSdp, CONSTANTS.WEBRTC.MEDIA_STATE.RECEIVE_ONLY);
	                }
	                if (self.getDefaultVideoContainer()) {
	                    self.useDefaultRenderer(false, false, true);
	                }
	            } else {
	                if (self.canOriginatorSendLocalVideo(call) && !_sdpParser.isVideoSdpDirectionInactive(call.sdp)) {
	                    peerLocalSdp = _sdpParser.updateVideoSdpDirection(peerLocalSdp, CONSTANTS.WEBRTC.MEDIA_STATE.SEND_ONLY);
	                } else {
	                    peerLocalSdp = _sdpParser.updateVideoSdpDirection(peerLocalSdp, CONSTANTS.WEBRTC.MEDIA_STATE.INACTIVE);
	                }
	                if (self.getDefaultVideoContainer()) {
	                    self.useDefaultRenderer(false, false, false);
	                }
	            }
	            self.setRemoteDescription(call, null, null, call.sdp);
	            peerLocalSdp = _sdpParser.setTcpSetupAttributeTo(peerLocalSdp, call.localTcpSetupAttribute, self.isDtlsEnabled());
	            _utils.callFunctionIfExist(successCallback, peerLocalSdp);
	        } else {
	            logger.debug("processUpdate  old solution");
	            // Meetme workaround
	            call.sdp = _sdpParser.addSdpMissingCryptoLine(call.sdp);

	            call.sdp = _sdpParser.checkAndRestoreICEParams(call.sdp, peerLocalSdp);

	            remoteVideoDirection = _sdpParser.getVideoSdpDirection(call.sdp);
	            localVideoDirection = _sdpParser.getVideoSdpDirection(peerLocalSdp);

	            self.setMediaVideo(_sdpParser.isSdpHasVideo(call.sdp));
	            if (remoteVideoDirection === CONSTANTS.WEBRTC.MEDIA_STATE.INACTIVE &&
	                    call.currentState === "COMPLETED") {
	                switch (call.remoteVideoState) {
	                    case CONSTANTS.WEBRTC.MEDIA_STATE.INACTIVE:
	                    case CONSTANTS.WEBRTC.MEDIA_STATE.RECEIVE_ONLY:
	                        call.sdp = _sdpParser.updateVideoSdpDirection(call.sdp, CONSTANTS.WEBRTC.MEDIA_STATE.SEND_RECEIVE);
	                        break;
	                    case CONSTANTS.WEBRTC.MEDIA_STATE.SEND_RECEIVE:
	                        call.sdp = _sdpParser.updateVideoSdpDirection(call.sdp, CONSTANTS.WEBRTC.MEDIA_STATE.RECEIVE_ONLY);
	                        break;
	                }
	            }

	            call.sdp = _sdpParser.changeDirection(call.sdp, CONSTANTS.WEBRTC.MEDIA_STATE.SEND_ONLY, CONSTANTS.WEBRTC.MEDIA_STATE.SEND_RECEIVE, CONSTANTS.STRING.VIDEO);

	            call.sdp = _sdpParser.checkSupportedVideoCodecs(call.sdp, null, self.isH264Enabled());
	            //this part is a work-around for webrtc bug
	            //set remote description with inactive media lines first.
	            //then set remote description with original media lines.

	            //keep original values of remote audio and video states
	            remoteAudioState = _sdpParser.getAudioSdpDirection(call.sdp);
	            remoteVideoState = _sdpParser.getVideoSdpDirection(call.sdp);

	            //This is highly required for meetme on DTLS
	            call.sdp = _sdpParser.setTcpSetupAttributeToActpass(call.sdp, self.isDtlsEnabled());

	            // delete all ssrc lines from the sdp before setting first remote description
	            // set second remote description with all ssrc lines included
	            if (remoteVideoState === CONSTANTS.WEBRTC.MEDIA_STATE.INACTIVE ||
	                    remoteVideoState === CONSTANTS.WEBRTC.MEDIA_STATE.RECEIVE_ONLY) {
	                call.sdp = _sdpParser.deleteInactiveVideoSsrc(call.sdp);
	            }

	            data = {
	                call: call,
	                mustCreatePeer: call.isRemoteEndFirefox,
	                oldSdp: call.prevRemoteSdp,
	                newSdp: call.sdp,
	                useIceServer: useIceServer
	            };
	            if (self.createNewPeerForCall(data)) {
	                peer = call.peer;
	            }

	            //set media lines with inactive state for workaround
	            call.sdp = _sdpParser.updateAudioSdpDirectionToInactive(call.sdp);
	            call.sdp = _sdpParser.updateVideoSdpDirectionToInactive(call.sdp);

	            callSdpWithNoSsrc = _sdpParser.deleteSsrcFromSdp(call.sdp);

	            self.setRemoteDescription(call, peer, CONSTANTS.WEBRTC.RTC_SDP_TYPE.OFFER, callSdpWithNoSsrc, function processUpdateWorkaroundSetRemoteDescriptionSuccessCallback() {
	                logger.debug("processUpdate: workaround setRemoteDescription success");

	                //restore original values
	                call.sdp = _sdpParser.updateAudioSdpDirection(call.sdp, remoteAudioState);
	                call.sdp = _sdpParser.updateVideoSdpDirection(call.sdp, remoteVideoState);
	                self.setRemoteDescription(call, peer, CONSTANTS.WEBRTC.RTC_SDP_TYPE.OFFER, call.sdp, function processUpdateSetRemoteDescriptionSuccessCallback() {
	                    logger.debug("processUpdate: setRemoteDescription success");
	                    call.remoteVideoState = _sdpParser.getVideoSdpDirection(call.sdp);

	                    peer.createAnswer(function processUpdateCreateAnswerSuccessCallback(obj) {
	                        logger.debug("processUpdate: isSdpEnabled audio= " + _sdpParser.isAudioSdpEnabled(obj.sdp));
	                        logger.debug("processUpdate: isSdpEnabled video= " + _sdpParser.isVideoSdpEnabled(obj.sdp));

	                        if (_sdpParser.isSdpVideoSendEnabled(call.sdp)) {
	                            if (self.canOriginatorSendLocalVideo(call)) {
	                                obj.sdp = _sdpParser.updateVideoSdpDirection(obj.sdp, CONSTANTS.WEBRTC.MEDIA_STATE.SEND_RECEIVE);
	                            } else {
	                                obj.sdp = _sdpParser.updateVideoSdpDirection(obj.sdp, CONSTANTS.WEBRTC.MEDIA_STATE.RECEIVE_ONLY);
	                            }
	                        } else {
	                            if (self.canOriginatorSendLocalVideo(call) && !_sdpParser.isVideoSdpDirectionInactive(call.sdp)) {
	                                obj.sdp = _sdpParser.updateVideoSdpDirection(obj.sdp, CONSTANTS.WEBRTC.MEDIA_STATE.SEND_ONLY);
	                            } else {
	                                obj.sdp = _sdpParser.updateVideoSdpDirection(obj.sdp, CONSTANTS.WEBRTC.MEDIA_STATE.INACTIVE);
	                            }
	                        }
	                        obj.sdp = _sdpParser.updateVersion(peerLocalSdp, obj.sdp);
	                        obj.sdp = _sdpParser.checkIceParamsLengths(obj.sdp, call.sdp);
	                        obj.sdp = _sdpParser.setTcpSetupAttributeTo(obj.sdp, call.localTcpSetupAttribute, self.isDtlsEnabled());

	                        localDescObj = self.getRtcLibrary().createRTCSessionDescription(CONSTANTS.WEBRTC.RTC_SDP_TYPE.ANSWER, obj.sdp);
	                        peer.setLocalDescription(localDescObj, function processUpdateSetLocalDescriptionSuccessCallback() {
	                            logger.debug("processUpdate setLocalDescription success. iceConnectionState: " + peer.iceConnectionState + " iceGatheringState: " + peer.iceGatheringState);
	                            if (peer.iceGatheringState === "complete") {
	                                if (call.successCallback) {
	                                    logger.debug("processUpdate iceGatheringState completed " + peer.localDescription.sdp);
	                                    _utils.callFunctionIfExist(successCallback, peer.localDescription.sdp);
	                                }
	                            }
	                        }, function processUpdateSetLocalDescriptionSuccessCallback(e) {
	                            logger.debug("processUpdate: setlocalDescription failed!!" + e);
	                            _utils.callFunctionIfExist(failureCallback, "processUpdate: setlocalDescription failed!!");
	                        });
	                    }, function processUpdateCreateAnswerFailureCallback(e) {
	                        logger.debug("processUpdate: createAnswer failed!! " + e);
	                        _utils.callFunctionIfExist(failureCallback, "Session cannot be created");
	                    }, self.getRtcLibrary().createConstraints(self.getMediaAudio(), self.getMediaVideo()));
	                }, function processUpdateSetRemoteDescriptionSuccessCallback(e) {
	                    logger.debug("processUpdate: setRemoteDescription failed!!" + e);
	                    _utils.callFunctionIfExist(failureCallback, "processUpdate: setRemoteDescription failed!!");
	                });
	            }, function processUpdateWorkaroundSetRemoteDescriptionSuccessCallback(e) {
	                logger.debug("processUpdate: workaround setRemoteDescription failed!!" + e);
	                _utils.callFunctionIfExist(failureCallback, "processUpdate: workaround setRemoteDescription failed!!");
	            });
	        }
	    };

	    // Native implementation lies on webRtcAdaptor.js
	    // processNativeAnswer
	    self.processAnswer = function(call, onSuccess, onFail) {
	        logger.debug("processAnswer: state= " + call.peer.signalingState);
	        var onSuccessAfterWorkarounds, setRemoteDescription,
	            remoteVideoDirection, localVideoDirection,
	            peer = call.peer,
	            origSdp;

	        onSuccessAfterWorkarounds = function() {
	            call.remoteVideoState = _sdpParser.getVideoSdpDirection(call.sdp);
	            _utils.callFunctionIfExist(onSuccess);
	        };

	        setRemoteDescription = function(call, onSuccess, onFailure) {
	            self.setRemoteDescription(call, peer, CONSTANTS.WEBRTC.RTC_SDP_TYPE.ANSWER, call.sdp,
	                function() {
	                    logger.debug("processAnswer: setRemoteDescription success");
	                    onSuccess();
	                },
	                function(e) {
	                    logger.error("processAnswer: setRemoteDescription failed: " + e);
	                    onFailure();
	                });
	        };

	        call.sdp = _sdpParser.checkSupportedVideoCodecs(call.sdp, peer.localDescription.sdp, self.isH264Enabled());
	        call.sdp = _sdpParser.performVideoPortZeroWorkaround(call.sdp);

	        if (peer.signalingState === CONSTANTS.WEBRTC.RTC_SIGNALING_STATE.HAVE_REMOTE_PRANSWER) {

	            if (_sdpParser.isIceLite(call.prevRemoteSdp) !== _sdpParser.isIceLite(call.sdp)) {
	                logger.debug("ice - ice-lite change.");
	                onFail(CONSTANTS.WEBRTC.ERROR.ICE_ICELITE);
	                return;
	            }

	            origSdp = call.sdp;
	            call.sdp = _sdpParser.updateVideoSdpDirection(call.sdp, CONSTANTS.WEBRTC.MEDIA_STATE.RECEIVE_ONLY);
	            call.sdp = _sdpParser.updateAudioSdpDirection(call.sdp, CONSTANTS.WEBRTC.MEDIA_STATE.RECEIVE_ONLY);
	            logger.debug("call processPrAnswer again to trigger on remote stream added with updated sdp.");
	            self.processPreAnswer(call,
	                function() {
	                    call.sdp = origSdp;
	                    logger.debug("processPrAnswer success callback. Restore original sdp.");
	                    setRemoteDescription(call, onSuccessAfterWorkarounds, onFail);
	                },
	                function() {
	                    call.sdp = origSdp;
	                    logger.debug("processPrAnswer failure callback. Restore original sdp.");
	                    setRemoteDescription(call, onSuccessAfterWorkarounds, onFail);
	                }
	            );
	            return;
	        }

	        remoteVideoDirection = _sdpParser.getVideoSdpDirection(call.sdp);
	        localVideoDirection = _sdpParser.getVideoSdpDirection(call.peer.localDescription.sdp);

	        // this is needed for buggy webrtc api. when term answers with video to audio only call
	        // this scenario does not work without converting to sendrecv
	        logger.debug("processAnswer: ice-lite: do remote video escalation");
	        call.sdp = _sdpParser.changeDirection(call.sdp, CONSTANTS.WEBRTC.MEDIA_STATE.SEND_ONLY, CONSTANTS.WEBRTC.MEDIA_STATE.SEND_RECEIVE, CONSTANTS.STRING.AUDIO);
	        call.sdp = _sdpParser.changeDirection(call.sdp, CONSTANTS.WEBRTC.MEDIA_STATE.SEND_ONLY, CONSTANTS.WEBRTC.MEDIA_STATE.SEND_RECEIVE, CONSTANTS.STRING.VIDEO);

	        if ((localVideoDirection === CONSTANTS.WEBRTC.MEDIA_STATE.RECEIVE_ONLY || localVideoDirection === CONSTANTS.WEBRTC.MEDIA_STATE.SEND_RECEIVE) &&
	            (remoteVideoDirection === CONSTANTS.WEBRTC.MEDIA_STATE.INACTIVE || remoteVideoDirection === CONSTANTS.WEBRTC.MEDIA_STATE.RECEIVE_ONLY)) {

	            // delete ssrc only from video, keep audio ssrc to hear audio
	            call.sdp = _sdpParser.deleteInactiveVideoSsrc(call.sdp);

	            // Audio <--> Audio : apply workaround step 1

	            setRemoteDescription(call, onSuccessAfterWorkarounds, onFail);

	        } else if (localVideoDirection === CONSTANTS.WEBRTC.MEDIA_STATE.RECEIVE_ONLY &&
	            (remoteVideoDirection === CONSTANTS.WEBRTC.MEDIA_STATE.SEND_ONLY || remoteVideoDirection === CONSTANTS.WEBRTC.MEDIA_STATE.SEND_RECEIVE)) {

	            // Audio  <--> Audio-Video

	            setRemoteDescription(call, function() {
	                self.performVideoStartWorkaround(call, onSuccessAfterWorkarounds, onFail);
	            }, onFail);

	        } else {

	            // Audio-Video <--> Audio-Video
	            // there is remote video, no need for orig side workaround

	            setRemoteDescription(call, onSuccessAfterWorkarounds, onFail);
	        }

	    };

	    // Native implementation lies on webRtcAdaptor.js
	    // processNativePreAnswer
	    self.processPreAnswer = function(call, onSuccess, onFailure) {
	        logger.debug("processPreAnswer: state= " + call.peer.signalingState);
	        var peer = call.peer;

	        call.sdp = _sdpParser.checkSupportedVideoCodecs(call.sdp, call.peer.localDescription.sdp, self.isH264Enabled());

	        self.setRemoteDescription(call, peer, CONSTANTS.WEBRTC.RTC_SDP_TYPE.PRANSWER, call.sdp,
	            function processPreAnswerSetRemoteDescriptionSuccessCallback() {
	                self.setOriginatorReceiveRemoteVideo(call);
	                call.remoteVideoState = _sdpParser.getVideoSdpDirection(call.sdp);
	                onSuccess();
	                logger.debug("processPreAnswer: setRemoteDescription success");
	            },
	            function processPreAnswerSetRemoteDescriptionFailureCallback(e) {
	                logger.error("processPreAnswer: setRemoteDescription failed: " + e);
	                onFailure(e);
	            });
	    };

	    // Native implementation lies on webRtcAdaptor.js
	    // processNativeRespond
	    self.processRespond = function(call, onSuccess, onFail, isJoin) {
	        var remoteVideoDirection, callSdpWithNoSsrc,
	            peer = call.peer,
	            remoteSdpHasVideo = false;

	        logger.debug("processRespond: state= " + call.peer.signalingState);

	        if (call.peer.signalingState === CONSTANTS.WEBRTC.RTC_SIGNALING_STATE.STABLE) {
	            //if we are in stable state we should not change remotedescription
	            self.setRemoteDescription(call, null, null, call.sdp, onSuccess, onFail);
	            return;
	        }

	        remoteSdpHasVideo = _sdpParser.isSdpHasVideo(call.sdp);

	        if (remoteSdpHasVideo) {
	            call.sdp = _sdpParser.checkSupportedVideoCodecs(call.sdp, call.stableLocalSdp, self.isH264Enabled());

	            remoteVideoDirection = _sdpParser.getVideoSdpDirection(call.sdp);

	            if ((remoteVideoDirection === CONSTANTS.WEBRTC.MEDIA_STATE.INACTIVE) && (call.currentState === "COMPLETED")) {
	                switch (call.remoteVideoState) {
	                    case CONSTANTS.WEBRTC.MEDIA_STATE.INACTIVE:
	                    case CONSTANTS.WEBRTC.MEDIA_STATE.RECEIVE_ONLY:
	                        call.sdp = _sdpParser.updateVideoSdpDirection(call.sdp, CONSTANTS.WEBRTC.MEDIA_STATE.RECEIVE_ONLY);
	                        break;
	                }
	            }
	            call.sdp = _sdpParser.changeDirection(call.sdp, CONSTANTS.WEBRTC.MEDIA_STATE.SEND_ONLY, CONSTANTS.WEBRTC.MEDIA_STATE.SEND_RECEIVE, CONSTANTS.STRING.VIDEO);
	        }

	        if (isJoin) {
	            call.sdp = _sdpParser.changeDirection(call.sdp, CONSTANTS.WEBRTC.MEDIA_STATE.RECEIVE_ONLY, CONSTANTS.WEBRTC.MEDIA_STATE.SEND_RECEIVE, CONSTANTS.STRING.AUDIO);
	            self.muteOnHold(call, false);
	        }

	        // delete all ssrc lines from the sdp before setting first remote description
	        // set second remote description with all ssrc lines included

	        if (remoteSdpHasVideo && (_sdpParser.getVideoSdpDirection(call.sdp) === CONSTANTS.WEBRTC.MEDIA_STATE.INACTIVE ||
	                _sdpParser.getVideoSdpDirection(call.sdp) === CONSTANTS.WEBRTC.MEDIA_STATE.RECEIVE_ONLY)) {
	            call.sdp = _sdpParser.deleteInactiveVideoSsrc(call.sdp);
	        }

	        callSdpWithNoSsrc = _sdpParser.deleteSsrcFromSdp(call.sdp);

	        self.setRemoteDescription(call, peer, CONSTANTS.WEBRTC.RTC_SDP_TYPE.ANSWER, callSdpWithNoSsrc, function() {
	            logger.debug("processRespond: setRemoteDescription success");
	            var onSuccessAfterWorkarounds = function() {
	                call.remoteVideoState = _sdpParser.getVideoSdpDirection(call.sdp);
	                _utils.callFunctionIfExist(onSuccess);
	            };
	            self.performVideoStartWorkaround(call, onSuccessAfterWorkarounds, onFail);
	        }, function(e) {
	            logger.debug("processRespond: setRemoteDescription failed: " + e);
	            _utils.callFunctionIfExist(onFail);
	        });
	    };

	    /*
	     * Native implementation lies on webRtcAdaptor.js
	     * processNativeHoldRespond
	     */
	    self.processHoldRespond = function(call, onSuccess, onFailure, isJoin) {
	        var remoteAudioDirection,
	            remoteVideoDirection,
	            onSuccessAfterWorkaround,
	            localHoldFlag = false,
	            remoteHoldFlag = false;

	        onSuccessAfterWorkaround = function() {
	            //call.remoteVideoState = getSdpDirection(call.sdp, video);
	            _utils.callFunctionIfExist(onSuccess);
	        };

	        logger.debug("processHoldRespond: state= " + call.peer.signalingState + " call.currentState= " + call.currentState);

	        if (call.peer.signalingState === CONSTANTS.WEBRTC.RTC_SIGNALING_STATE.STABLE) {
	            //if we are in stable state we should not change remotedescription
	            self.onRemoteStreamAdded(call);
	            self.setRemoteDescription(call, null, null, call.sdp, onSuccess, onFailure);
	            return;
	        }

	        call.sdp = _sdpParser.checkSupportedVideoCodecs(call.sdp, call.stableLocalSdp, self.isH264Enabled());

	        _sdpParser.init(call.sdp);
	        remoteHoldFlag = _sdpParser.isRemoteHold();

	        localHoldFlag = (call.currentState === "LOCAL_HOLD");

	        remoteAudioDirection = _sdpParser.getAudioSdpDirection(call.sdp);
	        remoteVideoDirection = _sdpParser.getVideoSdpDirection(call.sdp);

	        call.remoteVideoState = remoteVideoDirection;

	        logger.debug("processHoldRespond: localHold= " + localHoldFlag + " remoteHold= " + remoteHoldFlag);

	        /* Required for MOH - start */
	        if (remoteHoldFlag === false) {
	            if ((remoteAudioDirection === CONSTANTS.WEBRTC.MEDIA_STATE.SEND_RECEIVE) && (call.currentState === "REMOTE_HOLD")) {
	                logger.debug("set current web state to COMPLETED");
	                call.previousState = call.currentState;
	                call.currentState = "COMPLETED";
	            }
	        } else {
	            if (call.currentState === "COMPLETED") {
	                logger.debug("set current web state to REMOTE_HOLD");
	                call.previousState = call.currentState;
	                call.currentState = "REMOTE_HOLD";
	            }
	        }

	        if (localHoldFlag || remoteHoldFlag) {
	            logger.debug("processHoldRespond: " + call.currentState + " : video -> inactive");
	            call.sdp = _sdpParser.updateVideoSdpDirection(call.sdp, CONSTANTS.WEBRTC.MEDIA_STATE.INACTIVE);
	        }

	        if ((remoteVideoDirection === CONSTANTS.WEBRTC.MEDIA_STATE.INACTIVE) && (call.currentState === "COMPLETED")) {
	            logger.debug("processHoldRespond: video inactive -> recvonly");
	            call.sdp = _sdpParser.updateVideoSdpDirection(call.sdp, CONSTANTS.WEBRTC.MEDIA_STATE.RECEIVE_ONLY);
	        }
	        /* Required for MOH - end */

	        if (isJoin) {
	            self.muteOnHold(call, false);
	        }

	        // this is required for displaying remote video when direction is send only
	        call.sdp = _sdpParser.changeDirection(call.sdp, CONSTANTS.WEBRTC.MEDIA_STATE.SEND_ONLY, CONSTANTS.WEBRTC.MEDIA_STATE.SEND_RECEIVE, CONSTANTS.STRING.AUDIO);
	        call.sdp = _sdpParser.changeDirection(call.sdp, CONSTANTS.WEBRTC.MEDIA_STATE.SEND_ONLY, CONSTANTS.WEBRTC.MEDIA_STATE.SEND_RECEIVE, CONSTANTS.STRING.VIDEO);
	        if (_sdpParser.getVideoSdpDirection(call.sdp) === CONSTANTS.WEBRTC.MEDIA_STATE.INACTIVE ||
	            _sdpParser.getVideoSdpDirection(call.sdp) === CONSTANTS.WEBRTC.MEDIA_STATE.RECEIVE_ONLY) {
	            call.sdp = _sdpParser.deleteInactiveVideoSsrc(call.sdp);
	        }

	        if (localHoldFlag && remoteAudioDirection === CONSTANTS.WEBRTC.MEDIA_STATE.SEND_RECEIVE) {
	            logger.debug("processHoldRespond: Mute Remote Audio");
	            call.sdp = _sdpParser.updateAudioSdpDirection(call.sdp, CONSTANTS.WEBRTC.MEDIA_STATE.RECEIVE_ONLY);
	        }

	        if (localHoldFlag && remoteVideoDirection === CONSTANTS.WEBRTC.MEDIA_STATE.SEND_RECEIVE) {
	            logger.debug("processHoldRespond: Mute Remote Video");
	            call.sdp = _sdpParser.updateVideoSdpDirection(call.sdp, CONSTANTS.WEBRTC.MEDIA_STATE.RECEIVE_ONLY);
	        }

	        self.setRemoteDescription(call, call.peer, CONSTANTS.WEBRTC.RTC_SDP_TYPE.ANSWER, call.sdp,
	            function processHoldRespondSetRemoteDescriptionSuccessCallback() {
	                logger.debug("processHoldRespond: setRemoteDescription typeAns success");
	                if (remoteAudioDirection === CONSTANTS.WEBRTC.MEDIA_STATE.INACTIVE ||
	                    remoteAudioDirection === CONSTANTS.WEBRTC.MEDIA_STATE.RECEIVE_ONLY) {
	                    onSuccessAfterWorkaround();
	                } else {
	                    self.performVideoStartWorkaround(call, onSuccessAfterWorkaround, onFailure);
	                }
	            },
	            function processHoldRespondSetRemoteDescriptionFailureCallback(e) {
	                logger.debug("processHoldRespond: setRemoteDescription typeAns failed: " + e);
	                _utils.callFunctionIfExist(onFailure);
	            });
	    };

	    // Native implementation lies on webRtcAdaptor.js
	    self.processRemoteOfferOnLocalHold = function(call, successCallback, failureCallback) {
	        logger.info("processRemoteOfferOnLocalHold");
	        if (call.peer) {
	            _utils.callFunctionIfExist(successCallback, call.stableLocalSdp);
	        } else {
	            _utils.callFunctionIfExist(failureCallback, "we dont have a peer object somehow");
	        }
	    };

	    self.removeJslIdFromContainer = function() {
	        if (self.getDefaultVideoContainer()) {
	            self.getDefaultVideoContainer().removeAttribute('jsl-id');
	            self.disposeStreamRenderer(self.getDefaultVideoContainer().lastElementChild);
	        } else if (self.getLocalVideoContainer()) {
	            self.getLocalVideoContainer().removeAttribute('jsl-id');
	            self.disposeStreamRenderer(self.getLocalVideoContainer());
	        }
	    };

	    self.clearLocalMediaProperties = function(localMedia) {
	        localMedia.stream = null;
	        localMedia.originalStream = null;
	        localMedia.audioContext = null;
	        localMedia.mediaStreamDestination = null;
	    };

	    self.endLocalMedia = function(localMedia) {
	        if (localMedia && localMedia.stream && !localMedia.privateStream) {
	            logger.info("stopping local media " + localMedia.stream.id);
	            self.getLocalStreamMap().remove(localMedia.stream.id);
	            self.getRtcLibrary().detachWebAudioContextFromLocalMedia(localMedia);
	            self.getRtcLibrary().stopLocalMedia(localMedia);
	            self.clearLocalMediaProperties(localMedia);
	        }
	    };

	    /*
	     * Native implementation lies on webRtcAdaptor.js
	     * process the end call that was received
	     *
	     * @ignore
	     * @name rtc.processEnd.stop
	     */
	    self.processEnd = function(call) {
	        var id, localStreamEntries;
	        self.clearIceCandidateCollectionTimer(call);
	        self.clearWebrtcLogCollectionInterval(call);
	        if (call.peer) {
	            logger.info("close peer connection " + call.id);

	            if (call.peer.signalingState !== "closed") {
	                call.peer.close();
	            }
	            self.endLocalMedia(call.localMedia);

	            self.setPeerCount(self.getPeerCount() - 1);
	            if (self.getPeerCount() <= 0) {
	                self.removeJslIdFromContainer();

	                localStreamEntries = self.getLocalStreamMap().entries();
	                for (id in localStreamEntries) {
	                    if (localStreamEntries.hasOwnProperty(id)) {
	                        self.endLocalMedia(self.getLocalStreamMap().get(id));
	                    }
	                }
	            }
	        }
	    };

	    // Native implementation lies on webRtcAdaptor.js
	    self.onSessionConnecting = function() {
	        logger.debug("onSessionConnecting");
	    };

	    // Native implementation lies on webRtcAdaptor.js
	    self.onSessionOpened = function() {
	        logger.debug("onSessionOpened");
	    };

	    // Native implementation lies on webRtcAdaptor.js
	    self.onSignalingStateChange = function(call) {
	        //TODO may need to move the state changes for webrtc here
	        logger.debug("Signalling state changed: state= " + call.peer.signalingState);
	    };

	    // Native implementation lies on webRtcAdaptor.js
	    self.useDefaultRenderer = function(streamUrl, local, isVideoTrackAvailable) {
	        var videoContainer;

	        if (self.getDefaultVideoContainer() && self.getDefaultVideoContainer().children.length === 0) {
	            // Create divs for the remote and local
	            self.getDefaultVideoContainer().innerHTML = "<div style='height:100%;width:100%'></div><div style='position:absolute;bottom:10px;right:10px;height:30%; width:30%;'></div>";
	        }

	        if (local) {
	            videoContainer = self.getDefaultVideoContainer().lastElementChild;
	        } else {
	            videoContainer = self.getDefaultVideoContainer().firstElementChild;

	            if (!isVideoTrackAvailable) {
	                videoContainer.style.width = "0%";
	            } else {
	                videoContainer.style.width = "100%";
	            }
	        }
	        return self.createStreamRenderer(streamUrl, videoContainer, {
	            muted: local
	        });
	    };

	    // Native implementation lies on webRtcAdaptor.js
	    self.createStreamRenderer = function(streamUrl, container, options) {
	        var renderer;

	        if (!streamUrl || !container) {
	            return;
	        }

	        container.innerHTML = "";
	        renderer = document.createElement('video');
	        renderer.src = streamUrl;

	        renderer.style.width = "100%";
	        renderer.style.height = "100%";

	        renderer.autoplay = "true";

	        if (options) {
	            if (options.muted) {
	                renderer.muted = "true";
	            }
	        }

	        container.appendChild(renderer);
	        return renderer;
	    };

	    // Native implementation lies on webRtcAdaptor.js
	    self.addCallIdInPluginContainer = function(call) {
	        logger.info("addCallIdInPluginContainer Call ID= " + call.id);
	        if (self.getDefaultVideoContainer()) {
	            self.getDefaultVideoContainer().setAttribute('jsl-id', call.id);
	        } else if (self.getRemoteVideoContainer()) {
	            self.getRemoteVideoContainer().setAttribute('jsl-id', call.id);
	        }
	    };

	    // Native implementation lies on webRtcAdaptor.js
	    self.isActiveCallInVideoContainer = function(container, call) {
	        logger.info("isActiveCallInVideoContainer Call ID= " + call.id);
	        if (container.getAttribute('jsl-id') !== 'undefined') {
	            logger.info("isActiveCallInVideoContainer Jsl Id= " + container.getAttribute('jsl-id'));
	            if (call.id !== container.getAttribute('jsl-id')) {
	                return false;
	            }
	        }
	        return true;
	    };

	    // nativeOnRemoteStreamAdded
	    self.onRemoteStreamAdded = function(call, event) {
	        var fireEvent,
	            remoteVideoTracks = [],
	            isVideoTrackAvailable = false;

	        if (self.getDefaultVideoContainer()) {
	            if (!self.isActiveCallInVideoContainer(self.getDefaultVideoContainer(), call)) {
	                logger.debug("onRemoteStreamAdded: It is not active call. Call Id: " + call.id);
	                return;
	            }
	        } else if (self.getRemoteVideoContainer()) {
	            if (!self.isActiveCallInVideoContainer(self.getRemoteVideoContainer(), call)) {
	                logger.debug("onRemoteStreamAdded: It is not active call. Call Id: " + call.id);
	                return;
	            }
	        }

	        if (event && event.stream) {
	            call.remoteStreamUrl = self.getRtcLibrary().getURLFromStream(event.stream);

	            remoteVideoTracks = event.stream.getVideoTracks();
	        } else {
	            remoteVideoTracks = self.getRemoteVideoTrack(call.peer);
	        }

	        if (remoteVideoTracks && _sdpParser.isVideoSdpEnabled(call.sdp)) {
	            if (remoteVideoTracks.length > 0) {
	                isVideoTrackAvailable = true;
	            }
	        }

	        if (self.getDefaultVideoContainer()) {
	            fireEvent = self.useDefaultRenderer(call.remoteStreamUrl, false, isVideoTrackAvailable);
	        } else if (self.getRemoteVideoContainer()) {
	            fireEvent = self.createStreamRenderer(call.remoteStreamUrl, self.getRemoteVideoContainer());
	        } else {
	            fireEvent = true;
	        }

	        logger.debug("onRemoteStreamAdded: " + call.remoteStreamUrl);
	        if (fireEvent) {
	            self.fireOnStreamAddedEvent(call, call.remoteStreamUrl);
	        }
	    };

	    // Native implementation lies on webRtcAdaptor.js
	    self.fireOnStreamAddedEvent = function(call, streamUrl) {
	        if (call && call.call && call.call.onStreamAdded) {
	            self.setOriginatorReceiveRemoteVideo(call);
	            _utils.callFunctionIfExist(call.call.onStreamAdded, streamUrl);
	        }
	    };

	    // Native implementation lies on webRtcAdaptor.js
	    self.onRemoteStreamRemoved = function() {
	        logger.debug("onRemoteStreamRemoved");
	    };

	    // Native implementation lies on webRtcAdaptor.js
	    self.clearIceCandidateCollectionTimer = function(call) {
	        //This method wasn't implemented in webrtc.js
	        clearTimeout(call.iceCandidateCollectionTimer);
	        call.iceCandidateCollectionTimer = null;
	    };

	    // Native implementation lies on webRtcAdaptor.js
	    self.onIceCandidate = function(call, event) {
	        var sdp;
	        if (event.candidate === null) {
	            logger.debug("Null candidate received.");
	            if (call.successCallback) {
	                sdp = call.peer.localDescription.sdp;

	                if (_sdpParser.hasCandidates(sdp, call.relayCandidateCycle, fcsConfig.relayCandidateCollectionTimeoutCycle)) {
	                    self.clearIceCandidateCollectionTimer(call);
	                    logger.debug("Candidates received, invoking successCallback.");

	                    call.successCallback(sdp);
	                } else {
	                    logger.trace("Sdp does not have candidates.");
	                }
	            }
	        } else {
	            logger.debug("ICE candidate received: sdpMLineIndex = " + event.candidate.sdpMLineIndex +
	                ", candidate = " + event.candidate.candidate + " for call : " + call.id);
	        }
	    };

	    // Native implementation lies on webRtcAdaptor.js
	    self.onIceComplete = function(call) {
	        var sdp;
	        logger.debug("All ICE candidates received for call : " + call.id);
	        self.clearIceCandidateCollectionTimer(call);

	        if (call.successCallback) {
	            sdp = call.peer.localDescription.sdp;

	            logger.debug("onIceComplete sdp : " + sdp);

	            call.successCallback(sdp);
	        }
	    };

	    self.onDataChannel = function(dataChannelWrapperObj, event) {
	        dataChannelWrapperObj.dataChannel = event.channel;
	        _utils.callFunctionIfExist(dataChannelWrapperObj.onDataChannel, dataChannelWrapperObj);
	    };

	    // Native implementation lies on webRtcAdaptor.js
	    self.iceCandidateCollectionTimeoutHandler = function(call) {
	        var sdp = call.peer.localDescription.sdp;
	        self.clearIceCandidateCollectionTimer(call);
	        if (fcsConfig.relayCandidateCollectionTimeoutCycle) {
	            call.relayCandidateCycle++;
	        }
	        // set timeout if there is no ice candidate available or
	        // when audio, video port assignment isn't complete
	        if (!_sdpParser.hasCandidates(sdp, call.relayCandidateCycle, fcsConfig.relayCandidateCollectionTimeoutCycle)) {
	            logger.debug("Re-setting ice candidate collection timeout: " + fcsConfig.iceCandidateCollectionTimeoutInterval);
	            call.iceCandidateCollectionTimer = setTimeout(function() {
	                self.iceCandidateCollectionTimeoutHandler(call);
	            }, fcsConfig.iceCandidateCollectionTimeoutInterval);
	            return;
	        }

	        if (call.successCallback) {
	            logger.debug("Ice candidate collection interrupted after given timeout, invoking successCallback.");
	            call.successCallback(sdp);
	        }
	    };

	    // Native implementation lies on webRtcAdaptor.js
	    self.setupIceCandidateCollectionTimer = function(call) {
	        if (fcsConfig.iceCandidateCollectionTimeoutInterval) {
	            if (!call.iceCandidateCollectionTimer) {
	                logger.debug("Setting ice candidate collection timeout: " + fcsConfig.iceCandidateCollectionTimeoutInterval);
	                if (fcsConfig.relayCandidateCollectionTimeoutCycle) {
	                    call.relayCandidateCycle = 1;
	                }
	                call.iceCandidateCollectionTimer = setTimeout(function() {
	                    self.iceCandidateCollectionTimeoutHandler(call);
	                }, fcsConfig.iceCandidateCollectionTimeoutInterval);
	            } else {
	                logger.trace("Ice candidate collection timer exists.");
	            }
	        }
	    };

	    self.getNativeWebRtcStats = function(call, onSuccess, onFailure) {
	        try {
	            if (call) {
	                logger.debug("getNativeWebRtcStats called");
	                call.peer.getStats(function(stats) {
	                    if (stats !== undefined && stats !== null) {
	                        var results = stats.result();
	                        _utils.callFunctionIfExist(onSuccess, results);
	                    }
	                });
	            }
	        } catch (err) {
	            logger.error("Failed to get all WebRTC Statistics: " + err.message);
	            _utils.callFunctionIfExist(onFailure, err);
	        }
	    };

	    self.getWebRtcStats = function(call, onSuccess, onFailure) {
	        try {
	            if (call) {
	                logger.debug("getWebRtcStats called");
	                self.collectWebRtcStats(call.sdp, call.peer,
	                    function(stats) {
	                        var accumulatedStats = self.getAccumulatedWebRtcStats(call.stats, stats, call.cache);
	                        _utils.callFunctionIfExist(onSuccess, accumulatedStats);
	                    },
	                    onFailure);
	            } else {
	                var cacheWebRtcStats = JSON.parse(_cache.getItem(_fcs.getUser() + '_stats'));
	                _utils.callFunctionIfExist(onSuccess, cacheWebRtcStats);
	            }
	        } catch (err) {
	            logger.error("Failed to get WebRTC Statistics: " + err.message);
	            _utils.callFunctionIfExist(onFailure, err);
	        }
	        return self.getStats();
	    };

	    self.getAccumulatedWebRtcStats = function(statsList, currentStats, callCache) {
	        var i, accumulatedStats = {
	            audio: {
	                packetsSent: 0,
	                bytesSent: 0,
	                bytesReceived: 0,
	                peerAddress: null,
	                codec: null,
	                packetsLost: 0,
	                jitter: null,
	                rtt: null
	            },
	            video: {
	                packetsSent: 0,
	                bytesSent: 0,
	                bytesReceived: 0,
	                peerAddress: null,
	                codec: null,
	                packetsLost: 0,
	                rtt: null
	            }
	        };
	        if (statsList !== undefined) {
	            for (i = 0; i < statsList.length; i++) {
	                self.accumulateStats(accumulatedStats.audio, statsList[i].audio);
	                self.accumulateStats(accumulatedStats.video, statsList[i].video);
	            }
	        }

	        self.accumulateStats(accumulatedStats.audio, currentStats.audio);
	        accumulatedStats.audio.peerAddress = currentStats.audio.peerAddress;
	        accumulatedStats.audio.codec = currentStats.audio.codec;
	        accumulatedStats.audio.jitter = currentStats.audio.jitter;
	        accumulatedStats.audio.rtt = currentStats.audio.rtt;

	        self.accumulateStats(accumulatedStats.video, currentStats.video);
	        accumulatedStats.video.peerAddress = currentStats.video.peerAddress;
	        accumulatedStats.video.codec = currentStats.video.codec;
	        accumulatedStats.video.rtt = currentStats.video.rtt;

	        if (callCache) {
	            _cache.setItem(_fcs.getUser() + '_stats', JSON.stringify(accumulatedStats));
	        }
	        return accumulatedStats;
	    };

	    self.accumulateStats = function(accumulatedStatsObj, statsObj) {
	        accumulatedStatsObj.packetsSent += _utils.getInteger(statsObj.packetsSent);
	        accumulatedStatsObj.bytesSent += _utils.getInteger(statsObj.bytesSent);
	        accumulatedStatsObj.bytesReceived += _utils.getInteger(statsObj.bytesReceived);
	        accumulatedStatsObj.packetsLost += _utils.getInteger(statsObj.packetsLost) === -1 ? 0 : _utils.getInteger(statsObj.packetsLost);
	    };

	    self.collectWebRtcStats = function(statsSdp, peer, onSuccess, onFailure) {
	        try {
	            if (peer) {
	                logger.debug("collectWebRtcStats called");
	                peer.getStats(function(stats) {
	                    if (stats !== undefined && stats !== null) {
	                        var results = stats.result();
	                        self.setWebRtcStats(results, statsSdp);

	                        _utils.callFunctionIfExist(onSuccess, self.getStats());
	                    }
	                });
	            }
	        } catch (err) {
	            logger.error("Failed to collectWebRtcStats: " + err.message);
	            _utils.callFunctionIfExist(onFailure, err);
	        }

	        return self.getStats();
	    };

	    self.setWebRtcStats = function(results, statsSdp) {

	        var i, j, res, names, mediaDescriptions, sdpAudioPort, sdpVideoPort,
	            transportId, googChannelId, googCodecName, alwaysMediaOnBroker,
	            stats = {
	                audio: {
	                    packetsSent: null,
	                    bytesSent: null,
	                    bytesReceived: null,
	                    peerAddress: "",
	                    codec: null,
	                    packetsLost: null,
	                    jitter: null,
	                    rtt: null
	                },
	                video: {
	                    packetsSent: null,
	                    bytesSent: null,
	                    bytesReceived: null,
	                    peerAddress: null,
	                    codec: null,
	                    packetsLost: null,
	                    rtt: null
	                }
	            };

	        if (_sdpParser.isIceLite(statsSdp)) {
	            alwaysMediaOnBroker = true;
	        } else {
	            alwaysMediaOnBroker = false;
	        }

	        if (statsSdp !== undefined && statsSdp !== null && results !== undefined && results !== null) {
	            _sdpParser.init(statsSdp);
	            _sdpParser.parseSDP(statsSdp);
	            mediaDescriptions = _sdpParser.getMediaDescriptions();

	            if (mediaDescriptions !== undefined) {
	                if (mediaDescriptions[0] !== undefined) {
	                    sdpAudioPort = mediaDescriptions[0].port;
	                }

	                if (mediaDescriptions[1] !== undefined) {
	                    sdpVideoPort = mediaDescriptions[1].port;
	                }
	            }

	            for (i = 0; i < results.length; i++) {
	                res = results[i];
	                names = res.names();
	                if (names !== undefined) {
	                    for (j = 0; j < names.length; j++) {
	                        googChannelId = res.stat("googChannelId");
	                        transportId = res.stat("transportId");
	                        googCodecName = res.stat("googCodecName");
	                        if ((transportId !== undefined && transportId.indexOf("audio") > -1) ||
	                            (googChannelId !== undefined && googChannelId.indexOf("audio") > -1)) {

	                            if (googCodecName === "VP8" || googCodecName === "H264") {
	                                self.fillStats(stats.video, res, names, j, sdpVideoPort, alwaysMediaOnBroker);
	                            } else {
	                                self.fillStats(stats.audio, res, names, j, sdpAudioPort, alwaysMediaOnBroker);
	                            }
	                        } else if ((transportId !== undefined && transportId.indexOf("video") > -1) ||
	                            (googChannelId !== undefined && googChannelId.indexOf("video") > -1)) {
	                            self.fillStats(stats.video, res, names, j, sdpVideoPort, alwaysMediaOnBroker);
	                        }

	                    }
	                    if (!alwaysMediaOnBroker && sdpVideoPort !== undefined) {
	                        stats.video.peerAddress = stats.audio.peerAddress.split(":")[0];
	                    }
	                    self.setStats(stats);
	                }
	            }
	        }

	    };

	    self.fillStats = function(statsObj, res, names, index, sdpRemotePort, alwaysMediaOnBroker) {
	        var remotePort, remoteAddress;

	        if ((res.stat("googActiveConnection") === "true") && alwaysMediaOnBroker) {
	            remoteAddress = res.stat("googRemoteAddress");

	            if (remoteAddress !== undefined) {
	                if (remoteAddress.split(":") !== undefined && remoteAddress.split(":")[1] !== undefined) {
	                    remotePort = remoteAddress.split(":")[1];
	                }

	                if (remotePort === sdpRemotePort) {

	                    statsObj.peerAddress = remoteAddress;

	                    if (names[index] === "bytesReceived") {
	                        statsObj.bytesReceived = res.stat(names[index]);
	                    }

	                    if (names[index] === "packetsSent") {
	                        statsObj.packetsSent = res.stat(names[index]);
	                    }

	                    if (names[index] === "bytesSent") {
	                        statsObj.bytesSent = res.stat(names[index]);
	                    }
	                }
	            }
	        }

	        if ((res.stat("googActiveConnection") === "true") && !alwaysMediaOnBroker) {
	            remoteAddress = res.stat("googRemoteAddress");
	            statsObj.peerAddress = remoteAddress;
	        }

	        if (res.type === "ssrc") {
	            if (names[index] === "packetsLost") {
	                statsObj.packetsLost = res.stat(names[index]);
	            }

	            if (names[index] === "googCodecName") {
	                statsObj.codec = res.stat(names[index]);
	            }

	            if (names[index] === "googJitterReceived") {
	                statsObj.jitter = res.stat(names[index]);
	            }

	            if (names[index] === "googRtt") {
	                statsObj.rtt = res.stat(names[index]);
	            }

	            if (!alwaysMediaOnBroker) {
	                if (names[index] === "bytesReceived") {
	                    statsObj.bytesReceived = res.stat(names[index]);
	                }
	                if (names[index] === "packetsSent") {
	                    statsObj.packetsSent = res.stat(names[index]);
	                }
	                if (names[index] === "bytesSent") {
	                    statsObj.bytesSent = res.stat(names[index]);
	                }
	            }
	        }
	    };

	    self.clearWebrtcLogCollectionInterval = function(call) {
	        //This method wasn't implemented in webrtc.js
	        clearInterval(call.webrtcLogCollectionInterval);
	        call.webrtcLogCollectionInterval = null;
	    };

	    self.webrtcLogCollectionTimeoutHandler = function(call) {
	        if (call && call.peer && call.peer.signalingState !== "closed") {
	            call.peer.getStats(function(stats) {
	                var results = stats.result(),
	                    i, j, res, names, statObj,
	                    resultLength, namesLength;
	                resultLength = results.length;
	                for (i = 0; i < resultLength; ++i) {
	                    res = results[i];
	                    if (!res.local || res.local === res) {
	                        statObj = {};
	                        statObj.timestamp = res.timestamp;
	                        if (res.id) {
	                            statObj.id = res.id;
	                        }
	                        if (res.type) {
	                            statObj.type = res.type;
	                        }

	                        if (res.names) {
	                            names = res.names();
	                            namesLength = names.length;
	                            for (j = 0; j < namesLength; ++j) {
	                                statObj[names[j]] = res.stat(names[j]);
	                            }
	                        } else {
	                            if (res.stat('audioOutputLevel')) {
	                                statObj.audioOutputLevel = res.stat('audioOutputLevel');
	                            }
	                        }
	                        logger.trace("Peer connection stats, report[" + i + "]: ", statObj);
	                    }
	                }
	            });
	        } else {
	            self.clearWebrtcLogCollectionInterval(call);
	        }
	    };

	    self.setupWebrtcLogCollectionTimer = function(call) {
	        if (fcsConfig.webrtcLogCollectionInterval) {
	            self.clearWebrtcLogCollectionInterval(call);
	            var logCollectionInterval = fcsConfig.webrtcLogCollectionInterval * 1000;
	            logger.debug("Setting webrtc log collection interval: " + logCollectionInterval);
	            call.webrtcLogCollectionInterval = setInterval(function() {
	                self.webrtcLogCollectionTimeoutHandler(call);
	            }, logCollectionInterval);
	        }
	    };

	    self.oniceconnectionstatechange = function(call) {
	        logger.debug("ICE connection state change : " + call.peer.iceConnectionState);
	    };

	    self.createDataChannel = function(dataChannelWrapperObj, onSuccess, onFailure, options) {
	        try {
	            dataChannelWrapperObj.dataChannel = dataChannelWrapperObj.peer.createDataChannel(options);
	            onSuccess(dataChannelWrapperObj);
	        } catch (error) {
	            logger.error("Failed to create data channel, exception: " + error.message);
	            onFailure(error);
	        }
	    };

	    // Native implementation lies on webRtcAdaptor.js
	    self.createPeer = function(call, useIceServer, onSuccess, onFailure) {
	        try {
	            var pc, constraints, i, servers = [],
	                iceServerUrl, stunturn;

	            logger.info('useIceServer: ' + useIceServer);
	            if (useIceServer) {
	                iceServerUrl = self.getIceServerUrl();
	            }

	            if (iceServerUrl instanceof Array) {
	                for (i = 0; i < iceServerUrl.length; i++) {
	                    servers[i] = iceServerUrl[i];
	                }
	            } else if (!iceServerUrl || iceServerUrl === "") {
	                servers = [];
	            } else {
	                servers[0] = iceServerUrl;
	            }
	            stunturn = {
	                iceServers: servers
	            };

	            constraints = {
	                "optional": [{
	                    "DtlsSrtpKeyAgreement": self.isDtlsEnabled()
	                }]
	            };
	            pc = self.getRtcLibrary().createRTCPeerConnection(stunturn, constraints);

	            self.setPeerCount(self.getPeerCount() + 1);
	            call.peer = pc;

	            pc.onconnecting = function(event) {
	                self.onSessionConnecting(call, event);
	            };
	            pc.onopen = function(event) {
	                self.onSessionOpened(call, event);
	            };
	            pc.onsignalingstatechange = function(event) {
	                self.onSignalingStateChange(call, event);
	            };
	            pc.onaddstream = function(event) {
	                self.onRemoteStreamAdded(call, event);
	            };
	            pc.onremovestream = function(event) {
	                self.onRemoteStreamRemoved(call, event);
	            };
	            pc.onicecandidate = function(event) {
	                if (event.currentTarget.iceGatheringState === "complete") {
	                    logger.debug("ice gathering complete");
	                    self.onIceComplete(call);
	                } else {
	                    self.setupIceCandidateCollectionTimer(call);
	                    self.onIceCandidate(call, event);
	                }
	            };
	            pc.onicecomplete = function() {
	                self.onIceComplete(call);
	            };
	            pc.oniceconnectionstatechange = function(event) {
	                self.oniceconnectionstatechange(call, event);
	            };
	            pc.ondatachannel = function(event) {
	                self.onDataChannel(call, event);
	            };
	            logger.info("create PeerConnection successfully.");

	            self.setupWebrtcLogCollectionTimer(call);

	            onSuccess(call);
	        } catch (err) {
	            logger.error("Failed to create PeerConnection, exception: " + err.message);
	            onFailure();
	        }
	    };

	    self.createNewPeerForCall = function(data) {
	        var call = data.call,
	            mustCreatePeer = data.mustCreatePeer,
	            oldSessionId = _sdpParser.getSessionIdFromSdp(data.oldSdp),
	            newSessionId = _sdpParser.getSessionIdFromSdp(data.newSdp),
	            isNewPeerCreated = false,
	            oldPeer,
	            videoTrack,
	            telephoneEventPayloadChanged = _sdpParser.hasCodecPayloadChanged(data.oldSdp, data.newSdp);

	        if (mustCreatePeer || telephoneEventPayloadChanged || oldSessionId !== newSessionId) {
	            if (call.peer) {
	                oldPeer = call.peer;
	                self.collectWebRtcStats(call.sdp, oldPeer,
	                    function(stats) {
	                        logger.debug("collectWebRtcStats successfull");
	                        if (call.stats === undefined) {
	                            call.stats = [];
	                        }
	                        call.stats.push(stats);
	                        if (oldPeer.signalingState !== "closed") {
	                            oldPeer.close();
	                        }
	                        self.setPeerCount(self.getPeerCount() - 1);
	                        call.dtmfSender = null;
	                    },
	                    function() {
	                        logger.debug("collectWebRtcStats failed");
	                        if (oldPeer.signalingState !== "closed") {
	                            oldPeer.close();
	                        }
	                        self.setPeerCount(self.getPeerCount() - 1);
	                        call.dtmfSender = null;
	                    });
	            }

	            logger.trace("Creating new peer for call: " + call.id);
	            self.createPeer(call, data.useIceServer, function createPeerSuccessCallback() {
	                logger.trace("New peer has created for call: " + call.id);
	                if (data.deleteVideoStream) {
	                    videoTrack = call.localMedia.stream.getVideoTracks()[0];
	                    call.localMedia.stream.removeTrack(videoTrack);
	                }
	                call.peer.addStream(call.localMedia.stream);
	                isNewPeerCreated = true;
	            }, function createPeerFailureCallback() {
	                logger.error("New peer creation has failed!: " + call.id);
	                if (call.stats) {
	                    call.stats.pop();
	                }
	            });
	        }
	        return isNewPeerCreated;
	    };

	    /*
	     * Gets remote video resolutions with the order below
	     * remoteVideoHeight-remoteVideoWidth
	     *
	     * Native implementation lies on webRtcAdaptor.js
	     */
	    self.getRemoteVideoResolutions = function() {
	        var remoteResolution = [],
	            remoteVideoHeight,
	            remoteVideoWidth;

	        if (self.getRemoteVideoContainer()) {
	            if (!self.getRemoteVideoContainer().firstChild) {
	                return remoteResolution;
	            }

	            remoteVideoHeight = self.getRemoteVideoContainer().firstChild.videoHeight;
	            remoteVideoWidth = self.getRemoteVideoContainer().firstChild.videoWidth;

	        } else {
	            if (!self.getDefaultVideoContainer().firstElementChild.firstChild) {
	                return remoteResolution;
	            }

	            remoteVideoHeight = self.getDefaultVideoContainer().firstElementChild.firstChild.videoHeight;
	            remoteVideoWidth = self.getDefaultVideoContainer().firstElementChild.firstChild.videoWidth;
	        }

	        logger.debug("remote video resolutions of plugin webrtc...");
	        logger.debug("remoteVideoWidth  : " + remoteVideoWidth);
	        logger.debug("remoteVideoHeight : " + remoteVideoHeight);

	        remoteResolution.push(remoteVideoHeight);
	        remoteResolution.push(remoteVideoWidth);

	        self.getLocalVideoResolutions();

	        return remoteResolution;
	    };

	    /*
	     * Gets local video resolutions with the order below
	     * localVideoHeight-localVideoWidth
	     *
	     * Native implementation lies on webRtcAdaptor.js
	     */
	    self.getLocalVideoResolutions = function() {
	        var localResolution = [],
	            localVideoHeight,
	            localVideoWidth;

	        if (self.getLocalVideoContainer()) {
	            if (!self.getLocalVideoContainer().firstChild) {
	                return localResolution;
	            }

	            localVideoHeight = self.getLocalVideoContainer().firstChild.videoHeight;
	            localVideoWidth = self.getLocalVideoContainer().firstChild.videoWidth;

	        } else {
	            if (!self.getDefaultVideoContainer().lastElementChild.firstChild) {
	                return localResolution;
	            }

	            localVideoHeight = self.getDefaultVideoContainer().lastElementChild.firstChild.videoHeight;
	            localVideoWidth = self.getDefaultVideoContainer().lastElementChild.firstChild.videoWidth;
	        }

	        logger.debug("local video resolutions of plugin webrtc...");
	        logger.debug("localVideoWidth  : " + localVideoWidth);
	        logger.debug("localVideoHeight : " + localVideoHeight);

	        localResolution.push(localVideoHeight);
	        localResolution.push(localVideoWidth);

	        return localResolution;
	    };

	    // Native implementation lies on webRtcAdaptor.js
	    self.refreshVideoRenderer = function() {
	        return;
	    };

	    // Native implementation lies on webRtcAdaptor.js
	    self.sendIntraFrame = function() {
	        return;
	    };

	    // Native implementation lies on webRtcAdaptor.js
	    self.sendBlackFrame = function() {
	        return;
	    };

	    // Native implementation lies on webRtcAdaptor.js
	    self.disposeStreamRenderer = function(container) {
	        if (container) {
	            container.innerHTML = "";
	        }
	    };

	    self.sendInbandDTMF = function(call, tone, audioContext) {
	        var oscillator1, oscillator2, freq1, freq2, gainNode, mediaStreamDestination;

	        logger.info("sending inband DTMF tone: " + tone);
	        if (tone === "1") {
	            freq1 = "697";
	            freq2 = "1209";
	        }
	        if (tone === "2") {
	            freq1 = "697";
	            freq2 = "1336";
	        }
	        if (tone === "3") {
	            freq1 = "697";
	            freq2 = "1477";
	        }
	        if (tone === "4") {
	            freq1 = "770";
	            freq2 = "1209";
	        }
	        if (tone === "5") {
	            freq1 = "770";
	            freq2 = "1336";
	        }
	        if (tone === "6") {
	            freq1 = "770";
	            freq2 = "1477";
	        }
	        if (tone === "7") {
	            freq1 = "852";
	            freq2 = "1209";
	        }
	        if (tone === "8") {
	            freq1 = "852";
	            freq2 = "1336";
	        }
	        if (tone === "9") {
	            freq1 = "852";
	            freq2 = "1477";
	        }
	        if (tone === "*") {
	            freq1 = "941";
	            freq2 = "1209";
	        }
	        if (tone === "0") {
	            freq1 = "941";
	            freq2 = "1336";
	        }
	        if (tone === "#") {
	            freq1 = "941";
	            freq2 = "1477";
	        }

	        mediaStreamDestination = call.localMedia.mediaStreamDestination;

	        oscillator1 = audioContext.createOscillator();
	        oscillator1.type = 'sine';
	        oscillator1.frequency.value = freq1;
	        gainNode = audioContext.createGain ? audioContext.createGain() : audioContext.createGainNode();
	        oscillator1.connect(gainNode, 0, 0);
	        gainNode.connect(mediaStreamDestination);
	        gainNode.gain.value = 0.1;
	        oscillator1.start();

	        oscillator2 = audioContext.createOscillator();
	        oscillator2.type = 'sine';
	        oscillator2.frequency.value = freq2;
	        gainNode = audioContext.createGain ? audioContext.createGain() : audioContext.createGainNode();
	        oscillator2.connect(gainNode);
	        gainNode.connect(mediaStreamDestination);
	        gainNode.gain.value = 0.1;
	        oscillator2.start();

	        setTimeout(function() {
	            oscillator1.disconnect();
	            oscillator2.disconnect();
	        }, 100);
	    };

	    /**
	     * Send DTMF tone
	     * Native implementation lies on webRtcAdaptor.js
	     *
	     * @ignore
	     * @name rtc.sendDTMF
	     * @function
	     * @param {Object} call internalCall
	     * @param {String} tone DTMF tone
	     */
	    self.sendDTMF = function(call, tone) {
	        var audioContext, localAudioTrack;

	        if (!_sdpParser.isSdpHasTelephoneEvent(call.peer.remoteDescription.sdp)) {
	            audioContext = call.localMedia.audioContext;
	            self.sendInbandDTMF(call, tone, audioContext);
	        } else {
	            logger.info("sending outband DTMF tone: " + tone);
	            if (!call.dtmfSender) {
	                localAudioTrack = self.getLocalAudioTrack(call.peer);
	                if (!localAudioTrack) {
	                    return;
	                }
	                call.dtmfSender = call.peer.createDTMFSender(localAudioTrack);
	                if (!call.dtmfSender) {
	                    return;
	                }
	            }

	            if (call.dtmfSender.canInsertDTMF === true) {
	                call.dtmfSender.insertDTMF(tone, 400);
	            } else {
	                logger.error("Failed to execute 'insertDTMF' on 'RTCDTMFSender': The 'canInsertDTMF' attribute is false: this sender cannot send DTMF");
	            }
	        }
	    };

	    self.showSettingsWindow = function() {
	        self.getRtcLibrary().showSettingsWindow();
	    };

	    self.set_logSeverityLevel = function(level) {
	        self.getRtcLibrary().set_logSeverityLevel(level);
	    };

	    self.enable_logCallback = function() {
	        var pluginLogger = _logManager.getLogger("rtcPlugin");
	        self.getRtcLibrary().enable_logCallback(pluginLogger);
	    };

	    self.disable_logCallback = function() {
	        self.getRtcLibrary().disable_logCallback();
	    };

	    self.get_audioInDeviceCount = function() {
	        return self.getRtcLibrary().get_audioInDeviceCount();
	    };

	    self.get_audioOutDeviceCount = function() {
	        return self.getRtcLibrary().get_audioOutDeviceCount();
	    };

	    self.get_videoDeviceCount = function() {
	        return self.getRtcLibrary().get_videoDeviceCount();
	    };

	    // set local client's video send status
	    self.setOriginatorSendLocalVideo = function(call, tSdp, status) {
	        var videoSendEnabled = _sdpParser.isVideoSdpEnabled(tSdp);
	        call.canOrigSendVideo = status && videoSendEnabled;
	    };

	    // check if local client sends video
	    self.canOriginatorSendLocalVideo = function(call) {
	        return call.canOrigSendVideo;
	    };

	    // set local client's video receive status
	    self.setOriginatorReceiveRemoteVideo = function(call) {
	        call.canOrigReceiveVideo = _sdpParser.isVideoSdpEnabled(call.sdp);
	    };

	    // check if local client receives video
	    self.canOriginatorReceiveRemoteVideo = function(call) {
	        return call.canOrigReceiveVideo;
	    };

	    self.setTcpSetupAttiributesOnProcessAnswer = function(call, sdp) {
	        var isDtlsEnabled = self.isDtlsEnabled();

	        if (!isDtlsEnabled) {
	            return;
	        }

	        // this is occuring after mid-call events.
	        // once 'remoteTcpSetupAttribute' is set, it must not change
	        if (call.remoteTcpSetupAttribute) {
	            logger.debug("Remote TCP setup attribute [" + call.remoteTcpSetupAttribute + "] exists, not changing it...");
	            return;
	        }

	        call.remoteTcpSetupAttribute = _sdpParser.getTcpSetupAttribute(sdp);
	        if (call.remoteTcpSetupAttribute === CONSTANTS.SDP.SETUP_ACTIVE) {
	            call.localTcpSetupAttribute = CONSTANTS.SDP.SETUP_PASSIVE;
	        } else if (call.remoteTcpSetupAttribute === CONSTANTS.SDP.SETUP_PASSIVE) {
	            call.localTcpSetupAttribute = CONSTANTS.SDP.SETUP_ACTIVE;
	        } else {
	            logger.debug("Not handling remote TCP setup attribute: " + call.remoteTcpSetupAttribute);
	        }
	    };

	    self.setTcpSetupAttiributesOnCreateAnswer = function(call, sdp) {
	        if (self.isDtlsEnabled()) {
	            call.localTcpSetupAttribute = _sdpParser.getTcpSetupAttribute(sdp);
	            if (call.localTcpSetupAttribute === CONSTANTS.SDP.SETUP_ACTIVE) {
	                call.remoteTcpSetupAttribute = CONSTANTS.SDP.SETUP_PASSIVE;
	            } else if (call.localTcpSetupAttribute === CONSTANTS.SDP.SETUP_PASSIVE) {
	                call.remoteTcpSetupAttribute = CONSTANTS.SDP.SETUP_ACTIVE;
	            } else {
	                logger.debug("Not handling remote TCP setup attribute: " + call.remoteTcpSetupAttribute);
	            }
	        }
	    };

	    self.clearTcpSetupParameters = function (call) {
	        call.localTcpSetupAttribute = undefined;
	        call.remoteTcpSetupAttribute = undefined;
	    };

	    /*
	     * Native implementation lies on webRtcAdaptor.js
	     */
	    self.privateGetUserMedia = function(params) {
	        self.getRtcLibrary().checkMediaSourceAvailability(function mediaSourceCallback() {
	            var mediaInfo, privateMedia,
	                constraints = {
	                    audio: params.options.audioConstraints,
	                    video: params.options.videoConstraints
	                };

	            self.getRtcLibrary().getUserMedia(constraints, function privateGetUserMediaSuccessCallback(stream) {
	                privateMedia = {
	                    stream: stream,
	                    privateStream: params.options.privateStream
	                };
	                self.getPrivateStreamMap().add(stream.id, privateMedia);

	                mediaInfo = {
	                    id: stream.id,
	                    stream: stream,
	                    streamURL: self.getRtcLibrary().getURLFromStream(stream)
	                };
	                _utils.callFunctionIfExist(params.onSuccess, mediaInfo);
	            }, function privateGetUserMediaFailureCallback() {
	                _utils.callFunctionIfExist(params.onFailure, _mediaErrors.NOT_ALLOWED);
	            });
	        });
	    };

	    /*
	     * Native implementation lies on webRtcAdaptor.js
	     */
	    self.getCameraList = function(onSuccess) {
	        var index, cameraList = [],
	            sourceList = [];
	        self.getRtcLibrary().checkMediaSourceAvailability(function mediaSourceCallback(mediaSourceInfo) {
	            sourceList = mediaSourceInfo.sourceList;
	            for (index = 0; index < sourceList.length; index++) {
	                if (sourceList[index].kind === "video" || sourceList[index].kind === "videoinput") {
	                    cameraList.push(sourceList[index]);
	                }
	            }
	            _utils.callFunctionIfExist(onSuccess, cameraList);
	        });
	    };

	    /*
	     * Native implementation lies on webRtcAdaptor.js
	     */
	    self.getMicrophoneList = function(onSuccess) {
	        var index, microphoneList = [],
	            sourceList = [];
	        self.getRtcLibrary().checkMediaSourceAvailability(function mediaSourceCallback(mediaSourceInfo) {
	            sourceList = mediaSourceInfo.sourceList;
	            for (index = 0; index < sourceList.length; index++) {
	                if (sourceList[index].kind === "audio" || sourceList[index].kind === "audioinput") {
	                    microphoneList.push(sourceList[index]);
	                }
	            }
	            _utils.callFunctionIfExist(onSuccess, microphoneList);
	        });
	    };

	    /*
	     * Native implementation lies on webRtcAdaptor.js
	     */
	    self.getSpeakerList = function(onSuccess) {
	        var index, speakerList = [],
	            sourceList = [];
	        self.getRtcLibrary().checkMediaSourceAvailability(function mediaSourceCallback(mediaSourceInfo) {
	            sourceList = mediaSourceInfo.sourceList;
	            for (index = 0; index < sourceList.length; index++) {
	                if (sourceList[index].kind === "audiooutput") {
	                    speakerList.push(sourceList[index]);
	                }
	            }
	            _utils.callFunctionIfExist(onSuccess, speakerList);
	        });
	    };

	    self.removeStreamById = function(id) {
	        var localStream = self.getStreamById(id);
	        if (localStream) {
	            self.getRtcLibrary().stopStream(localStream.stream);
	            self.removeStreamFromMap(id);
	        }
	    };

	    logger.debug('WebRtcAdaptor initialized');
	};

	//@{fcs-jsl-prod}
	var WebRtcAdaptor = function(_super, _decorator, _model) {
	    return new WebRtcAdaptorImpl(_super, _decorator, _model, logManager, utils, sdpParser, fcs.call.MediaErrors, cache, fcs);
	};
	//@{fcs-jsl-prod}


	var WebRtcPluginAdaptorImpl = function(_super, _decorator, _model, _logManager, _utils, _sdpParser, _mediaErrors, _cache, _fcs) {
	    var self = this,
	        logger = _logManager.getLogger("WebRtcPluginAdaptorImpl");

	    logger.debug('WebRtcPluginAdaptor initializing');

	    _utils.compose(_super, self);
	    _utils.compose(_model, self);

	    self.setPluginEnabled(true);

	    //This function is called internally when we make a new call or hold/unhold scenario
	    // Enabler implementation lies on webRtcPluginAdaptor.js
	    self.addLocalStream = function(internalCall) {
	        var streamUrl, fireEvent = false,
	            isSendingLocalVideo = self.canOriginatorSendLocalVideo(internalCall);

	        if (internalCall.localMedia.stream) {
	            if (isSendingLocalVideo) {
	                streamUrl = self.getRtcLibrary().getURLFromStream(internalCall.localMedia.stream);

	                if (streamUrl) {
	                    if (self.getDefaultVideoContainer()) {
	                        fireEvent = self.useDefaultRenderer(streamUrl, true);
	                    } else if (self.getLocalVideoContainer()) {
	                        fireEvent = self.createStreamRenderer(streamUrl, self.getLocalVideoContainer(), {
	                            muted: true
	                        });
	                    } else {
	                        internalCall.call.localStreamURL = streamUrl;
	                        fireEvent = true;
	                    }
	                }
	            } else {
	                if (self.getDefaultVideoContainer()) {
	                    if (self.getDefaultVideoContainer().lastElementChild) {
	                        self.disposeStreamRenderer(self.getDefaultVideoContainer().lastElementChild);
	                    }
	                } else if (self.getLocalVideoContainer()) {
	                    self.disposeStreamRenderer(self.getLocalVideoContainer());
	                }
	            }

	            logger.debug("onLocalStreamAdded: " + streamUrl);
	            if (fireEvent) {
	                self.fireOnLocalStreamAddedEvent(internalCall, streamUrl);
	            }
	        }
	    };

	    self.performSdpWorkaroundsBeforeProcessingIncomingSdp = function(call) {
	        call.sdp = _sdpParser.deleteBandwidthLineFromSdp(call.sdp);
	        call.sdp = _sdpParser.removeG722Codec(call.sdp);
	    };

	    // Enabler implementation lies on webRtcPluginAdaptor.js
	    // initEnablerMedia
	    self.initMedia = function(onSuccess, onFailure, options) {
	        var mainContainer = document.body,
	            rtcPlugin = {},
	            verifyPlugin = true,
	            mediaErrors = _mediaErrors,
	            onloadParam,
	            size = "1px",
	            pluginid = "fcsPlugin",
	            applicationType = "application/x-gcfwenabler",
	            configuredPluginVersion = self.getPluginVersion(),
	            currentPluginVersion,
	            currentPluginVersionString;

	        logger.debug("Configured plugin version: " + configuredPluginVersion.major + "." + configuredPluginVersion.minor + "." + configuredPluginVersion.current_revision);

	        if (options) {
	            if (options.pluginLogLevel) {
	                self.setLogLevel(options.pluginLogLevel);
	            }

	            if (options.language) {
	                self.setLanguage(options.language);
	            }
	        }
	        //Callback for when the plugin is loaded
	        self.onFCSPLoaded = function() {

	            self.setRtcLibrary(_decorator(rtcPlugin));
	            if (self.isH264Enabled()) {
	                self.getRtcLibrary().enableH264();
	            }
	            self.getRtcLibrary().checkMediaSourceAvailability(function mediaSourceCallback(mediaSourceInfo) {
	                self.setMediaSources(mediaSourceInfo);
	            });
	            self.getRtcLibrary().setH264CodecStateChangeHandler(function onH264CodecStateChangeHandler(event) {
	                self.setH264Enabled(event.state);
	            });

	            currentPluginVersion = self.getRtcLibrary().getCurrentPluginVersionObject();
	            currentPluginVersionString = self.getRtcLibrary().getVersion();
	            // prevent multiple init calls
	            if (self.isInitialized()) {
	                // If the plugin is already initialized, it should call successCallback with persion
	                utils.callFunctionIfExist(onSuccess, {
	                    "pluginVersion": rtcPlugin.version
	                });
	            }
	            if (!verifyPlugin) {
	                return;
	            }
	            verifyPlugin = false;
	            logger.debug("Plugin callback");

	            fcs.setPluginVersion(currentPluginVersionString);
	            logger.debug("Installed plugin version: " + currentPluginVersionString);

	            if ((currentPluginVersionString.length < 1) ||
	                (currentPluginVersion.major !== configuredPluginVersion.major ||
	                    currentPluginVersion.minor !== configuredPluginVersion.minor) ||
	                (currentPluginVersion.revision < configuredPluginVersion.min_revision) ||
	                (currentPluginVersion.revision === configuredPluginVersion.min_revision &&
	                    currentPluginVersion.build < configuredPluginVersion.min_build)) {

	                logger.debug("Plugin version not supported");
	                _utils.callFunctionIfExist(onFailure, mediaErrors.WRONG_VERSION);
	                _utils.callFunctionIfExist(fcs.onPluginRequired, mediaErrors.WRONG_VERSION);
	            } else {
	                self.setInitialized(true);
	                if ((currentPluginVersion.revision < configuredPluginVersion.current_revision) ||
	                    (currentPluginVersion.revision === configuredPluginVersion.current_revision &&
	                        currentPluginVersion.build < configuredPluginVersion.current_build)) {

	                    logger.debug("New plugin version warning");
	                    _utils.callFunctionIfExist(onFailure, mediaErrors.NEW_VERSION_WARNING);
	                    _utils.callFunctionIfExist(fcs.onPluginRequired, mediaErrors.NEW_VERSION_WARNING);
	                } else {
	                    _utils.callFunctionIfExist(onSuccess, {
	                        "pluginVersion": rtcPlugin.version
	                    });
	                }

	                self.getRtcLibrary().setLang(self.getLanguage());
	            }

	            self.getRtcLibrary().checkMediaSourceAvailability();
	        };

	        // only check if the function exists, not its type, because in IE it is "object" (host object)
	        if (typeof mainContainer.appendChild === 'undefined') {
	            logger.debug("Could not inject plugin in container");
	            _utils.callFunctionIfExist(onFailure, mediaErrors.OPTIONS);
	            _utils.callFunctionIfExist(fcs.onPluginRequired, mediaErrors.OPTIONS);
	            return;
	        }

	        rtcPlugin = document.createElement('object');
	        onloadParam = document.createElement('param');
	        onloadParam.setAttribute("name", "onload");
	        onloadParam.setAttribute("value", "onFCSPLoaded");
	        rtcPlugin.appendChild(onloadParam);

	        rtcPlugin.id = pluginid;
	        rtcPlugin.width = rtcPlugin.height = size;

	        // Order matters for the following:
	        // For IE you need to append first so the dom is available when IE loads the plugin, which happens when the type is set.
	        // For FF you need to set the type and then append or the plugin won't load.
	        // Chrome seems happy either way.
	        try {
	            if (navigator.appName === 'Microsoft Internet Explorer') {
	                mainContainer.appendChild(rtcPlugin);
	                rtcPlugin.type = applicationType;
	            } else {
	                rtcPlugin.type = applicationType;
	                mainContainer.appendChild(rtcPlugin);
	            }
	        } catch (e) {
	            verifyPlugin = false;
	            _utils.callFunctionIfExist(onFailure, mediaErrors.NOT_FOUND);
	            _utils.callFunctionIfExist(fcs.onPluginRequired, mediaErrors.NOT_FOUND);
	        }

	        if (verifyPlugin) {
	            if (typeof document.getElementById(pluginid).createPeerConnection !== 'undefined') {
	                self.onFCSPLoaded();
	            } else {
	                //if the plugin is not initialized within 7 sec fail
	                setTimeout(function() {
	                    // for createPeerConnection, only check if it exists. It is "function" in FireFox and "object" in Chrome and IE
	                    if (!self.isInitialized()) {
	                        if (typeof document.getElementById(pluginid).createPeerConnection === 'undefined') {
	                            _utils.callFunctionIfExist(onFailure, mediaErrors.NOT_FOUND);
	                            _utils.callFunctionIfExist(fcs.onPluginRequired, mediaErrors.NOT_FOUND);
	                        } else {
	                            self.onFCSPLoaded();
	                        }
	                    }
	                }, 7000);
	            }
	        }
	    };

	    // Enabler implementation lies on webRtcPluginAdaptor.js
	    self.getUserMedia = function(params) {
	        self.getRtcLibrary().checkMediaSourceAvailability(function getUserMediaCallback(mediaSourceInfo) {
	            var mediaInfo, constraints = {
	                    audio: false,
	                    video: false
	                },
	                localMedia;
	            self.setMediaSources(mediaSourceInfo);

	            if (mediaSourceInfo) {
	                if (!mediaSourceInfo.audioSourceAvailable) {
	                    logger.debug("Failed to get access to local media.");
	                    _utils.callFunctionIfExist(params.onFailure, _mediaErrors.NOT_FOUND);
	                    return;
	                }
	            }

	            if (self.getMediaVideo() && self.getVideoSourceAvailable()) {
	                constraints.video = params.options.videoConstraints;
	            }
	            if (self.getMediaAudio() && self.getAudioSourceAvailable()) {
	                constraints.audio = params.options.audioConstraints;
	            }
	            logger.debug("Plugin version:" + self.getRtcLibrary().version);
	            logger.debug("getUserMedia - constraints: ", constraints);
	            self.getRtcLibrary().getUserMedia(constraints, function getUserMediaSuccessCallback(stream) {
	                localMedia = {
	                    audioContext: {
	                        close: function() {}
	                    },
	                    mediaStreamDestination: {
	                        disconnect: function() {}
	                    },
	                    stream: stream,
	                    originalStream: stream
	                };
	                self.setLocalMedia(localMedia);
	                self.getLocalStreamMap().add(localMedia.stream.label, localMedia);
	                self.setInitialized(true);

	                mediaInfo = {
	                    audio: self.getMediaAudio(),
	                    video: self.getMediaVideo(),
	                    id: localMedia.stream.label,
	                    originalStream: stream,
	                    streamURL: self.getRtcLibrary().getURLFromStream(stream)
	                };

	                logger.debug("user has granted access to local media: ", localMedia);
	                _utils.callFunctionIfExist(params.onSuccess, mediaInfo);
	            }, function getUserMediaFailureCallback(error) {
	                logger.debug("Failed to get access to local media. Error code was " + error.code);
	                _utils.callFunctionIfExist(params.onFailure, _mediaErrors.NOT_ALLOWED);
	            });
	        });
	    };

	    self.createDataChannelAnswer = function(call, successCallback, failureCallback, mandatorySettings) {
	        logger.debug("createDataChannelAnswer: state= " + call.peer.signalingState);
	        var peer = call.peer,
	            localDesc;

	        if (!mandatorySettings) {
	            mandatorySettings = self.getRtcLibrary().createConstraints(self.getMediaAudio(), self.getMediaVideo());
	        }

	        self.setRemoteDescription(call, peer, CONSTANTS.WEBRTC.RTC_SDP_TYPE.OFFER, call.sdp, function createAnswerSetRemoteDescriptionSuccessCallback() {
	            peer.createAnswer(peer.remoteDescription, function createAnswerSuccessCallback(oSdp) {
	                localDesc = self.getRtcLibrary().createRTCSessionDescription(CONSTANTS.WEBRTC.RTC_SDP_TYPE.ANSWER, oSdp.sdp);
	                peer.setLocalDescription(localDesc, function createAnswerSetLocalDescriptionSuccessCallback() {
	                    logger.debug("createDataChannelAnswer: setLocalDescription success");
	                    //Due to stun requests, successCallback will be called by onNativeIceCandidate()
	                }, function createAnswerSetLocalDescriptionFailureCallback(e) {
	                    logger.error("createDataChannelAnswer: setLocalDescription failed : " + e);
	                    _utils.callFunctionIfExist(failureCallback, "createAnswer setLocalDescription failed");
	                });
	            }, function createAnswerFailureCallback(e) {
	                logger.error("createDataChannelAnswer: failed!!" + e);
	                _utils.callFunctionIfExist(failureCallback, "Session cannot be created ");
	            }, mandatorySettings);
	        }, function createAnswerSetRemoteDescriptionFailureCallback(e) {
	            logger.error("createDataChannelAnswer setRemoteDescription failed : " + e);
	        });
	    };

	    /*
	     * Enabler implementation lies on webRtcPluginAdaptor.js
	     * createEnablerOffer to be used when the enabler plugin is enabled.
	     */
	    self.createOffer = function(call, successCallback, failureCallback, sendInitialVideo) {
	        logger.debug("createOffer: sendInitialVideo= " + sendInitialVideo + " state= " + call.peer.signalingState);
	        var peer = call.peer;

	        call.peer.addStream(call.localMedia.stream);

	        peer.createOffer(function createOfferSuccessCallback(oSdp) {
	            sendInitialVideo = sendInitialVideo && self.getVideoSourceAvailable();
	            if (sendInitialVideo) {
	                oSdp.sdp = _sdpParser.updateVideoSdpDirection(oSdp.sdp, CONSTANTS.WEBRTC.MEDIA_STATE.SEND_RECEIVE);
	            } else {
	                oSdp.sdp = _sdpParser.updateVideoSdpDirection(oSdp.sdp, CONSTANTS.WEBRTC.MEDIA_STATE.RECEIVE_ONLY);
	            }

	            oSdp.sdp = _sdpParser.deleteCryptoZeroFromSdp(oSdp.sdp);

	            oSdp.sdp = _sdpParser.removeG722Codec(oSdp.sdp);

	            oSdp.sdp = _sdpParser.deleteCryptoFromSdp(oSdp.sdp, self.isDtlsEnabled());
	            oSdp.sdp = _sdpParser.setTcpSetupAttributeToActpass(oSdp.sdp, self.isDtlsEnabled());

	            oSdp.sdp = self.updateCodecs(call, oSdp.sdp);

	            self.muteOnHold(call, false);
	            peer.setLocalDescription(
	                self.getRtcLibrary().createRTCSessionDescription(CONSTANTS.WEBRTC.RTC_SDP_TYPE.OFFER, oSdp.sdp),
	                function createOfferSetLocalDescriptionSuccessCallback() {
	                    //Due to stun requests, successCallback will be called by onNativeIceCandidate()
	                },
	                function createOfferSetLocalDescriptionFailureCallback(error) {
	                    logger.error("createOffer: setLocalDescription failed : " + error);
	                    _utils.callFunctionIfExist(failureCallback, "createOffer: setLocalDescription failed");
	                }
	            );

	        }, function createOfferFailureCallback(error) {
	            logger.error("createOffer: createOffer failed!! " + error);
	            _utils.callFunctionIfExist(failureCallback);
	        }, self.getRtcLibrary().createConstraints(self.getMediaAudio(), self.getMediaVideo()));
	    };

	    /*
	     * createEnablerAnswer to be used when the enabler plugin is enabled
	     * Enabler implementation lies on webRtcPluginAdaptor.js
	     */
	    self.createAnswer = function(call, successCallback, failureCallback, isVideoEnabled) {
	        logger.debug("createAnswer: isVideoEnabled= " + isVideoEnabled + " state= " + call.peer.signalingState);
	        var peer = call.peer,
	            newSdp;

	        call.sdp = _sdpParser.checkSupportedVideoCodecs(call.sdp, null, self.isH264Enabled());
	        call.sdp = _sdpParser.changeDirection(call.sdp, CONSTANTS.WEBRTC.MEDIA_STATE.INACTIVE, CONSTANTS.WEBRTC.MEDIA_STATE.SEND_RECEIVE, CONSTANTS.STRING.AUDIO);
	        call.sdp = _sdpParser.deleteFingerprintOrCrypto(call.sdp, self.isDtlsEnabled());

	        if (!_sdpParser.isSdpVideoSendEnabled(call.sdp)) {
	            // delete ssrc only from video, keep audio ssrc to hear audio
	            call.sdp = _sdpParser.deleteInactiveVideoSsrc(call.sdp);
	        }

	        self.setRemoteDescription(call, peer, CONSTANTS.WEBRTC.RTC_SDP_TYPE.OFFER, call.sdp,
	            function createAnswerSetRemoteDescriptionSuccessCallback() {
	                call.peer.addStream(call.localMedia.stream);
	                call.remoteVideoState = _sdpParser.getVideoSdpDirection(call.sdp);

	                // set answer SDP to localDescriptor for the offer
	                peer.createAnswer(peer.remoteDescription,
	                    function createAnswerSuccessCallback(oSdp) {
	                        newSdp = _sdpParser.getSdpFromObject(oSdp);
	                        oSdp = null;
	                        isVideoEnabled = isVideoEnabled && self.getVideoSourceAvailable() && _sdpParser.isSdpHasVideo(call.sdp);

	                        if (isVideoEnabled) {
	                            if (_sdpParser.isSdpVideoSendEnabled(call.sdp)) {
	                                newSdp = _sdpParser.updateVideoSdpDirection(newSdp, CONSTANTS.WEBRTC.MEDIA_STATE.SEND_RECEIVE);
	                            } else {
	                                if (_sdpParser.getVideoSdpDirection(call.sdp) !== CONSTANTS.WEBRTC.MEDIA_STATE.INACTIVE) {
	                                    newSdp = _sdpParser.updateVideoSdpDirection(newSdp, CONSTANTS.WEBRTC.MEDIA_STATE.SEND_ONLY);
	                                } else {
	                                    newSdp = _sdpParser.updateVideoSdpDirection(newSdp, CONSTANTS.WEBRTC.MEDIA_STATE.INACTIVE);
	                                }
	                            }
	                        } else {
	                            if (_sdpParser.isSdpVideoSendEnabled(call.sdp)) {
	                                newSdp = _sdpParser.updateVideoSdpDirection(newSdp, CONSTANTS.WEBRTC.MEDIA_STATE.RECEIVE_ONLY);
	                            } else {
	                                newSdp = _sdpParser.updateVideoSdpDirection(newSdp, CONSTANTS.WEBRTC.MEDIA_STATE.INACTIVE);
	                            }
	                        }

	                        logger.debug("doAnswer(plugin) - isSdpEnabled audio : " + _sdpParser.isAudioSdpEnabled(newSdp));
	                        logger.debug("doAnswer(plugin) - isSdpEnabled video : " + _sdpParser.isVideoSdpEnabled(newSdp));

	                        if (_sdpParser.isSdpHasAudio(newSdp) || _sdpParser.isSdpHasVideo(newSdp)) {

	                            // createAnswer generates an sdp without ice params
	                            // copy ice params to the local sdp
	                            // scenario: incoming video call from pcc in brokeronly config
	                            newSdp = _sdpParser.checkAndRestoreICEParams(newSdp, call.sdp);

	                            self.muteOnHold(call, false);
	                            peer.setLocalDescription(
	                                self.getRtcLibrary().createRTCSessionDescription(CONSTANTS.WEBRTC.RTC_SDP_TYPE.ANSWER, newSdp),
	                                function createAnswerSetLocalDescriptionSuccessCallback() {
	                                    //Due to stun requests, successCallback will be called by onNativeIceCandidate()
	                                },
	                                function createAnswerSetLocalDescriptionFailureCallback(e) {
	                                    logger.error("createAnswer: setLocalDescription failed : " + e);
	                                    _utils.callFunctionIfExist(failureCallback, "createAnswer setLocalDescription failed");
	                                });
	                        } else {
	                            logger.error("createrAnswer: createAnswer failed!!");
	                            _utils.callFunctionIfExist(failureCallback, "No codec negotiation");
	                        }
	                    },
	                    function createAnswerFailureCallback(e) {
	                        logger.error("createAnswer: failed!!" + e);
	                        _utils.callFunctionIfExist(failureCallback, "Session cannot be created ");
	                    }, self.getRtcLibrary().createConstraints(self.getMediaAudio(), self.getMediaVideo()));
	            },
	            function createAnswerSetRemoteDescriptionFailureCallback(e) {
	                logger.error("createAnswer setRemoteDescription failed : " + e);
	            });
	    };

	    /*
	     * Enabler implementation lies on webRtcPluginAdaptor.js
	     * createEnablerUpdate to be used when the video start or stop
	     */
	    self.createUpdate = function(call, successCallback, failureCallback, isVideoStart, useIceServer) {
	        logger.debug("createEnablerUpdate: isVideoStart= " + isVideoStart + " state= " + call.peer.signalingState);
	        var peer = call.peer,
	            localDesc, localSdp = call.stableLocalSdp;

	        if (self.createNewPeerForCall({
	                call: call,
	                mustCreatePeer: call.isRemoteEndFirefox,
	                useIceServer: useIceServer
	            })) {
	            peer = call.peer;
	        }
	        self.getRtcLibrary().updateStream(peer, call);

	        peer.createOffer(function createUpdateCreateOfferSuccessCallback(obj) {
	            isVideoStart = isVideoStart && self.getVideoSourceAvailable();
	            if (isVideoStart) {
	                obj.sdp = _sdpParser.updateVideoSdpDirection(obj.sdp, CONSTANTS.WEBRTC.MEDIA_STATE.SEND_RECEIVE);
	            } else {
	                if (_sdpParser.isVideoSdpDirectionInactive(call.stableRemoteSdp)) {
	                    obj.sdp = _sdpParser.updateVideoSdpDirectionToInactive(obj.sdp);
	                } else {
	                    obj.sdp = _sdpParser.updateVideoSdpDirection(obj.sdp, CONSTANTS.WEBRTC.MEDIA_STATE.RECEIVE_ONLY);
	                }
	            }
	            obj.sdp = self.updateCodecs(call, obj.sdp);
	            obj.sdp = _sdpParser.updateH264Level(obj.sdp);

	            if ((_sdpParser.isIceLite(call.sdp) && self.isVideoDirectionsSendRecv(peer.localDescription.sdp, peer.remoteDescription.sdp)) &&
	                !call.isRemoteEndFirefox &&
	                !self.iceCredentialsChanged(localSdp, obj.sdp)) {
	                logger.debug("createUpdate new solution ");
	                successCallback(obj.sdp);
	            } else {
	                logger.debug("createUpdate old solution ");

	                obj.sdp = _sdpParser.updateVersion(localSdp, obj.sdp);
	                obj.sdp = _sdpParser.setTcpSetupAttributeToActpass(obj.sdp, self.isDtlsEnabled());
	                obj.sdp = _sdpParser.deleteCryptoZeroFromSdp(obj.sdp);
	                obj.sdp = _sdpParser.removeG722Codec(obj.sdp);
	                obj.sdp = _sdpParser.deleteCryptoFromSdp(obj.sdp, self.isDtlsEnabled());

	                localDesc = self.getRtcLibrary().createRTCSessionDescription(CONSTANTS.WEBRTC.RTC_SDP_TYPE.OFFER, obj.sdp);

	                peer.setLocalDescription(localDesc, function createUpdateCreateOfferSetLocalDescriptionSuccessCallback() {
	                    logger.debug("createUpdate setLocalDescription success. iceConnectionState: " + peer.iceConnectionState + " iceGatheringState: " + peer.iceGatheringState);
	                    if (peer.iceGatheringState === "complete") {
	                        if (call.successCallback) {
	                            logger.debug("createUpdate iceGatheringState completed " + peer.localDescription.sdp);
	                            _utils.callFunctionIfExist(successCallback, peer.localDescription.sdp);
	                        }
	                    }
	                }, function crateUpdateCreateOfferSetLocalDescriptionFailureCallback(e) {
	                    logger.debug("createUpdate: createOffer setLocalDescription failed: " + e);
	                    _utils.callFunctionIfExist(failureCallback);
	                });
	            }
	        }, function createUpdateCrateOfferFailureCallback(e) {
	            logger.debug("createUpdate: createOffer failed!!: " + e);
	            _utils.callFunctionIfExist(failureCallback);
	        }, self.getRtcLibrary().createConstraints(self.getMediaAudio(), self.getMediaVideo()));
	    };

	    /*
	     * Enabler implementation lies on webRtcPluginAdaptor.js
	     * createEnablerHoldUpdate to be used when the enabler plugin is enabled
	     */
	    self.createHoldUpdate = function(call, hold, remote_hold_status, successCallback, failureCallback, useIceServer) {
	        logger.debug("createHoldUpdate: local hold= " + hold + " remote hold= " + remote_hold_status + " state= " + call.peer.signalingState);
	        var peer = call.peer,
	            localDescObj,
	            localSdp;

	        localSdp = call.stableLocalSdp;

	        if (self.createNewPeerForCall({
	                call: call,
	                mustCreatePeer: call.isRemoteEndFirefox,
	                useIceServer: useIceServer
	            })) {
	            peer = call.peer;
	        }

	        peer.createOffer(function createHoldUpdateCreateOfferSuccessCallback(obj) {

	            if (hold) {
	                if (!remote_hold_status) {
	                    obj.sdp = _sdpParser.updateAudioSdpDirection(obj.sdp, CONSTANTS.WEBRTC.MEDIA_STATE.SEND_ONLY);
	                    obj.sdp = _sdpParser.updateVideoSdpDirection(obj.sdp, CONSTANTS.WEBRTC.MEDIA_STATE.SEND_ONLY);
	                } else {
	                    obj.sdp = _sdpParser.updateAudioSdpDirectionToInactive(obj.sdp);
	                    obj.sdp = _sdpParser.updateVideoSdpDirectionToInactive(obj.sdp);
	                }
	            } else if (remote_hold_status) {
	                obj.sdp = _sdpParser.updateAudioSdpDirection(obj.sdp, CONSTANTS.WEBRTC.MEDIA_STATE.SEND_RECEIVE);
	                obj.sdp = _sdpParser.updateVideoSdpDirection(obj.sdp, CONSTANTS.WEBRTC.MEDIA_STATE.SEND_RECEIVE);
	            } else {
	                obj.sdp = _sdpParser.updateAudioSdpDirection(obj.sdp, CONSTANTS.WEBRTC.MEDIA_STATE.SEND_RECEIVE);
	                if (self.canOriginatorSendLocalVideo(call)) {
	                    obj.sdp = _sdpParser.updateVideoSdpDirection(obj.sdp, CONSTANTS.WEBRTC.MEDIA_STATE.SEND_RECEIVE);
	                } else {
	                    obj.sdp = _sdpParser.updateVideoSdpDirection(obj.sdp, CONSTANTS.WEBRTC.MEDIA_STATE.RECEIVE_ONLY);
	                }
	            }
	            obj.sdp = self.updateCodecs(call, obj.sdp);
	            obj.sdp = _sdpParser.updateH264Level(obj.sdp);

	            if ((_sdpParser.isIceLite(call.sdp) && self.isSdpDirectionsSendRecv(peer.localDescription.sdp, peer.remoteDescription.sdp)) &&
	                !call.isRemoteEndFirefox &&
	                !self.iceCredentialsChanged(localSdp, obj.sdp)) {
	                logger.debug("createHoldUpdate new solution ");
	                _utils.callFunctionIfExist(successCallback, obj.sdp);
	            } else {
	                logger.debug("createHoldUpdate old solution ");

	                obj.sdp = _sdpParser.updateVersion(localSdp, obj.sdp);
	                obj.sdp = _sdpParser.deleteCryptoZeroFromSdp(obj.sdp);
	                obj.sdp = _sdpParser.setTcpSetupAttributeToActpass(obj.sdp, self.isDtlsEnabled());

	                localDescObj = self.getRtcLibrary().createRTCSessionDescription(CONSTANTS.WEBRTC.RTC_SDP_TYPE.OFFER, obj.sdp);

	                peer.setLocalDescription(localDescObj, function createHoldUpdateSetLocalDescriptionSuccessCallback() {
	                    logger.debug("createHoldUpdate setLocalDescription success. iceConnectionState: " + peer.iceConnectionState + " iceGatheringState: " + peer.iceGatheringState);
	                    if (peer.iceGatheringState === "complete") {
	                        if (call.successCallback) {
	                            logger.debug("createHoldUpdate iceGatheringState completed " + peer.localDescription.sdp);
	                            _utils.callFunctionIfExist(successCallback, peer.localDescription.sdp);
	                        }
	                    }
	                }, function createHoldUpdateSetLocalDescriptionFailureCallback(error) {
	                    logger.error("createHoldUpdate: setLocalDescription failed: " + error.message);
	                    _utils.callFunctionIfExist(failureCallback);
	                });
	            }
	        }, function createHoldUpdateCreateOfferFailureCallback(error) {
	            logger.error("createHoldUpdate: createOffer failed: " + error.message);
	            _utils.callFunctionIfExist(failureCallback);
	        }, self.getRtcLibrary().createConstraints(self.getMediaAudio(), self.getMediaVideo()));
	    };

	    /*
	     * Enabler implementation lies on webRtcPluginAdaptor.js
	     * processEnabler30Update to be used when the enabler plugin is enabled. (based on processEnabler30Update)
	     */
	    self.processUpdate = function(call, successCallback, failureCallback, local_hold_status, useIceServer) {
	        logger.debug("processUpdate: state= " + call.peer.signalingState);
	        var peer = call.peer,
	            localSdp, remoteAudioState, remoteVideoState, peerRemoteSdp,
	            peerLocalSdp, remoteVideoDirection, callSdpWithNoSsrc, remoteDescriptionMainProcess, data;
	        peerLocalSdp = call.stableLocalSdp;

	        if ((_sdpParser.isIceLite(call.sdp) && self.isVideoDirectionsSendRecv(peer.localDescription.sdp, peer.remoteDescription.sdp)) &&
	            !call.isRemoteEndFirefox &&
	            !self.oldSolutionNeeded(call.prevRemoteSdp, call.sdp)) {
	            logger.debug("processUpdate  new solution");

	            if (_sdpParser.isSdpVideoSendEnabled(call.sdp)) {
	                if (self.canOriginatorSendLocalVideo(call)) {
	                    peerLocalSdp = _sdpParser.updateVideoSdpDirection(peerLocalSdp, CONSTANTS.WEBRTC.MEDIA_STATE.SEND_RECEIVE);
	                } else {
	                    peerLocalSdp = _sdpParser.updateVideoSdpDirection(peerLocalSdp, CONSTANTS.WEBRTC.MEDIA_STATE.RECEIVE_ONLY);
	                }
	                if (self.getDefaultVideoContainer()) {
	                    self.useDefaultRenderer(false, false, true);
	                }
	            } else {
	                if (self.canOriginatorSendLocalVideo(call) && !_sdpParser.isVideoSdpDirectionInactive(call.sdp)) {
	                    peerLocalSdp = _sdpParser.updateVideoSdpDirection(peerLocalSdp, CONSTANTS.WEBRTC.MEDIA_STATE.SEND_ONLY);
	                } else {
	                    peerLocalSdp = _sdpParser.updateVideoSdpDirection(peerLocalSdp, CONSTANTS.WEBRTC.MEDIA_STATE.INACTIVE);
	                }
	                if (self.getDefaultVideoContainer()) {
	                    self.useDefaultRenderer(false, false, false);
	                }
	            }
	            self.setRemoteDescription(call, null, null, call.sdp);
	            peerLocalSdp = _sdpParser.setTcpSetupAttributeTo(peerLocalSdp, call.localTcpSetupAttribute, self.isDtlsEnabled());
	            _utils.callFunctionIfExist(successCallback, peerLocalSdp);
	        } else {
	            logger.debug("processUpdate  old solution");

	            // Meetme workaround. This workaround is added into native function
	            call.sdp = _sdpParser.addSdpMissingCryptoLine(call.sdp);
	            call.sdp = _sdpParser.checkAndRestoreICEParams(call.sdp, peerLocalSdp);

	            remoteVideoDirection = _sdpParser.getVideoSdpDirection(call.sdp);

	            self.setMediaVideo(_sdpParser.isSdpHasVideo(call.sdp));
	            if ((remoteVideoDirection === CONSTANTS.WEBRTC.MEDIA_STATE.INACTIVE) &&
	                (call.currentState === "COMPLETED")) {
	                switch (call.remoteVideoState) {
	                    case CONSTANTS.WEBRTC.MEDIA_STATE.INACTIVE:
	                    case CONSTANTS.WEBRTC.MEDIA_STATE.RECEIVE_ONLY:
	                        call.sdp = _sdpParser.updateVideoSdpDirection(call.sdp, CONSTANTS.WEBRTC.MEDIA_STATE.SEND_RECEIVE);
	                        break;
	                    case CONSTANTS.WEBRTC.MEDIA_STATE.SEND_RECEIVE:
	                        call.sdp = _sdpParser.updateVideoSdpDirection(call.sdp, CONSTANTS.WEBRTC.MEDIA_STATE.RECEIVE_ONLY);
	                        break;
	                }
	            }

	            call.sdp = _sdpParser.changeDirection(call.sdp, CONSTANTS.WEBRTC.MEDIA_STATE.SEND_ONLY, CONSTANTS.WEBRTC.MEDIA_STATE.SEND_RECEIVE, CONSTANTS.STRING.VIDEO);

	            call.sdp = _sdpParser.checkSupportedVideoCodecs(call.sdp, null, self.isH264Enabled());
	            //this part is a work-around for webrtc bug
	            //set remote description with inactive media lines first.
	            //then set remote description with original media lines.

	            //keep original values of remote audio and video states
	            remoteAudioState = _sdpParser.getAudioSdpDirection(call.sdp);
	            remoteVideoState = _sdpParser.getVideoSdpDirection(call.sdp);

	            if (_sdpParser.getVideoSdpDirection(call.sdp) === CONSTANTS.WEBRTC.MEDIA_STATE.INACTIVE ||
	                _sdpParser.getVideoSdpDirection(call.sdp) === CONSTANTS.WEBRTC.MEDIA_STATE.RECEIVE_ONLY) {
	                call.sdp = _sdpParser.deleteInactiveVideoSsrc(call.sdp);
	            }

	            call.sdp = _sdpParser.setTcpSetupAttributeToActpass(call.sdp, self.isDtlsEnabled());
	            // delete all ssrc lines from the sdp before setting first remote description
	            // set second remote description with all ssrc lines included
	            peerRemoteSdp = self.getRtcLibrary().createRTCSessionDescription(CONSTANTS.WEBRTC.RTC_SDP_TYPE.OFFER, call.prevRemoteSdp);

	            data = {
	                call: call,
	                mustCreatePeer: call.isRemoteEndFirefox,
	                oldSdp: call.prevRemoteSdp,
	                newSdp: call.sdp,
	                useIceServer: useIceServer
	            };
	            if (self.createNewPeerForCall(data)) {
	                peer = call.peer;
	            }

	            remoteDescriptionMainProcess = function() {
	                self.setRemoteDescription(call, peer, CONSTANTS.WEBRTC.RTC_SDP_TYPE.OFFER, call.sdp, function processUpdateSetRemoteDescriptionSuccessCallback() {
	                    logger.debug("processUpdate: setRemoteDescription success");
	                    call.remoteVideoState = _sdpParser.getVideoSdpDirection(call.sdp);

	                    peer.createAnswer(peer.remoteDescription, function processUpdateCreateAnswerSuccessCallback(obj) {
	                        logger.debug("processUpdate: isSdpEnabled audio= " + _sdpParser.isAudioSdpEnabled(obj.sdp));
	                        logger.debug("processUpdate: isSdpEnabled video= " + _sdpParser.isVideoSdpEnabled(obj.sdp));

	                        if (_sdpParser.isAudioSdpEnabled(obj.sdp) || _sdpParser.isVideoSdpEnabled(obj.sdp)) {
	                            if (_sdpParser.isSdpVideoSendEnabled(call.sdp)) {
	                                if (self.canOriginatorSendLocalVideo(call)) {
	                                    obj.sdp = _sdpParser.updateVideoSdpDirection(obj.sdp, CONSTANTS.WEBRTC.MEDIA_STATE.SEND_RECEIVE);
	                                } else {
	                                    obj.sdp = _sdpParser.updateVideoSdpDirection(obj.sdp, CONSTANTS.WEBRTC.MEDIA_STATE.RECEIVE_ONLY);
	                                }
	                            } else {
	                                if (self.canOriginatorSendLocalVideo(call) && !_sdpParser.isVideoSdpDirectionInactive(call.sdp)) {
	                                    obj.sdp = _sdpParser.updateVideoSdpDirection(obj.sdp, CONSTANTS.WEBRTC.MEDIA_STATE.SEND_ONLY);
	                                } else {
	                                    obj.sdp = _sdpParser.updateVideoSdpDirection(obj.sdp, CONSTANTS.WEBRTC.MEDIA_STATE.INACTIVE);
	                                }
	                            }

	                            //TODO: Since there is no setter method for obj.sdp from the plugin side,
	                            //      we create a temporary local variable and pass obj.sdp's value into it.
	                            //      Rewrite the below part of code when the setter method is applied to the plugin side
	                            localSdp = _sdpParser.getSdpFromObject(obj);
	                            obj = null;
	                            localSdp = _sdpParser.updateVersion(peerLocalSdp, localSdp);

	                            localSdp = _sdpParser.checkIceParamsLengths(localSdp, call.sdp);
	                            localSdp = _sdpParser.setTcpSetupAttributeTo(localSdp, call.localTcpSetupAttribute, self.isDtlsEnabled());

	                            peer.setLocalDescription(self.getRtcLibrary().createRTCSessionDescription(CONSTANTS.WEBRTC.RTC_SDP_TYPE.ANSWER, localSdp),
	                                function processUpdateSetLocalDescriptionSuccessCallback() {
	                                    logger.debug("processUpdate setLocalDescription success. iceConnectionState: " + peer.iceConnectionState + " iceGatheringState: " + peer.iceGatheringState);
	                                    if (peer.iceGatheringState === "complete") {
	                                        if (call.successCallback) {
	                                            logger.debug("processUpdate iceGatheringState completed " + peer.localDescription.sdp);
	                                            _utils.callFunctionIfExist(successCallback, peer.localDescription.sdp);
	                                        }
	                                    }
	                                },
	                                function processUpdateSetLocalDescriptionFailureCallback(e) {
	                                    logger.debug("processUpdate: setLocalDescription failed: " + e);
	                                    _utils.callFunctionIfExist(failureCallback, "processUpdate: setlocalDescription failed!!");
	                                });
	                        } else {
	                            logger.debug("processUpdate: createAnswer failed!!");
	                            _utils.callFunctionIfExist(failureCallback, "No codec negotiation");
	                        }
	                    }, function processUpdateCreateAnswerFailureCallback(e) {
	                        logger.debug("processUpdate: createAnswer failed!! " + e);
	                        _utils.callFunctionIfExist(failureCallback, "Session cannot be created");
	                    }, self.getRtcLibrary().createConstraints(self.getMediaAudio(), self.getMediaVideo()));
	                }, function processUpdateSetRemoteDescriptionSuccessCallback(e) {
	                    logger.debug("processUpdate: setRemoteDescription failed: " + e);
	                    _utils.callFunctionIfExist(failureCallback, "processUpdate: setRemoteDescription failed!!");
	                });
	            };

	            if (_sdpParser.isSdpHasVideo(call.prevRemoteSdp) || _sdpParser.isIceLite(call.sdp) || local_hold_status) {
	                //set media lines with sendonly state for work-around
	                call.sdp = _sdpParser.updateAudioSdpDirectionToInactive(call.sdp);
	                call.sdp = _sdpParser.updateVideoSdpDirectionToInactive(call.sdp);

	                callSdpWithNoSsrc = _sdpParser.deleteSsrcFromSdp(call.sdp);

	                self.setRemoteDescription(call, peer, CONSTANTS.WEBRTC.RTC_SDP_TYPE.OFFER, callSdpWithNoSsrc, function processUpdateWorkaroundSetRemoteDescriptionSuccessCallback() {
	                    logger.debug("processUpdate: workaround setRemoteDescription success");

	                    //restore original values
	                    call.sdp = _sdpParser.updateAudioSdpDirection(call.sdp, remoteAudioState);
	                    call.sdp = _sdpParser.updateVideoSdpDirection(call.sdp, remoteVideoState);

	                    remoteDescriptionMainProcess();
	                }, function processUpdateWorkaroundSetRemoteDescriptionFailureCallback(e) {
	                    logger.debug("processUpdate: workaround setRemoteDescription failed!!" + e);
	                    _utils.callFunctionIfExist(failureCallback, "processUpdate: workaround setRemoteDescription failed!!");
	                });
	            } else {
	                remoteDescriptionMainProcess();
	            }
	        }
	    };

	    /*
	     * Enabler implementation lies on webRtcPluginAdaptor.js
	     * processEnabler30Answer to be used when the enabler plugin is enabled
	     */
	    self.processAnswer = function(call, onSuccess, onFail) {
	        logger.debug("processAnswer: state= " + call.peer.signalingState);

	        var onSuccessAfterWorkarounds, setRemoteDescription,
	            remoteVideoDirection, localVideoDirection, peer = call.peer,
	            origSdp;

	        onSuccessAfterWorkarounds = function() {
	            call.remoteVideoState = _sdpParser.getVideoSdpDirection(call.sdp);
	            _utils.callFunctionIfExist(onSuccess);
	        };

	        setRemoteDescription = function(call, onSuccess, onFailure) {
	            self.setRemoteDescription(call, call.peer, CONSTANTS.WEBRTC.RTC_SDP_TYPE.ANSWER, call.sdp,
	                function() {
	                    logger.debug("processAnswer: setRemoteDescription success");
	                    onSuccess();
	                },
	                function(e) {
	                    logger.error("processAnswer: setRemoteDescription failed: " + e);
	                    onFailure();
	                });
	        };

	        call.sdp = _sdpParser.checkSupportedVideoCodecs(call.sdp, _sdpParser.getSdpFromObject(call.peer.localDescription), self.isH264Enabled());
	        call.sdp = _sdpParser.performVideoPortZeroWorkaround(call.sdp);

	        if (peer.signalingState === CONSTANTS.WEBRTC.RTC_SIGNALING_STATE.HAVE_REMOTE_PRANSWER) {

	            if (_sdpParser.isIceLite(call.prevRemoteSdp) !== _sdpParser.isIceLite(call.sdp)) {
	                logger.debug("ice - ice-lite change.");
	                onFail(CONSTANTS.WEBRTC.ERROR.ICE_ICELITE);
	                return;
	            }

	            origSdp = call.sdp;
	            call.sdp = _sdpParser.updateVideoSdpDirection(call.sdp, CONSTANTS.WEBRTC.MEDIA_STATE.RECEIVE_ONLY);
	            call.sdp = _sdpParser.updateAudioSdpDirection(call.sdp, CONSTANTS.WEBRTC.MEDIA_STATE.RECEIVE_ONLY);
	            logger.debug("call processPrAnswer again to trigger on remote stream added with updated sdp.");
	            self.processPreAnswer(call,
	                function() {
	                    call.sdp = origSdp;
	                    logger.debug("processPrAnswer sucess callback. Restore original sdp.");
	                    setRemoteDescription(call, onSuccessAfterWorkarounds, onFail);
	                },
	                function() {
	                    call.sdp = origSdp;
	                    logger.debug("processPrAnswer failure callback. Restore original sdp.");
	                    setRemoteDescription(call, onSuccessAfterWorkarounds, onFail);
	                }
	            );
	            return;
	        }


	        remoteVideoDirection = _sdpParser.getVideoSdpDirection(call.sdp);
	        localVideoDirection = _sdpParser.getVideoSdpDirection(_sdpParser.getSdpFromObject(call.peer.localDescription));

	        // this is needed for buggy webrtc api. when term answers with video to audio only call
	        // this scenario does not work without converting to sendrecv
	        logger.debug("processAnswer: ice-lite: do remote video escalation");
	        call.sdp = _sdpParser.changeDirection(call.sdp, CONSTANTS.WEBRTC.MEDIA_STATE.SEND_ONLY, CONSTANTS.WEBRTC.MEDIA_STATE.SEND_RECEIVE, CONSTANTS.STRING.AUDIO);
	        call.sdp = _sdpParser.changeDirection(call.sdp, CONSTANTS.WEBRTC.MEDIA_STATE.SEND_ONLY, CONSTANTS.WEBRTC.MEDIA_STATE.SEND_RECEIVE, CONSTANTS.STRING.VIDEO);

	        if ((localVideoDirection === CONSTANTS.WEBRTC.MEDIA_STATE.RECEIVE_ONLY || localVideoDirection === CONSTANTS.WEBRTC.MEDIA_STATE.SEND_RECEIVE) &&
	            (remoteVideoDirection === CONSTANTS.WEBRTC.MEDIA_STATE.INACTIVE || remoteVideoDirection === CONSTANTS.WEBRTC.MEDIA_STATE.RECEIVE_ONLY)) {

	            // Audio <--> Audio : apply workaround step 1

	            // delete ssrc only from video, keep audio ssrc to hear audio
	            call.sdp = _sdpParser.deleteInactiveVideoSsrc(call.sdp);

	            setRemoteDescription(call, onSuccessAfterWorkarounds, onFail);

	        } else if (localVideoDirection === CONSTANTS.WEBRTC.MEDIA_STATE.RECEIVE_ONLY &&
	            (remoteVideoDirection === CONSTANTS.WEBRTC.MEDIA_STATE.SEND_ONLY || remoteVideoDirection === CONSTANTS.WEBRTC.MEDIA_STATE.SEND_RECEIVE)) {

	            // Audio  <--> Audio-Video

	            setRemoteDescription(call, function() {
	                self.performVideoStartWorkaround(call, onSuccessAfterWorkarounds, onFail);
	            }, onFail);

	        } else {

	            // Audio-Video <--> Audio-Video
	            // there is remote video, no need for orig side workaround

	            setRemoteDescription(call, onSuccessAfterWorkarounds, onFail);
	        }
	    };

	    /*
	     * Enabler implementation lies on webRtcPluginAdaptor.js
	     * performEnablerVideoStartWorkaround - term side cannot see orig's video
	     */
	    self.performVideoStartWorkaround = function(call, onSuccess, onFail) {
	        var peer = call.peer,
	            remoteAudioState, remoteVideoState,
	            callSdpWithNoSsrc, peerLocalSdp;

	        if (!_sdpParser.isSdpHasVideo(call.sdp)) {
	            self.setRemoteDescription(call, null, null, call.sdp, onSuccess, onFail);
	            return;
	        }

	        logger.debug("Workaround to play video");

	        peerLocalSdp = call.stableLocalSdp ? call.stableLocalSdp : call.peer.localDescription.sdp;

	        call.sdp = _sdpParser.addSdpMissingCryptoLine(call.sdp);

	        remoteAudioState = _sdpParser.getSdpDirectionLogging(call.sdp, CONSTANTS.STRING.AUDIO, false);
	        remoteVideoState = _sdpParser.getSdpDirectionLogging(call.sdp, CONSTANTS.STRING.VIDEO, false);

	        call.sdp = _sdpParser.updateSdpDirection(call.sdp, CONSTANTS.STRING.AUDIO, CONSTANTS.WEBRTC.MEDIA_STATE.INACTIVE);
	        call.sdp = _sdpParser.updateSdpDirection(call.sdp, CONSTANTS.STRING.VIDEO, CONSTANTS.WEBRTC.MEDIA_STATE.INACTIVE);

	        call.sdp = _sdpParser.setTcpSetupAttributeToActpass(call.sdp, self.isDtlsEnabled());

	        callSdpWithNoSsrc = _sdpParser.deleteSsrcFromSdp(call.sdp);

	        self.setRemoteDescription(call, peer, CONSTANTS.WEBRTC.RTC_SDP_TYPE.OFFER, callSdpWithNoSsrc,
	            function() {
	                logger.debug("performVideoStartWorkaround: first setRemoteDescription success");

	                // restore original values
	                call.sdp = _sdpParser.updateSdpDirection(call.sdp, CONSTANTS.STRING.AUDIO, remoteAudioState);
	                call.sdp = _sdpParser.updateSdpDirection(call.sdp, CONSTANTS.STRING.VIDEO, remoteVideoState);

	                self.setRemoteDescription(call, peer, CONSTANTS.WEBRTC.RTC_SDP_TYPE.OFFER, call.sdp,
	                    function() {
	                        logger.debug("performVideoStartWorkaround: second setRemoteDescription success");
	                        peer.createAnswer(peer.remoteDescription, function(obj) {
	                            var localSdp = _sdpParser.getSdpFromObject(obj);

	                            if (_sdpParser.getSdpDirectionLogging(call.sdp, CONSTANTS.STRING.AUDIO, false) === CONSTANTS.WEBRTC.MEDIA_STATE.INACTIVE) {
	                                localSdp = _sdpParser.updateSdpDirection(localSdp, CONSTANTS.STRING.AUDIO, CONSTANTS.WEBRTC.MEDIA_STATE.INACTIVE);
	                            }

	                            if (call.remoteVideoState === CONSTANTS.WEBRTC.MEDIA_STATE.INACTIVE) {
	                                localSdp = _sdpParser.updateSdpDirection(localSdp, CONSTANTS.STRING.VIDEO, CONSTANTS.WEBRTC.MEDIA_STATE.INACTIVE);
	                            } else if (self.canOriginatorSendLocalVideo(call)) {
	                                localSdp = _sdpParser.updateSdpDirection(localSdp, CONSTANTS.STRING.VIDEO, CONSTANTS.WEBRTC.MEDIA_STATE.SEND_RECEIVE);
	                            } else {
	                                localSdp = _sdpParser.updateSdpDirection(localSdp, CONSTANTS.STRING.VIDEO, CONSTANTS.WEBRTC.MEDIA_STATE.RECEIVE_ONLY);
	                            }

	                            localSdp = _sdpParser.checkAndRestoreICEParams(localSdp, call.sdp);

	                            localSdp = _sdpParser.setTcpSetupAttributeTo(localSdp, call.localTcpSetupAttribute, self.isDtlsEnabled());

	                            localSdp = _sdpParser.updateVersion(peerLocalSdp, localSdp);

	                            peer.setLocalDescription(
	                                self.getRtcLibrary().createRTCSessionDescription(CONSTANTS.WEBRTC.RTC_SDP_TYPE.ANSWER, localSdp),
	                                function() {
	                                    logger.debug("performVideoStartWorkaround: setlocalDescription success");
	                                    _utils.callFunctionIfExist(onSuccess);
	                                },
	                                function(e) {
	                                    logger.debug("performVideoStartWorkaround: setlocalDescription failed!!" + e);
	                                    _utils.callFunctionIfExist(onFail, "performVideoStartWorkaround: setlocalDescription failed!!");
	                                });
	                        }, function(e) {
	                            logger.debug("performVideoStartWorkaround: createAnswer failed!! " + e);
	                            _utils.callFunctionIfExist(onFail, "Session cannot be created");
	                        }, self.getRtcLibrary().createConstraints(self.getMediaAudio(), self.getMediaVideo()));
	                    },
	                    function(e) {
	                        logger.debug("performVideoStartWorkaround: second setRemoteDescription failed!!" + e);
	                        _utils.callFunctionIfExist(onFail, "performVideoStartWorkaround: second setRemoteDescription failed!!");
	                    });
	            },
	            function(e) {
	                logger.debug("performVideoStartWorkaround: first setRemoteDescription failed!!" + e);
	                _utils.callFunctionIfExist(onFail, "performVideoStartWorkaround: first setRemoteDescription failed!!");
	            });
	    };

	    /*
	     * Enabler implementation lies on webRtcPluginAdaptor.js
	     * processPreAnswer to be used when the enabler plugin is enabled
	     */
	    self.processPreAnswer = function(call, onSuccess, onFailure) {
	        logger.debug("processPreAnswer: state= " + call.peer.signalingState);

	        call.sdp = _sdpParser.checkSupportedVideoCodecs(call.sdp, _sdpParser.getSdpFromObject(call.peer.localDescription), self.isH264Enabled());

	        self.setRemoteDescription(call, call.peer, CONSTANTS.WEBRTC.RTC_SDP_TYPE.PRANSWER, call.sdp,
	            function processPreAnswerSetRemoteDescriptionSuccessCallback() {
	                self.setOriginatorReceiveRemoteVideo(call);
	                call.remoteVideoState = _sdpParser.getVideoSdpDirection(call.sdp);
	                onSuccess();
	                logger.debug("processPreAnswer: setRemoteDescription success");
	            },
	            function processPreAnswerSetRemoteDescriptionFailureCallback(e) {
	                logger.error("processPreAnswer: setRemoteDescription failed: " + e);
	                onFailure(e);
	            });
	    };

	    /*
	     * Enabler implementation lies on webRtcPluginAdaptor.js
	     * processEnablerRespond
	     */
	    self.processRespond = function(call, onSuccess, onFailure, isJoin) {
	        var remoteVideoDirection;

	        logger.debug("processRespond: state= " + call.peer.signalingState);

	        if (call.peer.signalingState === CONSTANTS.WEBRTC.RTC_SIGNALING_STATE.STABLE) {
	            //if we are in stable state we should not change remotedescription
	            self.setRemoteDescription(call, null, null, call.sdp, onSuccess, onFailure);
	            return;
	        }

	        call.sdp = _sdpParser.checkSupportedVideoCodecs(call.sdp, _sdpParser.getSdpFromObject(call.stableLocalSdp), self.isH264Enabled());

	        remoteVideoDirection = _sdpParser.getVideoSdpDirection(call.sdp);

	        if ((remoteVideoDirection === CONSTANTS.WEBRTC.MEDIA_STATE.INACTIVE) && (call.currentState === "COMPLETED")) {
	            switch (call.remoteVideoState) {
	                case CONSTANTS.WEBRTC.MEDIA_STATE.INACTIVE:
	                case CONSTANTS.WEBRTC.MEDIA_STATE.RECEIVE_ONLY:
	                    call.sdp = _sdpParser.updateSdpDirection(call.sdp, CONSTANTS.STRING.VIDEO, CONSTANTS.WEBRTC.MEDIA_STATE.RECEIVE_ONLY);
	                    break;
	            }
	        }

	        call.remoteVideoState = _sdpParser.getVideoSdpDirection(call.sdp);
	        call.sdp = _sdpParser.changeDirection(call.sdp, CONSTANTS.WEBRTC.MEDIA_STATE.SEND_ONLY, CONSTANTS.WEBRTC.MEDIA_STATE.SEND_RECEIVE, CONSTANTS.STRING.VIDEO);
	        if (isJoin) {
	            call.sdp = _sdpParser.changeDirection(call.sdp, CONSTANTS.WEBRTC.MEDIA_STATE.RECEIVE_ONLY, CONSTANTS.WEBRTC.MEDIA_STATE.SEND_RECEIVE, CONSTANTS.STRING.AUDIO);
	            self.muteOnHold(call, false);
	        }

	        if (_sdpParser.getVideoSdpDirection(call.sdp) === CONSTANTS.WEBRTC.MEDIA_STATE.INACTIVE ||
	            _sdpParser.getVideoSdpDirection(call.sdp) === CONSTANTS.WEBRTC.MEDIA_STATE.RECEIVE_ONLY) {
	            call.sdp = _sdpParser.deleteInactiveVideoSsrc(call.sdp);
	        }

	        self.setRemoteDescription(call, call.peer, CONSTANTS.WEBRTC.RTC_SDP_TYPE.ANSWER, call.sdp,
	            function() {
	                logger.debug("processRespond: setRemoteDescription success");
	                var onSuccessAfterWorkaround = function() {
	                    call.remoteVideoState = _sdpParser.getVideoSdpDirection(call.sdp);
	                    _utils.callFunctionIfExist(onSuccess);
	                };
	                // _utils.callFunctionIfExist(onSuccessAfterWorkaround);
	                self.performVideoStartWorkaround(call, onSuccessAfterWorkaround, onFailure);
	            },
	            function(e) {
	                logger.debug("processRespond: setRemoteDescription failed: " + e);
	                _utils.callFunctionIfExist(onFailure);
	            });
	    };

	    /*
	     * createPluginReOffer
	     */
	    self.createReOffer = function(call, successCallback, failureCallback, usePreviousMediaDirection, useIceServer) {
	        var peer = call.peer,
	            localDescObj, localAudioDirection, localVideoDirection,
	            prevLocalSdp = call.stableLocalSdp,
	            deleteVideoStream = false,
	            mediaVideo = self.getMediaVideo(),
	            data;

	        logger.debug("createReOffer:" + call.id);

	        if (!usePreviousMediaDirection) {
	            deleteVideoStream = !call.initialVideoState && _sdpParser.isSdpHasVideo(call.stableLocalSdp);
	            mediaVideo = mediaVideo && call.initialVideoState;
	        }

	        data = {
	            call: call,
	            mustCreatePeer: true,
	            deleteVideoStream: deleteVideoStream,
	            useIceServer: useIceServer
	        };
	        if (self.createNewPeerForCall(data)) {
	            peer = call.peer;
	        }

	        peer.createOffer(
	            function createReOfferCreateOfferSuccessCallback(oSdp) {

	                if (usePreviousMediaDirection) {
	                    localAudioDirection = _sdpParser.getAudioSdpDirection(prevLocalSdp);
	                    oSdp.sdp = _sdpParser.updateAudioSdpDirection(oSdp.sdp, localAudioDirection);
	                    localVideoDirection = _sdpParser.getVideoSdpDirection(prevLocalSdp);
	                    oSdp.sdp = _sdpParser.updateVideoSdpDirection(oSdp.sdp, localVideoDirection);
	                }

	                oSdp.sdp = _sdpParser.deleteCryptoZeroFromSdp(oSdp.sdp);
	                oSdp.sdp = _sdpParser.removeG722Codec(oSdp.sdp);
	                oSdp.sdp = _sdpParser.deleteCryptoFromSdp(oSdp.sdp, self.isDtlsEnabled());
	                oSdp.sdp = _sdpParser.setTcpSetupAttributeToActpass(oSdp.sdp, self.isDtlsEnabled());
	                oSdp.sdp = _sdpParser.updateVersion(prevLocalSdp, oSdp.sdp);
	                oSdp.sdp = self.updateCodecs(call, oSdp.sdp);

	                localDescObj = self.getRtcLibrary().createRTCSessionDescription(CONSTANTS.WEBRTC.RTC_SDP_TYPE.OFFER, oSdp.sdp);
	                peer.setLocalDescription(localDescObj, function createReOfferSetLocalDescriptionSuccessCallback() {
	                        logger.debug("createReOffer: setLocalDescription success" + call.id);
	                    }, function createReOfferSetLocalDescriptionFailureCallback(e) {
	                        logger.debug("createReOffer: setLocalDescription failed!!" + e + call.id);
	                        _utils.callFunctionIfExist(failureCallback);
	                    });
	            },
	            function createReOfferCreateOfferFailureCallback(e) {
	                logger.error("createReOffer: createOffer failed!! " + e);
	                _utils.callFunctionIfExist(failureCallback);
	            }, self.getRtcLibrary().createConstraints(self.getMediaAudio(), mediaVideo));
	    };

	    /*
	     * Enabler implementation lies on webRtcPluginAdaptor.js
	     * processEnablerHold to be used when the enabler plugin 30 is enabled.
	     */
	    self.processHold = function(call, hold, local_hold_status, successCallback, failureCallback, useIceServer) {
	        logger.debug("processHold: local hold= " + local_hold_status + " remote hold= " + hold + " state= " + call.peer.signalingState);
	        var peer = call.peer,
	            audioDirection, videoDirection, peerRemoteSdp, inactiveRemoteSdp,
	            peerLocalSdp, localSdp, data;
	        peerLocalSdp = call.stableLocalSdp;

	        audioDirection = _sdpParser.getAudioSdpDirection(call.sdp);
	        videoDirection = _sdpParser.getVideoSdpDirection(call.sdp);

	        if ((_sdpParser.isIceLite(call.sdp) && self.isSdpDirectionsSendRecv(peer.localDescription.sdp, peer.remoteDescription.sdp)) &&
	            !call.isRemoteEndFirefox &&
	            !self.oldSolutionNeeded(call.prevRemoteSdp, call.sdp)) {
	            logger.debug("processHold  new solution");
	            if (hold) {
	                logger.debug("processHold: Remote HOLD");
	                peerLocalSdp = _sdpParser.respondToRemoteSdpDirections(peerLocalSdp, call.sdp);
	                self.muteOnHold(call, true);
	            } else if (!local_hold_status) {
	                logger.debug("processHold: Remote UNHOLD: direction left as it is");

	                if (_sdpParser.isSdpVideoSendEnabled(call.sdp)) {
	                    if (self.canOriginatorSendLocalVideo(call)) {
	                        peerLocalSdp = _sdpParser.updateVideoSdpDirection(peerLocalSdp, CONSTANTS.WEBRTC.MEDIA_STATE.SEND_RECEIVE);
	                    } else {
	                        peerLocalSdp = _sdpParser.updateVideoSdpDirection(peerLocalSdp, CONSTANTS.WEBRTC.MEDIA_STATE.RECEIVE_ONLY);
	                    }
	                } else {
	                    if (self.canOriginatorSendLocalVideo(call) && !_sdpParser.isVideoSdpDirectionInactive(call.sdp)) {
	                        peerLocalSdp = _sdpParser.updateVideoSdpDirection(peerLocalSdp, CONSTANTS.WEBRTC.MEDIA_STATE.SEND_ONLY);
	                    } else {
	                        peerLocalSdp = _sdpParser.updateVideoSdpDirection(peerLocalSdp, CONSTANTS.WEBRTC.MEDIA_STATE.INACTIVE);
	                    }
	                }
	                //change audio's direction to sendrecv for ssl attendees in a 3wc
	                peerLocalSdp = _sdpParser.changeDirection(peerLocalSdp, CONSTANTS.WEBRTC.MEDIA_STATE.RECEIVE_ONLY, CONSTANTS.WEBRTC.MEDIA_STATE.SEND_RECEIVE, CONSTANTS.STRING.AUDIO);
	                self.muteOnHold(call, false);
	            } else if (local_hold_status && !hold) {
	                logger.debug("processHold: Remote UNHOLD on local hold");

	                if (audioDirection === CONSTANTS.WEBRTC.MEDIA_STATE.INACTIVE) {
	                    peerLocalSdp = _sdpParser.updateAudioSdpDirectionToInactive(peerLocalSdp);
	                } else {
	                    peerLocalSdp = _sdpParser.updateAudioSdpDirection(peerLocalSdp, CONSTANTS.WEBRTC.MEDIA_STATE.SEND_ONLY);
	                }

	                if (self.canOriginatorSendLocalVideo(call)) {
	                    peerLocalSdp = _sdpParser.updateVideoSdpDirection(peerLocalSdp, CONSTANTS.WEBRTC.MEDIA_STATE.SEND_ONLY);
	                } else {
	                    peerLocalSdp = _sdpParser.updateVideoSdpDirectionToInactive(peerLocalSdp);
	                }
	                self.muteOnHold(call, true);
	            }
	            self.setRemoteDescription(call, null, null, call.sdp);
	            peerLocalSdp = _sdpParser.setTcpSetupAttributeTo(peerLocalSdp, call.localTcpSetupAttribute, self.isDtlsEnabled());
	            _utils.callFunctionIfExist(successCallback, peerLocalSdp);
	        } else {
	            logger.debug("processHold  old solution");

	            if (!local_hold_status && !hold) {
	                self.muteOnHold(call, false);
	            }

	            call.sdp = _sdpParser.setTcpSetupAttributeToActpass(call.sdp, self.isDtlsEnabled());
	            call.sdp = _sdpParser.checkSupportedVideoCodecs(call.sdp, null, self.isH264Enabled());
	            call.sdp = _sdpParser.performVideoPortZeroWorkaround(call.sdp);
	            call.sdp = _sdpParser.checkAndRestoreICEParams(call.sdp, _sdpParser.getSdpFromObject(call.peer.localDescription));

	            peerRemoteSdp = call.prevRemoteSdp;

	            // chrome38 fix
	            inactiveRemoteSdp = _sdpParser.updateAudioSdpDirectionToInactive(call.sdp);
	            inactiveRemoteSdp = _sdpParser.updateVideoSdpDirectionToInactive(inactiveRemoteSdp);

	            data = {
	                call: call,
	                mustCreatePeer: call.isRemoteEndFirefox,
	                oldSdp: call.prevRemoteSdp,
	                newSdp: call.sdp,
	                useIceServer: useIceServer
	            };
	            if (self.createNewPeerForCall(data)) {
	                peer = call.peer;
	            }
	            inactiveRemoteSdp = _sdpParser.deleteSsrcFromSdp(inactiveRemoteSdp);

	            // 1st setRemoteDescription to make webrtc remove the audio and/or video streams
	            // 2nd setRemote will add the audio stream back so that services like MOH can work
	            // This code will also run in UnHold scenario, and it will remove & add video stream
	            self.setRemoteDescription(call, peer, CONSTANTS.WEBRTC.RTC_SDP_TYPE.OFFER, inactiveRemoteSdp, function processHoldSetFirstRemoteDescriptionSuccessCallback() {
	                call.sdp = _sdpParser.updateAudioSdpDirection(call.sdp, CONSTANTS.WEBRTC.MEDIA_STATE.SEND_RECEIVE);

	                if (_sdpParser.getVideoSdpDirection(call.sdp) === CONSTANTS.WEBRTC.MEDIA_STATE.INACTIVE ||
	                    _sdpParser.getVideoSdpDirection(call.sdp) === CONSTANTS.WEBRTC.MEDIA_STATE.RECEIVE_ONLY) {
	                    call.sdp = _sdpParser.deleteInactiveVideoSsrc(call.sdp);
	                }
	                self.setRemoteDescription(call, peer, CONSTANTS.WEBRTC.RTC_SDP_TYPE.OFFER, call.sdp, function processHoldSetSecondRemoteDescriptionSuccessCallback() {
	                    if (!hold && !local_hold_status && (videoDirection === CONSTANTS.WEBRTC.MEDIA_STATE.INACTIVE)) {
	                        call.remoteVideoState = CONSTANTS.WEBRTC.MEDIA_STATE.RECEIVE_ONLY;
	                    } else {
	                        call.remoteVideoState = _sdpParser.getVideoSdpDirection(call.sdp);
	                    }
	                    peer.createAnswer(peer.remoteDescription, function processHoldCreateAnswerSuccessCallback(obj) {
	                        localSdp = _sdpParser.getSdpFromObject(obj);
	                        logger.debug("processHold: isSdpEnabled audio= " + _sdpParser.isAudioSdpEnabled(obj.sdp));
	                        logger.debug("processHold: isSdpEnabled video= " + _sdpParser.isVideoSdpEnabled(obj.sdp));
	                        obj = null;

	                        if (hold) {
	                            logger.debug("processHold: Remote HOLD");
	                            localSdp = _sdpParser.respondToRemoteSdpDirections(localSdp, call.sdp);
	                        } else if (!local_hold_status) {
	                            logger.debug("processHold: Remote UNHOLD: direction left as it is");

	                            if (_sdpParser.isSdpVideoSendEnabled(call.sdp)) {
	                                if (self.canOriginatorSendLocalVideo(call)) {
	                                    localSdp = _sdpParser.updateVideoSdpDirection(localSdp, CONSTANTS.WEBRTC.MEDIA_STATE.SEND_RECEIVE);
	                                } else {
	                                    localSdp = _sdpParser.updateVideoSdpDirection(localSdp, CONSTANTS.WEBRTC.MEDIA_STATE.RECEIVE_ONLY);
	                                }
	                            } else {
	                                if (self.canOriginatorSendLocalVideo(call) && !_sdpParser.isVideoSdpDirectionInactive(call.sdp)) {
	                                    localSdp = _sdpParser.updateVideoSdpDirection(localSdp, CONSTANTS.WEBRTC.MEDIA_STATE.SEND_ONLY);
	                                } else {
	                                    localSdp = _sdpParser.updateVideoSdpDirection(localSdp, CONSTANTS.WEBRTC.MEDIA_STATE.INACTIVE);
	                                }
	                            }
	                            //change audio's direction to sendrecv for ssl attendees in a 3wc
	                            localSdp = _sdpParser.changeDirection(localSdp, CONSTANTS.WEBRTC.MEDIA_STATE.RECEIVE_ONLY, CONSTANTS.WEBRTC.MEDIA_STATE.SEND_RECEIVE, CONSTANTS.STRING.AUDIO);
	                        } else if (local_hold_status && !hold) {
	                            logger.debug("processHold: Remote UNHOLD on local hold");

	                            if (audioDirection === CONSTANTS.WEBRTC.MEDIA_STATE.INACTIVE) {
	                                localSdp = _sdpParser.updateAudioSdpDirectionToInactive(localSdp);
	                            } else {
	                                localSdp = _sdpParser.updateAudioSdpDirection(localSdp, CONSTANTS.WEBRTC.MEDIA_STATE.SEND_ONLY);
	                            }

	                            if (self.canOriginatorSendLocalVideo(call)) {
	                                localSdp = _sdpParser.updateVideoSdpDirection(localSdp, CONSTANTS.WEBRTC.MEDIA_STATE.SEND_ONLY);
	                            } else {
	                                localSdp = _sdpParser.updateVideoSdpDirectionToInactive(localSdp);
	                            }
	                        }

	                        localSdp = _sdpParser.updateVersion(peerLocalSdp, localSdp);
	                        localSdp = _sdpParser.checkIceParamsLengths(localSdp, call.sdp);
	                        localSdp = _sdpParser.checkAndRestoreICEParams(localSdp, call.sdp);
	                        if (_sdpParser.isSdpHasVideoWithZeroPort(localSdp) && self.getDefaultVideoContainer()) {
	                            self.useDefaultRenderer(false, false, false);
	                        }

	                        localSdp = _sdpParser.setTcpSetupAttributeTo(localSdp, call.localTcpSetupAttribute, self.isDtlsEnabled());

	                        localSdp = _sdpParser.updateH264Level(localSdp);

	                        peer.setLocalDescription(self.getRtcLibrary().createRTCSessionDescription(CONSTANTS.WEBRTC.RTC_SDP_TYPE.ANSWER, localSdp),
	                            function processHoldSetLocalDescriptionSuccessCallback() {
	                                logger.debug("processHold: setLocalDescription success!! " + "iceConnectionState: " + peer.iceConnectionState + " iceGatheringState: " + peer.iceGatheringState);
	                                if (peer.iceGatheringState === "complete") {
	                                    if (call.successCallback) {
	                                        logger.debug("processHold iceGatheringState completed " + peer.localDescription.sdp);
	                                        _utils.callFunctionIfExist(successCallback, peer.localDescription.sdp);
	                                    }
	                                }
	                            },
	                            function processHoldSetLocalDescriptionFailureCallback(e) {
	                                logger.error("processHold: setLocalDescription failed!! " + e);
	                                _utils.callFunctionIfExist(failureCallback, "Session cannot be created");
	                            });
	                    }, function processHoldCreateAnswerFailureCallback(e) {
	                        logger.error("processHold: createAnswer failed!!: " + e);
	                        _utils.callFunctionIfExist(failureCallback, "Session cannot be created");
	                    }, self.getRtcLibrary().createConstraints(self.getMediaAudio(), self.getMediaVideo()));
	                }, function processHoldSetSecondRemoteDescriptionFailureCallback(e) {
	                    logger.error("processHold: second setRemoteDescription failed!! " + e);
	                    _utils.callFunctionIfExist(failureCallback, "Session cannot be created");
	                });
	            }, function processHoldSetFirstRemoteDescriptionFailureCallback(e) {
	                logger.debug("processHold: first setRemoteDescription failed!! " + e);
	                _utils.callFunctionIfExist(failureCallback, "Session cannot be created");
	            });
	        }
	    };

	    /*
	     * Enabler implementation lies on webRtcPluginAdaptor.js
	     * processHoldRespond to be used when the enabler plugin is enabled
	     */
	    self.processHoldRespond = function(call, onSuccess, onFailure, isJoin) {
	        var remoteAudioDirection,
	            remoteVideoDirection,
	            localHoldFlag = false,
	            remoteHoldFlag = false;

	        logger.debug("processHoldRespond: state= " + call.peer.signalingState + " call.currentState= " + call.currentState);

	        if (call.peer.signalingState === CONSTANTS.WEBRTC.RTC_SIGNALING_STATE.STABLE) {
	            //if we are in stable state we should not change remotedescription
	            self.onRemoteStreamAdded(call);
	            self.setRemoteDescription(call, null, null, call.sdp, onSuccess, onFailure);
	            return;
	        }

	        call.sdp = _sdpParser.checkSupportedVideoCodecs(call.sdp, _sdpParser.getSdpFromObject(call.stableLocalSdp), self.isH264Enabled());

	        _sdpParser.init(call.sdp);
	        remoteHoldFlag = _sdpParser.isRemoteHold();

	        localHoldFlag = (call.currentState === "LOCAL_HOLD");

	        remoteAudioDirection = _sdpParser.getAudioSdpDirection(call.sdp);
	        remoteVideoDirection = _sdpParser.getVideoSdpDirection(call.sdp);

	        logger.debug("processHoldRespond: localHold= " + localHoldFlag + " remoteHold= " + remoteHoldFlag);

	        /* Required for MOH - start */
	        if (remoteHoldFlag === false) {
	            if ((remoteAudioDirection === CONSTANTS.WEBRTC.MEDIA_STATE.SEND_RECEIVE) && (call.currentState === "REMOTE_HOLD")) {
	                call.previousState = call.currentState;
	                call.currentState = "COMPLETED";
	            }
	        } else {
	            if (call.currentState === "COMPLETED") {
	                call.previousState = call.currentState;
	                call.currentState = "REMOTE_HOLD";
	            }
	        }

	        if (localHoldFlag || remoteHoldFlag) {
	            logger.debug("processHoldRespond: " + call.currentState + " : video -> inactive");
	            call.sdp = _sdpParser.updateSdpDirection(call.sdp, CONSTANTS.STRING.VIDEO, CONSTANTS.WEBRTC.MEDIA_STATE.INACTIVE);
	        }

	        if ((remoteVideoDirection === CONSTANTS.WEBRTC.MEDIA_STATE.INACTIVE) && (call.currentState === "COMPLETED")) {
	            logger.debug("processHoldRespond: video inactive -> recvonly");
	            call.sdp = _sdpParser.updateSdpDirection(call.sdp, CONSTANTS.STRING.VIDEO, CONSTANTS.WEBRTC.MEDIA_STATE.RECEIVE_ONLY);
	        }
	        /* Required for MOH - end */

	        if (localHoldFlag && remoteAudioDirection === CONSTANTS.WEBRTC.MEDIA_STATE.SEND_RECEIVE) {
	            logger.debug("processHoldRespond: Mute Remote Audio");
	            call.sdp = _sdpParser.updateAudioSdpDirection(call.sdp, CONSTANTS.WEBRTC.MEDIA_STATE.RECEIVE_ONLY);
	        }

	        if (localHoldFlag && remoteVideoDirection === CONSTANTS.WEBRTC.MEDIA_STATE.SEND_RECEIVE) {
	            logger.debug("processHoldRespond: Mute Remote Video");
	            call.sdp = _sdpParser.updateVideoSdpDirection(call.sdp, CONSTANTS.WEBRTC.MEDIA_STATE.RECEIVE_ONLY);
	        }

	        self.processRespond(call, onSuccess, onFailure, isJoin);
	    };

	    // createEnablerDataChannel
	    self.createDataChannel = function(dataChannelWrapperObj, onSuccess, onFailure, options) {
	        try {
	            if (options) {
	                dataChannelWrapperObj.dataChannel = dataChannelWrapperObj.peer.createDataChannel("Label", options);
	            } else {
	                dataChannelWrapperObj.dataChannel = dataChannelWrapperObj.peer.createDataChannel("Label");
	            }
	            onSuccess(dataChannelWrapperObj);
	        } catch (error) {
	            logger.error("Failed to create data channel, exception: " + error.message);
	            onFailure(error);
	        }
	    };

	    // Enabler implementation lies on webRtcPluginAdaptor.js
	    self.createPeer = function(call, useIceServer, onsuccess, onfailure) {
	        try {
	            var pc, constraints, i, servers = [],
	                iceServerUrl, stunturn;

	            logger.info('useIceServer: ' + useIceServer);
	            if (useIceServer) {
	                iceServerUrl = self.getIceServerUrl();
	            }

	            if (iceServerUrl instanceof Array) {
	                for (i = 0; i < iceServerUrl.length; i++) {
	                    servers[i] = iceServerUrl[i];
	                }
	            } else if (!iceServerUrl || iceServerUrl === "") {
	                servers = [];
	            } else {
	                servers[0] = iceServerUrl;
	            }
	            stunturn = {
	                iceServers: servers
	            };

	            constraints = {
	                "optional": {
	                    "DtlsSrtpKeyAgreement": self.isDtlsEnabled()
	                }
	            };
	            pc = self.getRtcLibrary().createRTCPeerConnection(stunturn, constraints);

	            self.setPeerCount(self.getPeerCount() + 1);
	            call.peer = pc;

	            pc.onconnecting = function(event) {
	                self.onSessionConnecting(call, event);
	            };
	            pc.onopen = function(event) {
	                self.onSessionOpened(call, event);
	            };
	            pc.onsignalingstatechange = function(event) {
	                self.onSignalingStateChange(call, event);
	            };
	            pc.onaddstream = function(event) {
	                self.onRemoteStreamAdded(call, event);
	            };
	            pc.onremovestream = function(event) {
	                self.onRemoteStreamRemoved(call, event);
	            };
	            pc.onicecandidate = function(event) {
	                self.setupIceCandidateCollectionTimer(call);
	                self.onIceCandidate(call, event);
	            };
	            pc.onicecomplete = function() {
	                self.onIceComplete(call);
	            };
	            pc.oniceconnectionstatechange = function(event) {
	                self.oniceconnectionstatechange(call, event);
	            };
	            pc.ondatachannel = function(event) {
	                self.onDataChannel(call, event);
	            };

	            logger.info("create PeerConnection successfully.");

	            self.setupWebrtcLogCollectionTimer(call);

	            _utils.callFunctionIfExist(onsuccess);
	        } catch (err) {
	            logger.error("Failed to create PeerConnection, exception: " + err.message);
	            _utils.callFunctionIfExist(onfailure);
	        }
	    };

	    self.createNewPeerForCall = function(data) {
	        var call = data.call,
	            mustCreatePeer = data.mustCreatePeer,
	            oldSessionId = _sdpParser.getSessionIdFromSdp(data.oldSdp),
	            newSessionId = _sdpParser.getSessionIdFromSdp(data.newSdp),
	            isNewPeerCreated = false,
	            oldPeer,
	            videoTrack,
	            telephoneEventPayloadChanged = _sdpParser.hasCodecPayloadChanged(data.oldSdp, data.newSdp);

	        if (mustCreatePeer || telephoneEventPayloadChanged || oldSessionId !== newSessionId) {
	            if (call.peer) {
	                oldPeer = call.peer;
	                self.collectWebRtcStats(call.sdp, oldPeer,
	                    function(stats) {
	                        logger.debug("Plugin collectWebRtcStats successfull");
	                        if (call.stats === undefined) {
	                            call.stats = [];
	                        }
	                        call.stats.push(stats);
	                        if (oldPeer.signalingState !== "closed") {
	                            oldPeer.close();
	                        }
	                        self.setPeerCount(self.getPeerCount() - 1);
	                        call.dtmfSender = null;
	                    },
	                    function() {
	                        logger.debug("Plugin collectWebRtcStats failed");
	                        if (oldPeer.signalingState !== "closed") {
	                            oldPeer.close();
	                        }
	                        self.setPeerCount(self.getPeerCount() - 1);
	                        call.dtmfSender = null;
	                    });
	            }

	            logger.trace("Creating new peer for call: " + call.id);
	            self.createPeer(call, data.useIceServer, function createPeerSuccessCallback() {
	                logger.trace("New peer has created for call: " + call.id);

	                //
	                // add commented out lines below
	                // after plugin implementation
	                //
	                //if (data.deleteVideoStream) {
	                //    videoTrack = call.localMedia.stream.getVideoTracks()[0];
	                //    call.localMedia.stream.removeTrack(videoTrack);
	                //}
	                //

	                call.peer.addStream(call.localMedia.stream);
	                isNewPeerCreated = true;
	            }, function createPeerFailureCallback() {
	                logger.error("New peer creation has failed!: " + call.id);
	                if (call.stats) {
	                    call.stats.pop();
	                }
	            });
	        }
	        return isNewPeerCreated;
	    };

	    // pluginOnRemoteStreamAdded
	    self.onRemoteStreamAdded = function(call, event) {
	        var fireEvent,
	            remoteVideoTracks = [],
	            isVideoTrackAvailable = false;

	        if (self.getDefaultVideoContainer()) {
	            if (!self.isActiveCallInVideoContainer(self.getDefaultVideoContainer(), call)) {
	                logger.debug("onRemoteStreamAdded: It is not active call. Call Id: " + call.id);
	                return;
	            }
	        } else if (self.getRemoteVideoContainer()) {
	            if (!self.isActiveCallInVideoContainer(self.getRemoteVideoContainer(), call)) {
	                logger.debug("onRemoteStreamAdded: It is not active call. Call Id: " + call.id);
	                return;
	            }
	        }

	        if (event && event.stream) {
	            call.remoteStreamUrl = self.getRtcLibrary().getURLFromStream(event.stream);

	            remoteVideoTracks = event.stream.getVideoTracks();
	        } else {
	            remoteVideoTracks = self.getRemoteVideoTrack(call.peer);
	        }

	        if (remoteVideoTracks) {
	            if (remoteVideoTracks.length > 0) {
	                isVideoTrackAvailable = true;
	            }
	        }

	        if (self.getDefaultVideoContainer()) {
	            fireEvent = self.useDefaultRenderer(call.remoteStreamUrl, false, isVideoTrackAvailable);
	        } else if (self.getRemoteVideoContainer()) {
	            fireEvent = self.createStreamRenderer(call.remoteStreamUrl, self.getRemoteVideoContainer());
	        } else {
	            fireEvent = true;
	        }

	        logger.debug("onRemoteStreamAdded: " + call.remoteStreamUrl);
	        if (fireEvent) {
	            self.fireOnStreamAddedEvent(call, call.remoteStreamUrl);
	        }
	    };

	    self.iceCandidateCollectionTimeoutHandler = function(call) {
	        var sdp = call.peer.localDescription.sdp;
	        self.clearIceCandidateCollectionTimer(call);
	        if (fcsConfig.relayCandidateCollectionTimeoutCycle) {
	            call.relayCandidateCycle++;
	        }
	        // set timeout if there is no ice candidate available or
	        // when audio, video port assignment isn't complete
	        if (!_sdpParser.hasCandidates(sdp, call.relayCandidateCycle, fcsConfig.relayCandidateCollectionTimeoutCycle)) {
	            logger.debug("Re-setting ice candidate collection timeout: " + fcsConfig.iceCandidateCollectionTimeoutInterval);
	            call.iceCandidateCollectionTimer = setTimeout(function() {
	                self.iceCandidateCollectionTimeoutHandler(call);
	            }, fcsConfig.iceCandidateCollectionTimeoutInterval);
	            return;
	        }

	        if (call.successCallback) {
	            logger.debug("Ice candidate collection interrupted after given timeout, invoking successCallback.");

	            sdp = _sdpParser.updateH264Level(sdp);

	            call.successCallback(sdp);
	        }
	    };

	    self.setupIceCandidateCollectionTimer = function(call) {
	        if (fcsConfig.iceCandidateCollectionTimeoutInterval) {
	            if (!call.iceCandidateCollectionTimer) {
	                logger.debug("Setting ice candidate collection timeout: " + fcsConfig.iceCandidateCollectionTimeoutInterval);
	                if (fcsConfig.relayCandidateCollectionTimeoutCycle) {
	                    call.relayCandidateCycle = 1;
	                }
	                call.iceCandidateCollectionTimer = setTimeout(function() {
	                    self.iceCandidateCollectionTimeoutHandler(call);
	                }, fcsConfig.iceCandidateCollectionTimeoutInterval);
	            } else {
	                logger.trace("Ice candidate collection timer exists.");
	            }
	        }
	    };

	    /*
	     * Enabler implementation lies on webRtcPluginAdaptor.js
	     * onIceCandidate to be called when the enabler plugin is enabled
	     */
	    self.onIceCandidate = function(call, event) {
	        var sdp;
	        if (event.candidate === null) {
	            logger.debug("Null candidate received.");
	            if (call.successCallback) {
	                sdp = _sdpParser.getSdpFromObject(call.peer.localDescription);

	                if (_sdpParser.hasCandidates(sdp, call.relayCandidateCycle, fcsConfig.relayCandidateCollectionTimeoutCycle)) {
	                    self.clearIceCandidateCollectionTimer(call);
	                    logger.debug("Candidates received, invoking successCallback.");

	                    sdp = _sdpParser.updateH264Level(sdp);
	                    call.successCallback(sdp);
	                } else {
	                    logger.trace("Sdp does not have candidates.");
	                }

	            }
	        } else {
	            logger.debug("ICE candidate received : sdpMLineIndex = " + event.candidate.sdpMLineIndex +
	                ", candidate = " + event.candidate.candidate + " for call : " + call.id);
	        }
	    };

	    /*
	     * Enabler implementation lies on webRtcPluginAdaptor.js
	     * onIceComplete to be called when the enabler plugin is enabled
	     */
	    self.onIceComplete = function(call) {
	        var sdp;
	        logger.debug("All ICE candidates received for call : " + call.id);
	        self.clearIceCandidateCollectionTimer(call);

	        if (call.successCallback) {
	            sdp = call.peer.localDescription.sdp;
	            sdp = _sdpParser.updateH264Level(sdp);
	            logger.debug("onIceComplete sdp : " + sdp);

	            call.successCallback(sdp);
	        }
	    };

	    // Enabler implementation lies on webRtcPluginAdaptor.js
	    self.useDefaultRenderer = function(streamUrl, local, isVideoTrackAvailable) {
	        var videoContainer;

	        if (self.getDefaultVideoContainer() && self.getDefaultVideoContainer().children.length === 0) {
	            // Create divs for the remote and local
	            self.getDefaultVideoContainer().innerHTML = "<div style='height:100%;width:100%'></div><div style='position:absolute;bottom:10px;right:10px;height:30%; width:30%;'></div>";
	        }

	        if (local) {
	            videoContainer = self.getDefaultVideoContainer().lastElementChild;
	        } else {
	            videoContainer = self.getDefaultVideoContainer().firstElementChild;

	            if (!isVideoTrackAvailable) {
	                videoContainer.style.width = "0%";
	            } else {
	                videoContainer.style.width = "100%";
	            }
	        }
	        return self.createStreamRenderer(streamUrl, videoContainer, {
	            muted: local
	        });
	    };


	    // Enabler implementation lies on webRtcPluginAdaptor.js
	    self.createStreamRenderer = function(streamUrl, container) {
	        if (!streamUrl || !container) {
	            return;
	        }

	        container.innerHTML = "<object width='100%' height='100%' type='application/x-gcfwenabler-video'><param name='autoplay' value='true' /><param name='videosrc' value='" + streamUrl + "' /></object>";

	        return true;
	    };

	    // Enabler implementation lies on webRtcPluginAdaptor.js
	    self.sendIntraFrame = function(call) {
	        if (!call.peer) {
	            return;
	        }

	        if (self.canOriginatorSendLocalVideo(call)) {
	            call.peer.sendIntraFrame();
	        } else {
	            //call.peer.sendBlackFrame();
	            //sendBlackFrame is removed from plugin
	            return;
	        }
	    };

	    // Enabler implementation lies on webRtcPluginAdaptor.js
	    self.sendBlackFrame = function(call) {
	        if (!call.peer) {
	            return;
	        }
	        //call.peer.sendBlackFrame();
	        //TODO: This function will be completely removed since sendBlackFrame is removed from plugin
	        return;
	    };

	    /**
	     * Send DTMF tone
	     * Enabler implementation lies on webRtcPluginAdaptor.js
	     *
	     * @ignore
	     * @name rtc.sendDTMF
	     * @function
	     * @param {Object} call internalCall
	     * @param {String} tone DTMF tone
	     */
	    self.sendDTMF = function(call, tone) {
	        var localAudioTrack;

	        if (!call.dtmfSender) {
	            localAudioTrack = self.getLocalAudioTrack(call.peer);
	            if (!localAudioTrack) {
	                return;
	            }
	            call.dtmfSender = call.peer.createDTMFSender(localAudioTrack);
	            if (!call.dtmfSender) {
	                return;
	            }
	        }

	        if (call.dtmfSender.canInsertDTMF === true) {
	            call.dtmfSender.insertDTMF(tone, 400);
	            logger.info("sending outband DTMF tone: " + tone);
	        } else {
	            logger.error("Failed to execute 'insertDTMF' on 'RTCDTMFSender': The 'canInsertDTMF' attribute is false: this sender cannot send DTMF");
	        }
	    };

	    /*
	     * Enabler implementation lies on webRtcPluginAdaptor.js
	     */
	    self.getCameraList = function() {
	        return;
	    };

	    /*
	     * Enabler implementation lies on webRtcPluginAdaptor.js
	     */
	    self.getMicrophoneList = function() {
	        return;
	    };

	    /*
	     * Enabler implementation lies on webRtcPluginAdaptor.js
	     */
	    self.getSpeakerList = function() {
	        return;
	    };

	    self.getNativeWebRtcStats = function(call, onSuccess, onFailure) {
	        try {
	            if (call) {
	                logger.debug("getNativeWebRtcStats called");
	                call.peer.getStats(function(stats) {
	                    if (stats !== undefined && stats !== null) {
	                        var results = stats.result();
	                        _utils.callFunctionIfExist(onSuccess, results);
	                    }
	                });
	            }
	        } catch (err) {
	            logger.error("Failed to get all WebRTC Statistics: " + err.message);
	            _utils.callFunctionIfExist(onFailure, err);
	        }
	    };

	    self.getWebRtcStats = function(call, onSuccess, onFailure) {
	        try {
	            if (call) {
	                logger.debug("getWebRtcStats called");
	                self.collectWebRtcStats(call.sdp, call.peer,
	                    function(stats) {
	                        var accumulatedStats = self.getAccumulatedWebRtcStats(call.stats, stats, call.cache);
	                        _utils.callFunctionIfExist(onSuccess, accumulatedStats);
	                    },
	                    onFailure);
	            } else {
	                var cacheWebRtcStats = JSON.parse(_cache.getItem(_fcs.getUser() + '_stats'));
	                _utils.callFunctionIfExist(onSuccess, cacheWebRtcStats);
	            }
	        } catch (err) {
	            logger.error("Failed to get WebRTC Statistics: " + err.message);
	            _utils.callFunctionIfExist(onFailure, err);
	        }
	        return self.getStats();
	    };

	    self.getAccumulatedWebRtcStats = function(statsList, currentStats, callCache) {
	        var i, accumulatedStats = {
	            audio: {
	                packetsSent: 0,
	                bytesSent: 0,
	                bytesReceived: 0,
	                peerAddress: null,
	                codec: null,
	                packetsLost: 0,
	                jitter: null,
	                rtt: null
	            },
	            video: {
	                packetsSent: 0,
	                bytesSent: 0,
	                bytesReceived: 0,
	                peerAddress: null,
	                codec: null,
	                packetsLost: 0,
	                rtt: null
	            }
	        };
	        if (statsList !== undefined) {
	            for (i = 0; i < statsList.length; i++) {
	                self.accumulateStats(accumulatedStats.audio, statsList[i].audio);
	                self.accumulateStats(accumulatedStats.video, statsList[i].video);
	            }
	        }

	        self.accumulateStats(accumulatedStats.audio, currentStats.audio);
	        accumulatedStats.audio.peerAddress = currentStats.audio.peerAddress;
	        accumulatedStats.audio.codec = currentStats.audio.codec;
	        accumulatedStats.audio.jitter = currentStats.audio.jitter;
	        accumulatedStats.audio.rtt = currentStats.audio.rtt;

	        self.accumulateStats(accumulatedStats.video, currentStats.video);
	        accumulatedStats.video.peerAddress = currentStats.video.peerAddress;
	        accumulatedStats.video.codec = currentStats.video.codec;
	        accumulatedStats.video.rtt = currentStats.video.rtt;

	        if (callCache) {
	            _cache.setItem(_fcs.getUser() + '_stats', JSON.stringify(accumulatedStats));
	        }
	        return accumulatedStats;
	    };

	    self.accumulateStats = function(accumulatedStatsObj, statsObj) {
	        accumulatedStatsObj.packetsSent += _utils.getInteger(statsObj.packetsSent);
	        accumulatedStatsObj.bytesSent += _utils.getInteger(statsObj.bytesSent);
	        accumulatedStatsObj.bytesReceived += _utils.getInteger(statsObj.bytesReceived);
	        accumulatedStatsObj.packetsLost += _utils.getInteger(statsObj.packetsLost) === -1 ? 0 : _utils.getInteger(statsObj.packetsLost);
	    };

	    self.collectWebRtcStats = function(statsSdp, peer, onSuccess, onFailure) {
	        try {
	            if (peer) {
	                logger.debug("collectWebRtcStats called");
	                peer.getStats(function(stats) {
	                    if (stats !== undefined && stats !== null) {
	                        var results = stats.result();
	                        self.setWebRtcStats(results, statsSdp);

	                        _utils.callFunctionIfExist(onSuccess, self.getStats());
	                    }
	                });
	            }
	        } catch (err) {
	            logger.error("Failed to collectWebRtcStats: " + err.message);
	            _utils.callFunctionIfExist(onFailure, err);
	        }

	        return self.getStats();
	    };

	    self.setWebRtcStats = function(results, statsSdp) {

	        var i, j, res, names, mediaDescriptions, sdpAudioPort, sdpVideoPort,
	            transportId, googChannelId, googCodecName, alwaysMediaOnBroker,
	            stats = {
	                audio: {
	                    packetsSent: null,
	                    bytesSent: null,
	                    bytesReceived: null,
	                    peerAddress: "",
	                    codec: null,
	                    packetsLost: null,
	                    jitter: null,
	                    rtt: null
	                },
	                video: {
	                    packetsSent: null,
	                    bytesSent: null,
	                    bytesReceived: null,
	                    peerAddress: null,
	                    codec: null,
	                    packetsLost: null,
	                    rtt: null
	                }
	            };

	        if (_sdpParser.isIceLite(statsSdp)) {
	            alwaysMediaOnBroker = true;
	        } else {
	            alwaysMediaOnBroker = false;
	        }

	        if (statsSdp !== undefined && statsSdp !== null && results !== undefined && results !== null) {
	            _sdpParser.init(statsSdp);
	            _sdpParser.parseSDP(statsSdp);
	            mediaDescriptions = _sdpParser.getMediaDescriptions();

	            if (mediaDescriptions !== undefined) {
	                if (mediaDescriptions[0] !== undefined) {
	                    sdpAudioPort = mediaDescriptions[0].port;
	                }

	                if (mediaDescriptions[1] !== undefined) {
	                    sdpVideoPort = mediaDescriptions[1].port;
	                }
	            }

	            for (i = 0; i < results.length; i++) {
	                res = results[i];
	                names = res.names();
	                if (names !== undefined) {
	                    for (j = 0; j < names.length; j++) {
	                        googChannelId = res.stat("googChannelId");
	                        transportId = res.stat("transportId");
	                        googCodecName = res.stat("googCodecName");
	                        if ((transportId !== undefined && transportId.indexOf("audio") > -1) ||
	                            (googChannelId !== undefined && googChannelId.indexOf("audio") > -1)) {

	                            if (googCodecName === "VP8" || googCodecName === "H264") {
	                                self.fillStats(stats.video, res, names, j, sdpVideoPort, alwaysMediaOnBroker);
	                            } else {
	                                self.fillStats(stats.audio, res, names, j, sdpAudioPort, alwaysMediaOnBroker);
	                            }
	                        } else if ((transportId !== undefined && transportId.indexOf("video") > -1) ||
	                            (googChannelId !== undefined && googChannelId.indexOf("video") > -1)) {
	                            self.fillStats(stats.video, res, names, j, sdpVideoPort, alwaysMediaOnBroker);
	                        }

	                    }
	                    if (!alwaysMediaOnBroker && sdpVideoPort !== undefined) {
	                        stats.video.peerAddress = stats.audio.peerAddress.split(":")[0];
	                    }
	                    self.setStats(stats);
	                }
	            }
	        }

	    };

	    self.fillStats = function(statsObj, res, names, index, sdpRemotePort, alwaysMediaOnBroker) {
	        var remotePort, remoteAddress;

	        if ((res.stat("googActiveConnection") === "true") && alwaysMediaOnBroker) {
	            remoteAddress = res.stat("googRemoteAddress");

	            if (remoteAddress !== undefined) {
	                if (remoteAddress.split(":") !== undefined && remoteAddress.split(":")[1] !== undefined) {
	                    remotePort = remoteAddress.split(":")[1];
	                }

	                if (remotePort === sdpRemotePort) {

	                    statsObj.peerAddress = remoteAddress;

	                    if (names[index] === "bytesReceived") {
	                        statsObj.bytesReceived = res.stat(names[index]);
	                    }

	                    if (names[index] === "packetsSent") {
	                        statsObj.packetsSent = res.stat(names[index]);
	                    }

	                    if (names[index] === "bytesSent") {
	                        statsObj.bytesSent = res.stat(names[index]);
	                    }
	                }
	            }
	        }

	        if ((res.stat("googActiveConnection") === "true") && !alwaysMediaOnBroker) {
	            remoteAddress = res.stat("googRemoteAddress");
	            statsObj.peerAddress = remoteAddress;
	        }

	        if (res.type === "ssrc" || res.id.indexOf("ssrc") > -1) {
	            if (names[index] === "packetsLost") {
	                statsObj.packetsLost = res.stat(names[index]);
	            }

	            if (names[index] === "googCodecName") {
	                statsObj.codec = res.stat(names[index]);
	            }

	            if (names[index] === "googJitterReceived") {
	                statsObj.jitter = res.stat(names[index]);
	            }

	            if (names[index] === "googRtt") {
	                statsObj.rtt = res.stat(names[index]);
	            }

	            if (!alwaysMediaOnBroker) {
	                if (names[index] === "bytesReceived") {
	                    statsObj.bytesReceived = res.stat(names[index]);
	                }
	                if (names[index] === "packetsSent") {
	                    statsObj.packetsSent = res.stat(names[index]);
	                }
	                if (names[index] === "bytesSent") {
	                    statsObj.bytesSent = res.stat(names[index]);
	                }
	            }
	        }
	    };

	    logger.debug('WebRtcPluginAdaptor initialized');
	};

	//@{fcs-jsl-prod}
	var WebRtcPluginAdaptor = function(_super, _decorator, _model) {
	    var decorator = _decorator || webRtcLibraryDecorator,
	        model = _model || new WebRtcPluginAdaptorModel();
	    return new WebRtcPluginAdaptorImpl(_super ||
	        new WebRtcAdaptor({}, decorator, model),
	        decorator,
	        model,
	        logManager,
	        utils,
	        sdpParser,
	        fcs.call.MediaErrors,
	        cache,
	        fcs);
	};
	//@{fcs-jsl-prod}


	var WebRtcPluginv22AdaptorImpl = function(_super, _decorator, _model, _logManager) {
	    var self = this,
	        webRtcPlugin22Version = {
	            major: 2,
	            minor: 2,

	            min_revision: 477,
	            min_build: 0,

	            current_revision: 477,
	            current_build: 0
	        },
	        logger = _logManager.getLogger("WebRtcPluginv22AdaptorImpl");
	    logger.debug('WebRtcPluginv22Adaptor initializing');

	    utils.compose(_super, self);
	    utils.compose(_model, self);

	    self.setPluginVersion(webRtcPlugin22Version);
	    logger.debug('WebRtcPluginv22Adaptor initialized');
	};

	//@{fcs-jsl-prod}
	var WebRtcPluginv22Adaptor = function(_super, _decorator, _model) {
	    var decorator = _decorator || webRtcLibraryDecorator,
	        model = _model || new WebRtcPluginAdaptorModel();
	    return new WebRtcPluginv22AdaptorImpl(_super ||
	        new WebRtcPluginAdaptor(undefined, decorator, model),
	        decorator,
	        model,
	        logManager);
	};
	//@{fcs-jsl-prod}


	var WebRtcPluginv31AdaptorImpl = function(_super, _decorator, _model, _logManager) {
	    var self = this,
	        webRtcPlugin31Version = {
	            major: 3,
	            minor: 1,

	            min_revision: 500,
	            min_build: 0,

	            current_revision: 520,
	            current_build: 0
	        },
	        logger = _logManager.getLogger("WebRtcPluginv31AdaptorImpl");
	    logger.debug('WebRtcPluginv31Adaptor initializing');

	    utils.compose(_super, self);
	    utils.compose(_model, self);

	    self.setPluginVersion(webRtcPlugin31Version);

	    /**
	     * Send DTMF tone
	     * Enabler implementation lies on webRtcPluginv31Adaptor.js
	     *
	     * @ignore
	     * @name rtc.sendDTMF
	     * @function
	     * @param {Object} call internalCall
	     * @param {String} tone DTMF tone
	     */
	    self.sendDTMF = function(call, tone) {
	        var localAudioTrack;

	        if (!call.dtmfSender) {
	            localAudioTrack = self.getLocalAudioTrack(call.peer);
	            if (!localAudioTrack) {
	                return;
	            }
	            call.dtmfSender = call.peer.createDTMFSender(localAudioTrack);
	            if (!call.dtmfSender) {
	                return;
	            }
	        }

	        if (!sdpParser.isSdpHasTelephoneEvent(call.peer.remoteDescription.sdp)) {
	            call.dtmfSender.insertDTMF(tone, 400, 100, true);
	            logger.info("sending inband DTMF tone: " + tone);
	        } else {
	            if (call.dtmfSender.canInsertDTMF === true) {
	                call.dtmfSender.insertDTMF(tone, 400);
	                logger.info("sending outband DTMF tone: " + tone);
	            } else {
	                logger.error("Failed to execute 'insertDTMF' on 'RTCDTMFSender': The 'canInsertDTMF' attribute is false: this sender cannot send DTMF");
	            }
	        }
	    };

	    logger.debug('WebRtcPluginv31Adaptor initialized');
	};

	//@{fcs-jsl-prod}
	var WebRtcPluginv31Adaptor = function(_super, _decorator, _model) {
	    var decorator = _decorator || webRtcLibraryDecorator,
	        model = _model || new WebRtcPluginAdaptorModel();
	    return new WebRtcPluginv31AdaptorImpl(_super ||
	        new WebRtcPluginAdaptor(undefined, decorator, model),
	        decorator,
	        model,
	        logManager);
	};
	//@{fcs-jsl-prod}


	var WebRtcChromeAdaptorImpl = function(_super, _decorator, _model, _logManager, _utils) {
	    var self = this,
	        logger = _logManager.getLogger("WebRtcChromeAdaptorImpl");
	    logger.debug('WebRtcChromeAdaptor initializing');

	    /*
	     * Native implementation lies on webRtcAdaptor.js
	     * Most of this function is identitical to the native implementation.
	     */
	    self.startScreenMedia = function(onSuccess, onFailure, onEnded) {
	        self.getRtcLibrary().checkMediaSourceAvailability(function mediaSourceCallback(mediaSourceInfo) {
	            var video_constraints;
	            self.setMediaSources(mediaSourceInfo);
	            if (self.getScreenSourceAvailable()) {
	                video_constraints = {
	                    mandatory: {
	                        "maxFrameRate": self.getScreenFrameRate(),
	                        "maxWidth": self.getScreenWidth(),
	                        "maxHeight": self.getScreenHeight()
	                    }
	                };

	                // This if statement is the only change from the default adaptor.
	                if(self.getMediaSourceId()) {
	                    video_constraints.mandatory.chromeMediaSourceId = self.getMediaSourceId();
	                }

	                self.getRtcLibrary().getScreenMedia({
	                    video: video_constraints
	                }, function(stream) {
	                    var mediaInfo = self.replaceVideoStream(stream),
	                        oldStream = self.getScreenStream();

	                    // If there is an old screen stream, just stop it but prevent the stop from happening
	                    if(oldStream) {
	                        oldStream.onended = null;
	                        self.getRtcLibrary().stopStream(oldStream);
	                    }

	                    stream.onended = onEnded;
	                    self.setScreenStream(stream);

	                    logger.debug("user granted access to local media.");
	                    utils.callFunctionIfExist(onSuccess, mediaInfo);

	                }, function() {
	                    logger.debug("Failed to get access to screen media.");
	                    utils.callFunctionIfExist(onFailure, fcs.call.MediaErrors.NOT_ALLOWED);
	                }, onEnded);
	            } else {
	                utils.callFunctionIfExist(onFailure, fcs.call.MediaErrors.NOT_FOUND);
	            }
	        });
	    };

	    _utils.compose(_super, self);
	    _utils.compose(_model, self);

	    logger.debug('WebRtcChromeAdaptor initialized');
	};

	//@{fcs-jsl-prod}
	var WebRtcChromeAdaptor = function(_super, _decorator, _model) {
	    var decorator = _decorator || webRtcLibraryChromeDecorator,
	        model = _model || new WebRtcChromeAdaptorModel();
	    return new WebRtcChromeAdaptorImpl(_super ||
	        new WebRtcAdaptor({}, decorator, model),
	        decorator,
	        model,
	        logManager,
	        utils);
	};
	//@{fcs-jsl-prod}


	var WebRtcFirefoxAdaptorImpl = function(_super, _decorator, _model, _logManager, _utils, _sdpParser, _mediaErrors) {
	    var self = this,
	        logger = _logManager.getLogger("WebRtcFirefoxAdaptorImpl");
	    logger.debug('WebRtcFirefoxAdaptor initializing');

	    _utils.compose(_super, self);
	    _utils.compose(_model, self);

	    // firefoxPerformSdpWorkaroundsBeforeProcessingIncomingSdp
	    self.performSdpWorkaroundsBeforeProcessingIncomingSdp = function(call) {
	        call.sdp = _sdpParser.updateH264LevelTo42E01F(call.sdp, self.isH264Enabled());
	        call.sdp = _sdpParser.deleteBandwidthLineFromSdp(call.sdp);
	        call.sdp = _sdpParser.addRtpmapForPCMU(call.sdp);
	        call.sdp = _sdpParser.addRtpmapForPCMA(call.sdp);
	        call.sdp = _sdpParser.removeG722Codec(call.sdp);
	        call.sdp = _sdpParser.setOpusCodecToLowerCase(call.sdp);
	    };

	    // firefoxGetUserMedia
	    self.getUserMedia = function(params) {
	        self.getRtcLibrary().checkMediaSourceAvailability(function mediaSourceCallback(mediaSourceInfo) {
	            var mediaInfo, mediaStreamSource, constraints = {
	                    audio: false,
	                    video: false
	                },
	                localMedia;
	            self.setMediaSources(mediaSourceInfo);

	            if (mediaSourceInfo) {
	                if (!mediaSourceInfo.audioSourceAvailable) {
	                    logger.debug("Failed to get access to local media.");
	                    _utils.callFunctionIfExist(params.onFailure, _mediaErrors.NOT_FOUND);
	                    return;
	                }
	            }

	            if (self.getMediaVideo() && self.getVideoSourceAvailable()) {
	                constraints.video = params.options.videoConstraints;
	            }
	            if (self.getMediaAudio() && self.getAudioSourceAvailable()) {
	                constraints.audio = params.options.audioConstraints;
	            }

	            logger.debug("getUserMedia - constraints: ", constraints);
	            self.getRtcLibrary().getUserMedia(constraints, function getUserMediaSuccessCallback(stream) {
	                if (constraints.video) {
	                    localMedia = {
	                        audioContext: {
	                            close: function() {}
	                        },
	                        mediaStreamDestination: {
	                            disconnect: function() {}
	                        },
	                        stream: stream,
	                        originalStream: stream
	                    };
	                } else {
	                    self.initAudioContext();
	                    mediaStreamSource = self.getAudioContext().createMediaStreamSource(stream);
	                    self.initMediaStreamDestination();
	                    mediaStreamSource.connect(self.getMediaStreamDestination());

	                    localMedia = {
	                        audioContext: self.getAudioContext(),
	                        mediaStreamDestination: self.getMediaStreamDestination(),
	                        stream: self.getMediaStreamDestination().stream,
	                        originalStream: stream
	                    };
	                }

	                self.setLocalMedia(localMedia);
	                self.getLocalStreamMap().add(localMedia.stream.id, localMedia);
	                self.setInitialized(true);

	                mediaInfo = {
	                    audio: self.getMediaAudio(),
	                    video: self.getMediaVideo(),
	                    id: localMedia.stream.id,
	                    originalStream: stream,
	                    streamURL: self.getRtcLibrary().getURLFromStream(stream)
	                };

	                logger.debug("user has granted access to local media: ", localMedia);
	                _utils.callFunctionIfExist(params.onSuccess, mediaInfo);
	            }, function getUserMediaFailureCallback(error) {
	                logger.debug("Failed to get access to local media. Error code was " + error.code);
	                _utils.callFunctionIfExist(params.onFailure, _mediaErrors.NOT_ALLOWED);
	            });
	        });
	    };

	    self.createDataChannelOffer = function (call, successCallback, failureCallback) {
	        logger.debug("createDataChannelOffer: state= " + call.peer.signalingState);
	        var peer = call.peer, localDesc;

	        peer.createOffer(function createOfferSuccessCallback(oSdp) {
	            localDesc = self.getRtcLibrary().createRTCSessionDescription(CONSTANTS.WEBRTC.RTC_SDP_TYPE.OFFER, oSdp.sdp);
	            peer.setLocalDescription(localDesc, function createOfferSetLocalDescriptionSuccessCallback() {
	                logger.debug("createDataChannelOffer: setLocalDescription success");
	                //Due to stun requests, successCallback will be called by onNativeIceCandidate()
	            }, function createOfferSetLocalDescriptionFailureCallback(error) {
	                logger.error("createDataChannelOffer: setLocalDescription failed : " + error);
	                _utils.callFunctionIfExist(failureCallback, "createDataChannelOffer: setLocalDescription failed");
	            });
	        }, function createOfferFailureCallback(e) {
	            logger.error("createDataChannelOffer: createOffer failed!! " + e);
	            _utils.callFunctionIfExist(failureCallback);
	        }, self.getRtcLibrary().createConstraints(self.getMediaAudio(), self.getMediaVideo()));
	    };

	    // firefoxCreateOffer
	    self.createOffer = function(call, successCallback, failureCallback, sendInitialVideo) {
	        logger.debug("createOffer: sendInitialVideo= " + sendInitialVideo + " state= " + call.peer.signalingState);
	        var peer = call.peer;

	        call.peer.addStream(call.localMedia.stream);

	        peer.createOffer(
	            function createOfferSuccessCallback(oSdp) {
	                sendInitialVideo = sendInitialVideo && self.getVideoSourceAvailable();
	                if (sendInitialVideo) {
	                    oSdp.sdp = _sdpParser.updateVideoSdpDirection(oSdp.sdp, CONSTANTS.WEBRTC.MEDIA_STATE.SEND_RECEIVE);
	                } else {
	                    oSdp.sdp = _sdpParser.updateVideoSdpDirection(oSdp.sdp, CONSTANTS.WEBRTC.MEDIA_STATE.RECEIVE_ONLY);
	                }

	                oSdp.sdp = _sdpParser.deleteCryptoZeroFromSdp(oSdp.sdp);

	                oSdp.sdp = _sdpParser.removeG722Codec(oSdp.sdp);

	                oSdp.sdp = _sdpParser.deleteCryptoFromSdp(oSdp.sdp, self.isDtlsEnabled());
	                oSdp.sdp = _sdpParser.setTcpSetupAttributeToActpass(oSdp.sdp, self.isDtlsEnabled());

	                oSdp.sdp = self.updateCodecs(call, oSdp.sdp);

	                peer.setLocalDescription(
	                    self.getRtcLibrary().createRTCSessionDescription(CONSTANTS.WEBRTC.RTC_SDP_TYPE.OFFER, oSdp.sdp),
	                    function createOfferSetLocalDescriptionSuccessCallback() {
	                        //Due to stun requests, successCallback will be called by onNativeIceCandidate()
	                    },
	                    function createOfferSetLocalDescriptionFailureCallback(error) {
	                        logger.error("createOffer: setLocalDescription failed : " + error);
	                        _utils.callFunctionIfExist(failureCallback, "createOffer: setLocalDescription failed");
	                    });
	            },
	            function createOfferFailureCallback(e) {
	                logger.error("createOffer: createOffer failed!! " + e);
	                _utils.callFunctionIfExist(failureCallback);
	            }, self.getRtcLibrary().createConstraints(self.getMediaAudio(), self.getMediaVideo()));
	    };

	    // firefoxCreateReOffer
	    self.createReOffer = function(call, onSuccess, onFailure, usePreviousMediaDirection, useIceServer) {
	        var peer = call.peer,
	            localDescObj, localAudioDirection, localVideoDirection,
	            prevLocalSdp = call.stableLocalSdp,
	            deleteVideoStream = false,
	            mediaVideo = self.getMediaVideo(),
	            data;

	        logger.debug("createReOffer:" + call.id);

	        if (!usePreviousMediaDirection) {
	            deleteVideoStream = !call.initialVideoState && sdpParser.isSdpHasVideo(call.stableLocalSdp);
	            mediaVideo = mediaVideo && call.initialVideoState;
	        }

	        data = {
	            call: call,
	            mustCreatePeer: true,
	            deleteVideoStream: deleteVideoStream,
	            useIceServer: useIceServer
	        };
	        if (self.createNewPeerForCall(data)) {
	            peer = call.peer;
	        }

	        peer.createOffer(
	            function createReOfferCreateOfferSuccessCallback(oSdp) {

	                if (usePreviousMediaDirection) {
	                    localAudioDirection = _sdpParser.getAudioSdpDirection(prevLocalSdp);
	                    oSdp.sdp = _sdpParser.updateAudioSdpDirection(oSdp.sdp, localAudioDirection);
	                    localVideoDirection = _sdpParser.getVideoSdpDirection(prevLocalSdp);
	                    oSdp.sdp = _sdpParser.updateVideoSdpDirection(oSdp.sdp, localVideoDirection);
	                }

	                oSdp.sdp = _sdpParser.deleteCryptoZeroFromSdp(oSdp.sdp);
	                oSdp.sdp = _sdpParser.removeG722Codec(oSdp.sdp);
	                oSdp.sdp = _sdpParser.deleteCryptoFromSdp(oSdp.sdp, self.isDtlsEnabled());
	                oSdp.sdp = _sdpParser.setTcpSetupAttributeToActpass(oSdp.sdp, self.isDtlsEnabled());
	                oSdp.sdp = _sdpParser.updateVersion(prevLocalSdp, oSdp.sdp);
	                oSdp.sdp = self.updateCodecs(call, oSdp.sdp);

	                localDescObj = self.getRtcLibrary().createRTCSessionDescription(CONSTANTS.WEBRTC.RTC_SDP_TYPE.OFFER, oSdp.sdp);
	                peer.setLocalDescription(localDescObj, function createReOfferSetLocalDescriptionSuccessCallback() {
	                        logger.debug("createReOffer: setLocalDescription success" + call.id);
	                    }, function createReOfferSetLocalDescriptionFailureCallback(e) {
	                        logger.debug("createReOffer: setLocalDescription failed!!" + e + call.id);
	                        _utils.callFunctionIfExist(onFailure);
	                    });
	            },
	            function createReOfferCreateOfferFailureCallback(e) {
	                logger.error("createReOffer: createOffer failed!! " + e);
	                _utils.callFunctionIfExist(onFailure);
	            }, self.getRtcLibrary().createConstraints(self.getMediaAudio(), mediaVideo));
	    };

	    // firefoxProcessAnswer
	    self.processAnswer = function(call, successCallback, failureCallback) {
	        var remoteVideoDirection, localVideoDirection, peer = call.peer;
	        logger.debug("processAnswer: state= " + peer.signalingState);

	        call.sdp = _sdpParser.checkSupportedVideoCodecs(call.sdp, peer.localDescription.sdp, self.isH264Enabled());
	        call.sdp = _sdpParser.performVideoPortZeroWorkaround(call.sdp);

	        remoteVideoDirection = _sdpParser.getVideoSdpDirection(call.sdp);
	        localVideoDirection = _sdpParser.getVideoSdpDirection(call.peer.localDescription.sdp);

	        self.setRemoteDescription(call, peer, CONSTANTS.WEBRTC.RTC_SDP_TYPE.ANSWER, call.sdp,
	            function processAnswerSetRemoteDescriptionSuccessCallback() {
	                logger.debug("processAnswer: setRemoteDescription success");
	                call.remoteVideoState = _sdpParser.getVideoSdpDirection(call.sdp);
	                _utils.callFunctionIfExist(successCallback);
	            },
	            function processAnswerSetRemoteDescriptionFailureCallback(e) {
	                logger.error("processAnswer: setRemoteDescription failed: " + e.message);
	                _utils.callFunctionIfExist(failureCallback);
	            });
	    };

	    // firefoxRevertRtcState
	    self.revertRtcState = function(call, successCallback) {
	        //no need to create new peer to handle revertRtc case. Peer will be handled after retryAfter period.

	        // TODO: Setting timeout to 0 skips the problem of successive holds without glare condition
	        // A real solution have to be found
	        setTimeout(function() {
	            _utils.callFunctionIfExist(successCallback, call);
	        }, 0);
	    };

	    // firefoxCreateHoldUpdate
	    self.createHoldUpdate = function(call, hold, remote_hold_status, successCallback, failureCallback, useIceServer) {
	        logger.debug("createHoldUpdate: local hold= " + hold + " remote hold= " + remote_hold_status + " state= " + call.peer.signalingState);
	        var peer = call.peer,
	            localDescObj,
	            localSdp,
	            createHoldUpdate,
	            hasActiveVideo;

	        createHoldUpdate = function() {
	            localSdp = call.stableLocalSdp;

	            if (self.createNewPeerForCall({
	                call: call,
	                mustCreatePeer: true,
	                useIceServer: useIceServer
	            })) {
	                peer = call.peer;
	            }

	            peer.createOffer(function createHoldUpdateCreateOfferSuccessCallback(obj) {

	                if (hold) {
	                    if (!remote_hold_status) {
	                        obj.sdp = _sdpParser.updateAudioSdpDirection(obj.sdp, CONSTANTS.WEBRTC.MEDIA_STATE.SEND_ONLY);
	                        obj.sdp = _sdpParser.updateVideoSdpDirection(obj.sdp, CONSTANTS.WEBRTC.MEDIA_STATE.SEND_ONLY);
	                    } else {
	                        obj.sdp = _sdpParser.updateAudioSdpDirectionToInactive(obj.sdp);
	                        obj.sdp = _sdpParser.updateVideoSdpDirectionToInactive(obj.sdp);
	                    }
	                } else if (remote_hold_status) {
	                    obj.sdp = _sdpParser.updateAudioSdpDirection(obj.sdp, CONSTANTS.WEBRTC.MEDIA_STATE.SEND_RECEIVE);
	                    obj.sdp = _sdpParser.updateVideoSdpDirection(obj.sdp, CONSTANTS.WEBRTC.MEDIA_STATE.SEND_RECEIVE);
	                } else {
	                    obj.sdp = _sdpParser.updateAudioSdpDirection(obj.sdp, CONSTANTS.WEBRTC.MEDIA_STATE.SEND_RECEIVE);
	                    if (self.canOriginatorSendLocalVideo(call)) {
	                        obj.sdp = _sdpParser.updateVideoSdpDirection(obj.sdp, CONSTANTS.WEBRTC.MEDIA_STATE.SEND_RECEIVE);
	                    } else {
	                        obj.sdp = _sdpParser.updateVideoSdpDirection(obj.sdp, CONSTANTS.WEBRTC.MEDIA_STATE.RECEIVE_ONLY);
	                    }
	                }
	                obj.sdp = self.updateCodecs(call, obj.sdp);
	                obj.sdp = _sdpParser.updateVersion(localSdp, obj.sdp);
	                obj.sdp = _sdpParser.deleteCryptoZeroFromSdp(obj.sdp);
	                obj.sdp = _sdpParser.setTcpSetupAttributeToActpass(obj.sdp, self.isDtlsEnabled());

	                localDescObj = self.getRtcLibrary().createRTCSessionDescription(CONSTANTS.WEBRTC.RTC_SDP_TYPE.OFFER, obj.sdp);

	                peer.setLocalDescription(localDescObj, function createHoldUpdateSetLocalDescriptionSuccessCallback() {
	                    logger.debug("createHoldUpdate setLocalDescription success. iceConnectionState: " + peer.iceConnectionState + " iceGatheringState: " + peer.iceGatheringState);
	                    if (peer.iceGatheringState === "complete") {
	                        if (call.successCallback) {
	                            logger.debug("createHoldUpdate iceGatheringState completed " + peer.localDescription.sdp);
	                            _utils.callFunctionIfExist(successCallback, peer.localDescription.sdp);
	                        }
	                    }
	                }, function createHoldUpdateSetLocalDescriptionFailureCallback(error) {
	                    logger.error("createHoldUpdate: setLocalDescription failed: " + error.message);
	                    _utils.callFunctionIfExist(failureCallback);
	                });
	            }, function createHoldUpdateCreateOfferFailureCallback(error) {
	                logger.error("createHoldUpdate: createOffer failed: " + error.message);
	                _utils.callFunctionIfExist(failureCallback);
	            }, self.getRtcLibrary().createConstraints(self.getMediaAudio(), self.getMediaVideo()));
	        };

	        hasActiveVideo = _sdpParser.isSdpHasVideo(call.sdp) &&
	            !_sdpParser.isVideoSdpDirectionInactive(call.stableLocalSdp);

	        if (!call.isVideoSourceAllowed && hasActiveVideo) {
	            self.setMediaAudio(true);
	            self.setMediaVideo(true);

	            // TODO: This should not be done here just for code consistency
	            self.getUserMedia({
	                onSuccess: function (mediaInfo) {
	                    self.storeLocalStreamToCall(call, mediaInfo.id);
	                    call.isVideoSourceAllowed = mediaInfo.video;
	                    createHoldUpdate();
	                }, onFailure: function () {
	                    _utils.callFunctionIfExist(failureCallback);
	                }, options: {
	                    audioConstraints: true,
	                    videoConstraints: true
	                }});
	        } else {
	            if (hasActiveVideo) {
	                call.isVideoSourceAllowed = true;
	            }
	            createHoldUpdate();
	        }
	    };

	    // firefoxProcessHold
	    self.processHold = function(call, hold, local_hold_status, successCallback, failureCallback, useIceServer) {
	        logger.debug("processHold: local hold= " + local_hold_status + " remote hold= " + hold + " state= " + call.peer.signalingState);
	        var peer = call.peer,
	            audioDirection = _sdpParser.getAudioSdpDirection(call.sdp);

	        if (!local_hold_status && !hold) {
	            self.muteOnHold(call, false);
	        }

	        call.sdp = _sdpParser.checkSupportedVideoCodecs(call.sdp, null);
	        call.sdp = _sdpParser.performVideoPortZeroWorkaround(call.sdp);
	        call.sdp = _sdpParser.setTcpSetupAttributeToActpass(call.sdp, self.isDtlsEnabled());

	        if (self.createNewPeerForCall({
	            call: call,
	            mustCreatePeer: true,
	            useIceServer: useIceServer
	        })) {
	            peer = call.peer;
	        }

	        self.setRemoteDescription(call, peer, CONSTANTS.WEBRTC.RTC_SDP_TYPE.OFFER, call.sdp, function processHoldSetRemoteDescriptionSuccessCallback() {
	            peer.createAnswer(function (obj) {
	                if (hold) {
	                    logger.debug("processHold: Remote HOLD");
	                    obj.sdp = _sdpParser.respondToRemoteSdpDirections(obj.sdp, call.sdp);
	                } else if (!local_hold_status) {
	                    logger.debug("processHold: Remote UNHOLD: direction left as it is");

	                    if (_sdpParser.isSdpVideoSendEnabled(call.sdp)) {
	                        if (self.canOriginatorSendLocalVideo(call)) {
	                            obj.sdp = _sdpParser.updateVideoSdpDirection(obj.sdp, CONSTANTS.WEBRTC.MEDIA_STATE.SEND_RECEIVE);
	                        } else {
	                            obj.sdp = _sdpParser.updateVideoSdpDirection(obj.sdp, CONSTANTS.WEBRTC.MEDIA_STATE.RECEIVE_ONLY);
	                        }
	                    } else {
	                        if (self.canOriginatorSendLocalVideo(call) && !_sdpParser.isVideoSdpDirectionInactive(call.sdp)) {
	                            obj.sdp = _sdpParser.updateVideoSdpDirection(obj.sdp, CONSTANTS.WEBRTC.MEDIA_STATE.SEND_ONLY);
	                        } else {
	                            obj.sdp = _sdpParser.updateVideoSdpDirection(obj.sdp, CONSTANTS.WEBRTC.MEDIA_STATE.INACTIVE);
	                        }
	                    }
	                    //change audio's direction to sendrecv for ssl attendees in a 3wc
	                    obj.sdp = _sdpParser.changeDirection(obj.sdp, CONSTANTS.WEBRTC.MEDIA_STATE.RECEIVE_ONLY, CONSTANTS.WEBRTC.MEDIA_STATE.SEND_RECEIVE, CONSTANTS.STRING.AUDIO);
	                } else if (local_hold_status && !hold) {
	                    logger.debug("processHold: Remote UNHOLD on local hold");

	                    if (audioDirection === CONSTANTS.WEBRTC.MEDIA_STATE.INACTIVE) {
	                        obj.sdp = _sdpParser.updateAudioSdpDirectionToInactive(obj.sdp);
	                    } else {
	                        obj.sdp = _sdpParser.updateAudioSdpDirection(obj.sdp, CONSTANTS.WEBRTC.MEDIA_STATE.SEND_ONLY);
	                    }

	                    if (self.canOriginatorSendLocalVideo(call)) {
	                        obj.sdp = _sdpParser.updateVideoSdpDirection(obj.sdp, CONSTANTS.WEBRTC.MEDIA_STATE.SEND_ONLY);
	                    } else {
	                        obj.sdp = _sdpParser.updateVideoSdpDirectionToInactive(obj.sdp);
	                    }
	                }

	                obj.sdp = _sdpParser.setTcpSetupAttributeTo(obj.sdp, call.localTcpSetupAttribute, self.isDtlsEnabled());

	                peer.setLocalDescription(obj, function processHoldSetLocalDescriptionSuccessCallback() {
	                    logger.debug("processHold: setLocalDescription succeeded");
	                }, function processHoldSetLocalDescriptionFailureCallback(e) {
	                    logger.error("processHold: setLocalDescription failed!! " + e);
	                    _utils.callFunctionIfExist(failureCallback, "Session cannot be created");
	                });
	            }, function () {
	                logger.debug("processHold: createAnswer failed!!");
	                _utils.callFunctionIfExist(failureCallback, "Session cannot be created");
	            }, self.getRtcLibrary().createConstraints(self.getMediaAudio(), self.getMediaVideo()));
	        }, function processHoldSetRemoteDescriptionFailureCallback(e) {
	            logger.error("processHold: setRemoteDescription failed: " + e.message);
	            _utils.callFunctionIfExist(failureCallback, "Session cannot be created");
	        });
	    };

	    // firefoxProcessHoldRespond
	    self.processHoldRespond = function(call, onSuccess, onFailure, isJoin) {
	        var remoteAudioDirection,
	            remoteVideoDirection,
	            localHoldFlag = false,
	            remoteHoldFlag = false;

	        logger.debug("processHoldRespond: state= " + call.peer.signalingState + " call.currentState= " + call.currentState);

	        if (call.peer.signalingState === CONSTANTS.WEBRTC.RTC_SIGNALING_STATE.STABLE) {
	            //if we are in stable state we should not change remotedescription
	            self.setRemoteDescription(call, null, null, call.sdp, onSuccess, onFailure);
	            return;
	        }

	        call.sdp = _sdpParser.checkSupportedVideoCodecs(call.sdp, call.stableLocalSdp, self.isH264Enabled());

	        _sdpParser.init(call.sdp);
	        remoteHoldFlag = _sdpParser.isRemoteHold();

	        localHoldFlag = (call.currentState === "LOCAL_HOLD");

	        remoteAudioDirection = _sdpParser.getAudioSdpDirection(call.sdp);
	        remoteVideoDirection = _sdpParser.getVideoSdpDirection(call.sdp);

	        call.remoteVideoState = remoteVideoDirection;

	        logger.debug("processHoldRespond: localHold= " + localHoldFlag + " remoteHold= " + remoteHoldFlag);

	        /* Required for MOH - start */
	        if (remoteHoldFlag === false) {
	            if ((remoteAudioDirection === CONSTANTS.WEBRTC.MEDIA_STATE.SEND_RECEIVE) && (call.currentState === "REMOTE_HOLD")) {
	                logger.debug("set current web state to COMPLETED");
	                call.previousState = call.currentState;
	                call.currentState = "COMPLETED";
	            }
	        } else {
	            if (call.currentState === "COMPLETED") {
	                logger.debug("set current web state to REMOTE_HOLD");
	                call.previousState = call.currentState;
	                call.currentState = "REMOTE_HOLD";
	            }
	        }

	        if (localHoldFlag || remoteHoldFlag) {
	            logger.debug("processHoldRespond: " + call.currentState + " : video -> inactive");
	            call.sdp = _sdpParser.updateVideoSdpDirection(call.sdp, CONSTANTS.WEBRTC.MEDIA_STATE.INACTIVE);
	        }

	        /* Required for MOH - end */

	        if (isJoin) {
	            self.muteOnHold(call, false);
	        }

	        // this is required for displaying remote video when direction is send only
	        // call.sdp = _sdpParser.changeDirection(call.sdp, CONSTANTS.WEBRTC.MEDIA_STATE.SEND_ONLY, CONSTANTS.WEBRTC.MEDIA_STATE.SEND_RECEIVE, video);
	        if (_sdpParser.getVideoSdpDirection(call.sdp) === CONSTANTS.WEBRTC.MEDIA_STATE.INACTIVE ||
	            _sdpParser.getVideoSdpDirection(call.sdp) === CONSTANTS.WEBRTC.MEDIA_STATE.RECEIVE_ONLY) {
	            call.sdp = _sdpParser.deleteInactiveVideoSsrc(call.sdp);
	        }

	        if (localHoldFlag && remoteAudioDirection === CONSTANTS.WEBRTC.MEDIA_STATE.SEND_RECEIVE) {
	            logger.debug("processHoldRespond: Mute Remote Audio");
	            call.sdp = _sdpParser.updateAudioSdpDirection(call.sdp, CONSTANTS.WEBRTC.MEDIA_STATE.RECEIVE_ONLY);
	        }

	        if (localHoldFlag && remoteVideoDirection === CONSTANTS.WEBRTC.MEDIA_STATE.SEND_RECEIVE) {
	            logger.debug("processHoldRespond: Mute Remote Video");
	            call.sdp = _sdpParser.updateVideoSdpDirection(call.sdp, CONSTANTS.WEBRTC.MEDIA_STATE.RECEIVE_ONLY);
	        }

	        self.setRemoteDescription(call, call.peer, CONSTANTS.WEBRTC.RTC_SDP_TYPE.ANSWER, call.sdp,
	            function processHoldRespondSetRemoteDescriptionSuccessCallback() {
	                logger.debug("processHoldRespond: setRemoteDescription typeAns success");
	                _utils.callFunctionIfExist(onSuccess);
	            },
	            function processHoldRespondSetRemoteDescriptionFailureCallback(e) {
	                logger.debug("processHoldRespond: setRemoteDescription typeAns failed: " + e);
	                _utils.callFunctionIfExist(onFailure);
	            });
	    };

	    // firefoxCreateUpdate
	    self.createUpdate = function(call, successCallback, failureCallback, isVideoStart, useIceServer) {
	        logger.debug("createUpdate: isVideoStart= " + isVideoStart + " state= " + call.peer.signalingState);
	        var peer = call.peer,
	            localDesc;

	        if (self.createNewPeerForCall({
	            call: call,
	            mustCreatePeer: true,
	            useIceServer: useIceServer
	        })) {
	            peer = call.peer;
	        }

	        peer.createOffer(function createUpdateCreateOfferSuccessCallback(obj) {
	            isVideoStart = isVideoStart && self.getVideoSourceAvailable();
	            if (isVideoStart) {
	                obj.sdp = _sdpParser.updateVideoSdpDirection(obj.sdp, CONSTANTS.WEBRTC.MEDIA_STATE.SEND_RECEIVE);
	            } else {
	                if (_sdpParser.isVideoSdpDirectionInactive(call.stableRemoteSdp)) {
	                    obj.sdp = _sdpParser.updateVideoSdpDirectionToInactive(obj.sdp);
	                } else {
	                    obj.sdp = _sdpParser.updateVideoSdpDirection(obj.sdp, CONSTANTS.WEBRTC.MEDIA_STATE.RECEIVE_ONLY);
	                }
	            }
	            obj.sdp = self.updateCodecs(call, obj.sdp);
	            obj.sdp = _sdpParser.updateVersion(call.stableLocalSdp, obj.sdp);
	            obj.sdp = _sdpParser.setTcpSetupAttributeToActpass(obj.sdp, self.isDtlsEnabled());
	            obj.sdp = _sdpParser.deleteCryptoZeroFromSdp(obj.sdp);
	            obj.sdp = _sdpParser.removeG722Codec(obj.sdp);
	            obj.sdp = _sdpParser.deleteCryptoFromSdp(obj.sdp, self.isDtlsEnabled());

	            localDesc = self.getRtcLibrary().createRTCSessionDescription(CONSTANTS.WEBRTC.RTC_SDP_TYPE.OFFER, obj.sdp);

	            peer.setLocalDescription(localDesc, function createUpdateCreateOfferSetLocalDescriptionSuccessCallback() {
	                //since the candidates have changed we will call the successCallback at onIceCandidate
	                //_utils.callFunctionIfExist(successCallback);
	                logger.debug("createUpdate: createOffer setLocalDescription success ");
	            }, function crateUpdateCreateOfferSetLocalDescriptionFailureCallback(e) {
	                logger.debug("createUpdate: createOffer setLocalDescription failed: " + e);
	                _utils.callFunctionIfExist(failureCallback);
	            });
	        }, function createUpdateCrateOfferFailureCallback(e) {
	            logger.debug("createUpdate: createOffer failed!!: " + e);
	            _utils.callFunctionIfExist(failureCallback);
	        }, self.getRtcLibrary().createConstraints(self.getMediaAudio(), self.getMediaVideo()));
	    };

	    // firefoxProcessUpdate
	    self.processUpdate = function(call, successCallback, failureCallback, local_hold_status, useIceServer) {
	        logger.debug("processUpdate: state= " + call.peer.signalingState);
	        var peer = call.peer,
	            localDescObj, peerLocalSdp;
	        peerLocalSdp = call.stableLocalSdp;

	        // Meetme workarounds
	        call.sdp = _sdpParser.addSdpMissingCryptoLine(call.sdp);
	        call.sdp = _sdpParser.checkAndRestoreICEParams(call.sdp, peerLocalSdp);
	        call.sdp = _sdpParser.checkSupportedVideoCodecs(call.sdp, null, self.isH264Enabled());
	        call.sdp = _sdpParser.setTcpSetupAttributeToActpass(call.sdp, self.isDtlsEnabled());

	        if (self.createNewPeerForCall({
	            call: call,
	            mustCreatePeer: true,
	            useIceServer: useIceServer
	        })) {
	            peer = call.peer;
	        }

	        self.setRemoteDescription(call, peer, CONSTANTS.WEBRTC.RTC_SDP_TYPE.OFFER, call.sdp, function processUpdateSetRemoteDescriptionSuccessCallback() {
	            logger.debug("processUpdate: setRemoteDescription success");
	            call.remoteVideoState = _sdpParser.getVideoSdpDirection(call.sdp);

	            peer.createAnswer(function processUpdateCreateAnswerSuccessCallback(obj) {
	                if (_sdpParser.isSdpVideoSendEnabled(call.sdp)) {
	                    if (self.canOriginatorSendLocalVideo(call)) {
	                        obj.sdp = _sdpParser.updateVideoSdpDirection(obj.sdp, CONSTANTS.WEBRTC.MEDIA_STATE.SEND_RECEIVE);
	                    } else {
	                        obj.sdp = _sdpParser.updateVideoSdpDirection(obj.sdp, CONSTANTS.WEBRTC.MEDIA_STATE.RECEIVE_ONLY);
	                    }
	                } else {
	                    if (self.canOriginatorSendLocalVideo(call) && !_sdpParser.isVideoSdpDirectionInactive(call.sdp)) {
	                        obj.sdp = _sdpParser.updateVideoSdpDirection(obj.sdp, CONSTANTS.WEBRTC.MEDIA_STATE.SEND_ONLY);
	                    } else {
	                        obj.sdp = _sdpParser.updateVideoSdpDirection(obj.sdp, CONSTANTS.WEBRTC.MEDIA_STATE.INACTIVE);
	                    }
	                }

	                obj.sdp = _sdpParser.updateVersion(peerLocalSdp, obj.sdp);
	                obj.sdp = _sdpParser.checkIceParamsLengths(obj.sdp, call.sdp);
	                obj.sdp = _sdpParser.setTcpSetupAttributeTo(obj.sdp, call.localTcpSetupAttribute, self.isDtlsEnabled());

	                localDescObj = self.getRtcLibrary().createRTCSessionDescription(CONSTANTS.WEBRTC.RTC_SDP_TYPE.ANSWER, obj.sdp);
	                peer.setLocalDescription(localDescObj, function processUpdateSetLocalDescriptionSuccessCallback() {
	                    //since the candidates have changed we will call the successCallback at onIceCandidate
	                    //_utils.callFunctionIfExist(successCallback);
	                    logger.debug("processUpdate: setlocalDescription success");
	                }, function processUpdateSetLocalDescriptionSuccessCallback(e) {
	                    logger.debug("processUpdate: setlocalDescription failed!!" + e);
	                    _utils.callFunctionIfExist(failureCallback, "processUpdate: setlocalDescription failed!!");
	                });
	            }, function processUpdateCreateAnswerFailureCallback(e) {
	                logger.debug("processUpdate: createAnswer failed!! " + e);
	                _utils.callFunctionIfExist(failureCallback, "Session cannot be created");
	            }, self.getRtcLibrary().createConstraints(self.getMediaAudio(), self.getMediaVideo()));
	        }, function processUpdateSetRemoteDescriptionSuccessCallback(e) {
	            logger.debug("processUpdate: setRemoteDescription failed!!" + e);
	            _utils.callFunctionIfExist(failureCallback, "processUpdate: setRemoteDescription failed!!");
	        });
	    };

	    // firefoxProcessRespond
	    self.processRespond = function(call, onSuccess, onFail, isJoin) {
	        var peer = call.peer;
	        logger.debug("processRespond: state= " + call.peer.signalingState);

	        if (call.peer.signalingState === CONSTANTS.WEBRTC.RTC_SIGNALING_STATE.STABLE) {
	            //if we are in stable state we should not change remotedescription
	            self.setRemoteDescription(call, null, null, call.sdp, onSuccess, onFail);
	            return;
	        }

	        call.sdp = _sdpParser.checkSupportedVideoCodecs(call.sdp, call.stableLocalSdp, self.isH264Enabled());

	        if (isJoin) {
	            call.sdp = _sdpParser.changeDirection(call.sdp, CONSTANTS.WEBRTC.MEDIA_STATE.RECEIVE_ONLY, CONSTANTS.WEBRTC.MEDIA_STATE.SEND_RECEIVE, CONSTANTS.STRING.AUDIO);
	            self.muteOnHold(call, false);
	        }

	        self.setRemoteDescription(call, peer, CONSTANTS.WEBRTC.RTC_SDP_TYPE.ANSWER, call.sdp, function processRespondSetRemoteDescriptionSuccessCallback() {
	            logger.debug("processRespond: setRemoteDescription success");
	            call.remoteVideoState = _sdpParser.getVideoSdpDirection(call.sdp);
	            _utils.callFunctionIfExist(onSuccess);
	        }, function processRespondSetRemoteDescriptionSuccessCallback(e) {
	            logger.debug("processRespond: setRemoteDescription failed: " + e);
	            _utils.callFunctionIfExist(onFail);
	        });
	    };

	    // firefoxSendDTMF
	    self.sendDTMF = function(call, tone) {
	        var audioContext;

	        audioContext = call.localMedia.audioContext;
	        if (audioContext.createOscillator) {
	            self.sendInbandDTMF(call, tone, audioContext);
	        } else {
	            logger.debug("DMTF IS NOT SUPPORTED FOR VIDEO CALL ON FIREFOX");
	        }
	    };

	    // firefoxIceCandidateCollectionTimeoutHandler
	    self.iceCandidateCollectionTimeoutHandler = function(call) {
	        var sdp = call.peer.localDescription.sdp;
	        self.clearIceCandidateCollectionTimer(call);
	        if (fcsConfig.relayCandidateCollectionTimeoutCycle) {
	            call.relayCandidateCycle++;
	        }
	        sdp = _sdpParser.findZeroConnectionIPandModify(sdp);

	        // set timeout if there is no ice candidate available or
	        // when audio, video port assignment isn't complete
	        if (!_sdpParser.hasCandidates(sdp, call.relayCandidateCycle, fcsConfig.relayCandidateCollectionTimeoutCycle)) {
	            logger.debug("Re-setting ice candidate collection timeout: " + fcsConfig.iceCandidateCollectionTimeoutInterval);
	            call.iceCandidateCollectionTimer = setTimeout(function() {
	                self.iceCandidateCollectionTimeoutHandler(call);
	            }, fcsConfig.iceCandidateCollectionTimeoutInterval);
	            return;
	        }

	        if (call.successCallback) {
	            logger.debug("Ice candidate collection interrupted after given timeout, invoking successCallback.");
	            sdp = _sdpParser.deleteCurlyBracketsSDP(sdp);
	            if (!self.isH264Enabled()) {
	                sdp = _sdpParser.removeH264Codec(sdp);
	            }
	            if (!_sdpParser.isSdpHasUfrag(sdp)) {
	                sdp = _sdpParser.checkAndRestoreICEParams(sdp, call.stableLocalSdp);
	                logger.debug("Absent ufrag due to inactive video direction is restored from that in stable local sdp");
	            }
	            call.successCallback(sdp);
	        }
	    };

	    // firefoxSetupIceCandidateCollectionTimer
	    self.setupIceCandidateCollectionTimer = function(call) {
	        if (fcsConfig.iceCandidateCollectionTimeoutInterval) {
	            if (!call.iceCandidateCollectionTimer) {
	                logger.debug("Setting ice candidate collection timeout: " + fcsConfig.iceCandidateCollectionTimeoutInterval);
	                if (fcsConfig.relayCandidateCollectionTimeoutCycle) {
	                    call.relayCandidateCycle = 1;
	                }
	                call.iceCandidateCollectionTimer = setTimeout(function() {
	                    self.iceCandidateCollectionTimeoutHandler(call);
	                }, fcsConfig.iceCandidateCollectionTimeoutInterval);
	            } else {
	                logger.trace("Ice candidate collection timer exists.");
	            }
	        }
	    };

	    // firefoxOnIceCandidate
	    self.onIceCandidate = function(call, event) {
	        var sdp;
	        if (event.candidate === null) {
	            logger.debug("Null candidate received.");
	            if (call.successCallback) {
	                sdp = call.peer.localDescription.sdp;
	                self.clearIceCandidateCollectionTimer(call);
	                logger.debug("Candidates received, invoking successCallback.");

	                sdp = _sdpParser.deleteCurlyBracketsSDP(sdp);
	                if (!self.isH264Enabled()) {
	                    sdp = _sdpParser.removeH264Codec(sdp);
	                }
	                if (!_sdpParser.isSdpHasUfrag(sdp)) {
	                    sdp = _sdpParser.checkAndRestoreICEParams(sdp, call.stableLocalSdp);
	                    logger.debug("Absent ufrag due to inactive video direction is restored from that in stable local sdp");
	                }
	                call.successCallback(sdp);
	            }
	        } else {
	            logger.debug("ICE candidate received: sdpMLineIndex = " + event.candidate.sdpMLineIndex +
	                ", candidate = " + event.candidate.candidate + " for call : " + call.id);
	        }
	    };

	    // firefoxOnIceComplete
	    self.onIceComplete = function(call) {
	        var sdp;
	        logger.debug("All ICE candidates received for call : " + call.id);
	        self.clearIceCandidateCollectionTimer(call);

	        if (call.successCallback) {
	            sdp = call.peer.localDescription.sdp;
	            sdp = _sdpParser.deleteCurlyBracketsSDP(sdp);
	            if (!self.isH264Enabled()) {
	                sdp = _sdpParser.removeH264Codec(sdp);
	            }
	            if (!_sdpParser.isSdpHasUfrag(sdp)) {
	                sdp = _sdpParser.checkAndRestoreICEParams(sdp, call.stableLocalSdp);
	                logger.debug("Absent ufrag due to inactive video direction is restored from that in stable local sdp");
	            }

	            logger.debug("onIceComplete sdp : " + sdp);

	            call.successCallback(sdp);
	        }
	    };

	    self.createDataChannel = function(dataChannelWrapperObj, onSuccess, onFailure, options) {
	        try {
	            dataChannelWrapperObj.dataChannel = dataChannelWrapperObj.peer.createDataChannel(options);
	            onSuccess(dataChannelWrapperObj);
	        } catch (error) {
	            logger.error("Failed to create data channel, exception: " + error.message);
	            onFailure(error);
	        }
	    };

	    // firefoxCreateNewPeerForCall
	    self.createNewPeerForCall = function(data) {
	        var call = data.call,
	            mustCreatePeer = data.mustCreatePeer,
	            isNewPeerCreated = false,
	            oldPeer,
	            videoTrack;

	        if (mustCreatePeer) {
	            if (call.peer) {
	                oldPeer = call.peer;
	                self.collectWebRtcStats(oldPeer,
	                    function (stats) {
	                        logger.debug("collectWebRtcStats successfull mozilla");
	                        if (call.stats === undefined) {
	                            call.stats = [];
	                        }
	                        call.stats.push(stats);
	                        if (oldPeer.signalingState !== "closed") {
	                            oldPeer.close();
	                        }
	                        self.setPeerCount(self.getPeerCount() - 1);
	                        call.dtmfSender = null;
	                    },
	                    function () {
	                        logger.debug("collectWebRtcStats failed mozilla");
	                        if (oldPeer.signalingState !== "closed") {
	                            oldPeer.close();
	                        }
	                        self.setPeerCount(self.getPeerCount() - 1);
	                        call.dtmfSender = null;
	                    });
	            }

	            logger.trace("Creating new peer for call: " + call.id);
	            self.createPeer(call, data.useIceServer, function createPeerSuccessCallback() {
	                logger.trace("New peer has created for call: " + call.id);
	                if (data.deleteVideoStream) {
	                    videoTrack = call.localMedia.stream.getVideoTracks()[0];
	                    call.localMedia.stream.removeTrack(videoTrack);
	                }
	                call.peer.addStream(call.localMedia.stream);
	                isNewPeerCreated = true;
	            }, function createPeerFailureCallback() {
	                logger.error("New peer creation has failed!: " + call.id);
	                if (call.stats) {
	                    call.stats.pop();
	                }
	            });
	        }
	        return isNewPeerCreated;
	    };

	    // firefoxCreatePeer
	    self.createPeer = function(call, useIceServer, onSuccess, onFailure) {
	        try {
	            var pc, constraints, i, servers = [],
	                iceServerUrl, stunturn, serverType;

	            logger.info('useIceServer: ' + useIceServer);
	            if (useIceServer) {
	                iceServerUrl = self.getIceServerUrl();
	            }

	            if (iceServerUrl instanceof Array) {
	                for (i = 0; i < iceServerUrl.length; i++) {
	                    iceServerUrl[i].url = iceServerUrl[i].url.replace('turns', 'turn');
	                    servers[i] = iceServerUrl[i];
	                }
	            } else if (!iceServerUrl || iceServerUrl === "") {
	                servers = [];
	            } else {
	                servers[0] = iceServerUrl;
	            }
	            stunturn = {
	                iceServers: servers
	            };

	            constraints = {
	                "optional": [{
	                    "DtlsSrtpKeyAgreement": self.isDtlsEnabled()
	                }]
	            };
	            pc = self.getRtcLibrary().createRTCPeerConnection(stunturn, constraints);

	            self.setPeerCount(self.getPeerCount() + 1);
	            call.peer = pc;

	            pc.onconnecting = function(event) {
	                self.onSessionConnecting(call, event);
	            };
	            pc.onopen = function(event) {
	                self.onSessionOpened(call, event);
	            };
	            pc.onsignalingstatechange = function(event) {
	                self.onSignalingStateChange(call, event);
	            };
	            pc.onaddstream = function(event) {
	                self.onRemoteStreamAdded(call, event);
	            };
	            pc.onremovestream = function(event) {
	                self.onRemoteStreamRemoved(call, event);
	            };
	            pc.onicecandidate = function(event) {
	                if (event.currentTarget.iceGatheringState === "complete") {
	                    logger.debug("ice gathering complete");
	                    self.onIceComplete(call);
	                } else {
	                    self.setupIceCandidateCollectionTimer(call);
	                    self.onIceCandidate(call, event);
	                }
	            };
	            pc.onicecomplete = function() {
	                self.onIceComplete(call);
	            };
	            pc.oniceconnectionstatechange = function(event) {
	                self.oniceconnectionstatechange(call, event);
	            };
	            pc.ondatachannel = function(event) {
	                self.onDataChannel(call, event);
	            };
	            logger.info("create PeerConnection successfully.");

	            // Will be commented-in after decision of necessary stats
	            // self.setupWebrtcLogCollectionTimer(call);

	            onSuccess(call);
	        } catch (err) {
	            logger.error("Failed to create PeerConnection, exception: " + err.message);
	            onFailure();
	        }
	    };

	    // firefoxgetCameraList
	    self.getCameraList = function() {
	        return;
	    };

	    // firefoxgetMicrophoneList
	    self.getMicrophoneList = function() {
	        return;
	    };

	    // firefoxgetSpeakerList
	    self.getSpeakerList = function() {
	        return;
	    };

	    self.getNativeWebRtcStats = function(call, onSuccess, onFailure) {
	        try {
	            if (call) {
	                logger.debug("getNativeWebRtcStats called mozilla");
	                call.peer.getStats(undefined, function(stats) {
	                        if (stats !== undefined && stats !== null) {
	                            _utils.callFunctionIfExist(onSuccess, stats);
	                        }
	                    },
	                    self.statsCallback);
	            }
	        } catch (err) {
	            logger.error("Failed to get all WebRTC Statistics: " + err.message);
	            _utils.callFunctionIfExist(onFailure, err);
	        }
	    };

	    self.statsCallback = function(error) {
	        logger.debug('Mozilla statsCallback:' + error);
	    };

	    self.getWebRtcStats = function(call, onSuccess, onFailure) {
	        try {
	            if (call) {
	                logger.debug("getWebRtcStats called mozilla");
	                self.collectWebRtcStats(call.peer,
	                    function(stats) {
	                        var accumulatedStats = self.getAccumulatedWebRtcStats(call.stats, stats);
	                        _utils.callFunctionIfExist(onSuccess, accumulatedStats);
	                    },
	                    onFailure);
	            }
	        } catch (err) {
	            logger.error("Failed to get WebRTC Statistics: " + err.message);
	            _utils.callFunctionIfExist(onFailure, err);
	        }
	        return self.getStats();
	    };

	    self.getAccumulatedWebRtcStats = function(statsList, currentStats) {
	        var i, accumulatedStats = {
	            audio: {
	                packetsSent: 0,
	                bytesSent: 0,
	                bytesReceived: 0,
	                peerAddress: null,
	                codec: null,
	                packetsLost: 0,
	                jitter: null,
	                rtt: null
	            },
	            video: {
	                packetsSent: 0,
	                bytesSent: 0,
	                bytesReceived: 0,
	                peerAddress: null,
	                codec: null,
	                packetsLost: 0,
	                rtt: null
	            }
	        };
	        if (statsList !== undefined) {
	            for (i = 0; i < statsList.length; i++) {
	                self.accumulateStats(accumulatedStats.audio, statsList[i].audio);
	                self.accumulateStats(accumulatedStats.video, statsList[i].video);
	            }
	        }

	        self.accumulateStats(accumulatedStats.audio, currentStats.audio);
	        accumulatedStats.audio.peerAddress = currentStats.audio.peerAddress;
	        accumulatedStats.audio.codec = currentStats.audio.codec;
	        accumulatedStats.audio.jitter = currentStats.audio.jitter;
	        accumulatedStats.audio.rtt = currentStats.audio.rtt;

	        self.accumulateStats(accumulatedStats.video, currentStats.video);
	        accumulatedStats.video.peerAddress = currentStats.video.peerAddress;
	        accumulatedStats.video.codec = currentStats.video.codec;
	        accumulatedStats.video.rtt = currentStats.video.rtt;

	        return accumulatedStats;
	    };

	    self.accumulateStats = function(accumulatedStatsObj, statsObj) {
	        accumulatedStatsObj.packetsSent += _utils.getInteger(statsObj.packetsSent);
	        accumulatedStatsObj.bytesSent += _utils.getInteger(statsObj.bytesSent);
	        accumulatedStatsObj.bytesReceived += _utils.getInteger(statsObj.bytesReceived);
	        accumulatedStatsObj.packetsLost += _utils.getInteger(statsObj.packetsLost) === -1 ? 0 : _utils.getInteger(statsObj.packetsLost);
	    };

	    self.collectWebRtcStats = function(peer, onSuccess, onFailure) {
	        try {
	            if (peer) {
	                logger.debug("collectWebRtcStats called mozilla");
	                peer.getStats(undefined, function(stats) {
	                        if (stats !== undefined && stats !== null) {
	                            self.setWebRtcStats(stats);
	                            _utils.callFunctionIfExist(onSuccess, self.getStats());
	                        }
	                    },
	                    self.statsCallback);
	            }
	        } catch (err) {
	            logger.error("Failed to collectWebRtcStats: " + err.message);
	            _utils.callFunctionIfExist(onFailure, err);
	        }
	        return self.getStats();
	    };

	    self.setWebRtcStats = function(results) {
	        var stats = {
	            audio: {
	                packetsSent: null,
	                bytesSent: null,
	                bytesReceived: null,
	                peerAddress: null,
	                codec: null,
	                packetsLost: null,
	                jitter: null,
	                rtt: null
	            },
	            video: {
	                packetsSent: null,
	                bytesSent: null,
	                bytesReceived: null,
	                peerAddress: null,
	                codec: null,
	                packetsLost: null,
	                rtt: null
	            }
	        };

	        results.forEach(function(result) {
	            if (result.type === "remotecandidate") {
	                if (result.componentId !== undefined) {
	                    if (result.componentId.indexOf("aLevel=0") > -1) {
	                        stats.audio.peerAddress = result.ipAddress + ':' + result.portNumber;
	                    } else if (result.componentId.indexOf("aLevel=1") > -1) {
	                        stats.video.peerAddress = result.ipAddress + ':' + result.portNumber;
	                    }
	                }
	            }
	        });

	        if(stats.video.peerAddress === undefined || stats.video.peerAddress === null  ){
	            stats.video.peerAddress = stats.audio.peerAddress;
	        }

	        //audio
	        if (results.inbound_rtp_audio_0 !== undefined) {
	            stats.audio.bytesReceived = results.inbound_rtp_audio_0.bytesReceived;
	            stats.audio.packetsLost = results.inbound_rtp_audio_0.packetsLost;
	            stats.audio.jitter = results.inbound_rtp_audio_0.jitter;
	        }
	        if (results.outbound_rtp_audio_0 !== undefined) {
	            stats.audio.packetsSent = results.outbound_rtp_audio_0.packetsSent;
	            stats.audio.bytesSent = results.outbound_rtp_audio_0.bytesSent;
	        }
	        if (results.outbound_rtcp_audio_0 !== undefined) {
	            stats.audio.rtt = results.outbound_rtcp_audio_0.mozRtt;
	        }

	        if (results.inbound_rtp_video_1 !== undefined) {
	            stats.video.bytesReceived = results.inbound_rtp_video_1.bytesReceived;
	            stats.video.packetsLost = results.inbound_rtp_video_1.packetsLost;
	        }

	        if (results.outbound_rtp_video_1 !== undefined) {
	            stats.video.packetsSent = results.outbound_rtp_video_1.packetsSent;
	            stats.video.bytesSent = results.outbound_rtp_video_1.bytesSent;
	        }
	        if (results.outbound_rtcp_video_1 !== undefined) {
	            stats.video.rtt = results.outbound_rtcp_video_1.mozRtt;
	        }

	        self.setStats(stats);
	    };

	    logger.debug('WebRtcFirefoxAdaptor initialized');
	};

	//@{fcs-jsl-prod}
	var WebRtcFirefoxAdaptor = function(_super, _decorator, _model) {
	    var decorator = _decorator || webRtcLibraryFirefoxDecorator,
	        model = _model || new WebRtcFirefoxAdaptorModel();
	    return new WebRtcFirefoxAdaptorImpl(_super ||
	        new WebRtcAdaptor({}, decorator, model),
	        decorator,
	        model,
	        logManager,
	        utils,
	        sdpParser,
	        fcs.call.MediaErrors);
	};
	//@{fcs-jsl-prod}


	var WebRtcFirefoxEsrAdaptorImpl = function(_super, _decorator, _model, _logManager) {
	    var self = this,
	        logger = _logManager.getLogger("WebRtcFirefoxEsrAdaptorImpl");
	    logger.debug('WebRtcFirefoxEsrAdaptor initializing');

	    utils.compose(_super, self);
	    utils.compose(_model, self);

	    // firefoxEsrGetUserMedia
	    self.getUserMedia = function(params) {
	        self.getRtcLibrary().checkMediaSourceAvailability(function mediaSourceCallback(mediaSourceInfo) {
	            var mediaInfo, constraints = {
	                    audio: false,
	                    video: false
	                },
	                localMedia;
	            self.setMediaSources(mediaSourceInfo);

	            if (mediaSourceInfo) {
	                if (!mediaSourceInfo.audioSourceAvailable) {
	                    logger.debug("Failed to get access to local media.");
	                    utils.callFunctionIfExist(params.onFailure, fcs.call.MediaErrors.NOT_FOUND);
	                    return;
	                }
	            }

	            if (self.getMediaVideo() && self.getVideoSourceAvailable()) {
	                constraints.video = params.options.videoConstraints;
	            }
	            if (self.getMediaAudio() && self.getAudioSourceAvailable()) {
	                constraints.audio = params.options.audioConstraints;
	            }

	            logger.debug("getUserMedia - constraints: ", constraints);
	            self.getRtcLibrary().getUserMedia(constraints, function getUserMediaSuccessCallback(stream) {

	                localMedia = {
	                    audioContext: {
	                        close: function() {}
	                    },
	                    mediaStreamDestination: {
	                        disconnect: function() {}
	                    },
	                    stream: stream,
	                    originalStream: stream
	                };

	                self.setLocalMedia(localMedia);
	                self.getLocalStreamMap().add(localMedia.stream.id, localMedia);
	                self.setInitialized(true);

	                mediaInfo = {
	                    audio: self.getMediaAudio(),
	                    video: self.getMediaVideo(),
	                    id: localMedia.stream.id,
	                    originalStream: stream,
	                    streamURL: self.getRtcLibrary().getURLFromStream(stream)
	                };

	                logger.debug("user has granted access to local media: ", localMedia);
	                utils.callFunctionIfExist(params.onSuccess, mediaInfo);
	            }, function getUserMediaFailureCallback(error) {
	                logger.debug("Failed to get access to local media. Error code was " + error.code);
	                utils.callFunctionIfExist(params.onFailure, fcs.call.MediaErrors.NOT_ALLOWED);
	            });
	        });
	    };


	    // firefoxEsrSendDTMF
	    self.sendDTMF = function(call, tone) {
	        logger.debug("DMTF IS ONLY SUPPORTED FOR  FIREFOX 40 AND NEWER VERSIONS");
	    };

	    logger.debug('WebRtcFirefoxEsrAdaptor initialized');
	};

	//@{fcs-jsl-prod}
	var WebRtcFirefoxEsrAdaptor = function(_super, _decorator, _model) {
	    var decorator = _decorator || webRtcLibraryFirefoxDecorator,
	        model = _model || new WebRtcFirefoxAdaptorModel();
	    return new WebRtcFirefoxEsrAdaptorImpl(_super ||
	        new WebRtcFirefoxAdaptor(null, decorator, model),
	        decorator,
	        model,
	        logManager);
	};
	//@{fcs-jsl-prod}


	var WebRtcAdaptorFactory = function(_window, _navigator, _logManager, _WebRtcPluginv22Adaptor, _WebRtcPluginv31Adaptor, _WebRtcChromeAdaptor, _WebRtcFirefoxAdaptor, _WebRtcFirefoxEsrAdaptor) {
	    var logger = _logManager.getLogger("WebRtcAdaptorFactory"),
	        NAVIGATOR_TYPES = {
	            CHROME: "chrome",
	            FIREFOX: "firefox",
	            "PLUGIN": "plugin"
	        },
	        PLUGIN_MODES = {
	            // 3.0 Enabler Plugin
	            WEBRTCH264: "webrtch264",
	            // 2.2 Enabler Plugin
	            WEBRTC22: "webrtc22",
	            // Default Enabler Plugin
	            WEBRTC: "webrtc",
	            // Native For Chrome Browser and Default Enabler Plugin for other Browsers
	            AUTO: "auto",
	            // Native For Chrome Browser and Default Enabler Plugin for other Browsers
	            AUTO22: "auto22",
	            // Native For Chrome Browser and 3.0 Enabler Plugin for other Browsers
	            AUTOH264: "autoh264",
	            // Native For Chrome AND Firefox Browser and Enabler Plugin for other Browsers
	            AUTOFIREFOX: "autofirefox"
	        },
	        DEFAULT_RTC_PLUGIN_MODE = PLUGIN_MODES.WEBRTCH264,
	        DEFAULT_RTC_ADAPTOR = _WebRtcPluginv31Adaptor,
	        PLUGIN_MODE_LOOKUP_TABLE = {
	            chrome: {
	                webrtc: DEFAULT_RTC_PLUGIN_MODE,
	                autofirefox: PLUGIN_MODES.AUTO,
	                autoh264: PLUGIN_MODES.AUTO,
	                webrtch264: PLUGIN_MODES.WEBRTCH264
	            },
	            firefox: {
	                webrtc: DEFAULT_RTC_PLUGIN_MODE,
	                auto: DEFAULT_RTC_PLUGIN_MODE,
	                auto22: PLUGIN_MODES.WEBRTC22,
	                autoh264: PLUGIN_MODES.WEBRTCH264,
	                autofirefox: PLUGIN_MODES.AUTO
	            },
	            plugin: {
	                auto: DEFAULT_RTC_PLUGIN_MODE,
	                auto22: PLUGIN_MODES.WEBRTC22,
	                autoh264: PLUGIN_MODES.WEBRTCH264,
	                autofirefox: DEFAULT_RTC_PLUGIN_MODE,
	                webrtc: DEFAULT_RTC_PLUGIN_MODE
	            }
	        },
	        ADAPTOR_LOOKUP_TABLE = {
	            chrome: {
	                auto: _WebRtcChromeAdaptor,
	                autoh264: _WebRtcChromeAdaptor,
	                webrtc22: _WebRtcPluginv22Adaptor,
	                webrtch264: _WebRtcPluginv31Adaptor
	            },
	            firefox: {
	                auto: _WebRtcFirefoxAdaptor,
	                autoesr: _WebRtcFirefoxEsrAdaptor,
	                webrtc22: _WebRtcPluginv22Adaptor,
	                webrtch264: _WebRtcPluginv31Adaptor
	            },
	            plugin: {
	                webrtc22: _WebRtcPluginv22Adaptor,
	                webrtch264: _WebRtcPluginv31Adaptor
	            }
	        },
	        COMPOSIT_PLUGIN_MODES = {
	            // Default Enabler Plugin
	            WEBRTC: "webrtc",
	            // Native For Chrome And Firefox Browser and Default Enabler Plugin for other Browsers
	            AUTO: "auto"
	        },
	        COMPOSIT_ADAPTOR_LOOKUP_TABLE = {
	            chrome: {
	                auto: _WebRtcChromeAdaptor,
	                webrtc: DEFAULT_RTC_ADAPTOR
	            },
	            firefox: {
	                auto: _WebRtcFirefoxAdaptor,
	                autoesr: _WebRtcFirefoxEsrAdaptor,
	                webrtc: DEFAULT_RTC_ADAPTOR
	            },
	            plugin: {
	                auto: DEFAULT_RTC_ADAPTOR,
	                webrtc: DEFAULT_RTC_ADAPTOR
	            }
	        },
	        pluginMode;

	    function getNavigatorType() {
	        var type, version, regex;
	        if (_navigator.userAgent && _navigator.userAgent.indexOf("GENBANDOmni") !== -1) {
	            type = NAVIGATOR_TYPES.CHROME;
	        } else if (_navigator.webkitGetUserMedia) {
	            type = NAVIGATOR_TYPES.CHROME;
	            regex = new RegExp(/\Chrome\/(\d*)/);
	        } else if (_navigator.mozGetUserMedia || (_navigator.mediaDevices && _navigator.mediaDevices.getUserMedia)) {
	            type = NAVIGATOR_TYPES.FIREFOX;
	            regex = new RegExp(/\Firefox\/(\d*)/);
	        } else {
	            type = NAVIGATOR_TYPES.PLUGIN;
	        }
	        if (regex && _navigator.userAgent) {
	            version = parseInt(_navigator.userAgent.match(regex).pop(), 10);
	        }
	        return {
	            type: type,
	            version: version
	        };
	    }

	    function identifyPluginMode(options) {
	        var i;

	        if (!options || !options.pluginMode) {
	            return PLUGIN_MODES.AUTO;
	        }

	        for (i in PLUGIN_MODES) {
	            if (PLUGIN_MODES[i] === options.pluginMode) {
	                return PLUGIN_MODES[i];
	            }
	        }

	        return PLUGIN_MODES.AUTO;
	    }

	    function getPluginModeForComposition(navigatorType) {
	        var pluginMode = PLUGIN_MODES.AUTO,
	            validPluginMode = false,
	            h264Enabled,
	            pluginModeBrowser = fcsConfig.pluginMode[navigatorType.type],
	            pluginModeBrowserVersion,
	            browserVersion, i, regex;

	        if (pluginModeBrowser) {
	            regex = new RegExp(/^\d+\+$/);
	            if (pluginModeBrowser.version && regex.test(pluginModeBrowser.version)) {
	                pluginModeBrowserVersion = parseInt(pluginModeBrowser.version.replace(/\+/, ''), 10);
	            }
	            browserVersion = navigatorType.version;
	            if (pluginModeBrowser.mode && (!pluginModeBrowserVersion || browserVersion >= pluginModeBrowserVersion)) {
	                pluginMode = pluginModeBrowser.mode;
	            } else if (fcsConfig.pluginMode.mode) {
	                pluginMode = fcsConfig.pluginMode.mode;
	            }

	            if (typeof pluginModeBrowser.h264 !== 'undefined' && (!pluginModeBrowserVersion || browserVersion >= pluginModeBrowserVersion)) {
	                h264Enabled = pluginModeBrowser.h264;
	            } else {
	                h264Enabled = fcsConfig.pluginMode.h264;
	            }
	        } else {
	            pluginMode = fcsConfig.pluginMode.mode;
	            h264Enabled = fcsConfig.pluginMode.h264;
	        }

	        // plugin mode validity check
	        for (i in COMPOSIT_PLUGIN_MODES) {
	            if (COMPOSIT_PLUGIN_MODES[i] === pluginMode) {
	                validPluginMode = true;
	            }
	        }
	        if (!validPluginMode) {
	            pluginMode = PLUGIN_MODES.AUTO;
	        }

	        // h264 validity check
	        if (h264Enabled !== true && h264Enabled !== false) {
	            h264Enabled = undefined;
	        }

	        return {
	            pluginMode: pluginMode,
	            h264Enabled: h264Enabled
	        };
	    }

	    function getPluginMode(options, navigatorType) {
	        var pluginMode = identifyPluginMode(options);

	        return PLUGIN_MODE_LOOKUP_TABLE[navigatorType.type][pluginMode] || pluginMode;
	    }

	    this.getWebRtcAdaptor = function(options) {
	        var Adaptor, navigatorType = getNavigatorType(),
	            adaptor, pluginModeAndH264Bundle, h264Enabled;

	        if (fcsConfig.pluginMode) {
	            pluginModeAndH264Bundle = getPluginModeForComposition(navigatorType);
	            pluginMode = pluginModeAndH264Bundle.pluginMode;
	            h264Enabled = pluginModeAndH264Bundle.h264Enabled;
	            if (pluginMode === "auto" && navigatorType.type === "firefox" && navigatorType.version < 40) {
	                pluginMode = "autoesr";
	            }
	            Adaptor = COMPOSIT_ADAPTOR_LOOKUP_TABLE[navigatorType.type][pluginMode];
	        } else {
	            pluginMode = getPluginMode(options, navigatorType);
	            if (pluginMode === "auto" && navigatorType.type === "firefox" && navigatorType.version < 40) {
	                pluginMode = "autoesr";
	            }
	            Adaptor = ADAPTOR_LOOKUP_TABLE[navigatorType.type][pluginMode];
	        }

	        if (!Adaptor) {
	            // This seems unnecessary, still keeping it just in case of a weird
	            // condition
	            logger.debug("Invalid Plugin Mode Detected, Treated as WEBRTC");
	            pluginMode = DEFAULT_RTC_PLUGIN_MODE;
	            Adaptor = DEFAULT_RTC_ADAPTOR;
	        }

	        logger.debug("Adaptor initializing from " + navigatorType + " browser and " + pluginMode + " plugIn mode");
	        _window.pluginMode = pluginMode;
	        adaptor = new Adaptor();
	        //TODO: set h264Enabled for adaptor
	        if (typeof h264Enabled !== 'undefined') {
	            adaptor.setH264Enabled(h264Enabled);
	        }
	        return adaptor;
	    };

	    this.getPluginModes = function() {
	        return PLUGIN_MODES;
	    };

	    this.getDefaultRtcPluginMode = function() {
	        return DEFAULT_RTC_PLUGIN_MODE;
	    };

	    this.getDefaultRtcAdaptor = function() {
	        return DEFAULT_RTC_ADAPTOR;
	    };

	    
	};

	//@{fcs-jsl-prod}
	var webRtcAdaptorFactory = new WebRtcAdaptorFactory(window,
	    navigator,
	    logManager,
	    WebRtcPluginv22Adaptor,
	    WebRtcPluginv31Adaptor,
	    WebRtcChromeAdaptor,
	    WebRtcFirefoxAdaptor,
	    WebRtcFirefoxEsrAdaptor);
	//@{fcs-jsl-prod}


	var WebRtcManager = function(_webRtcAdaptorFactory, _logManager, _turnCredentialsManager, _navigator, _utils, _fcs, _globalBroadcaster) {
	    var self = this,
	        rtcAdaptor,
	        logger = _logManager.getLogger("WebRtcManager");

	    function setSuccessCallbacktoCall(call, successCallback) {
	        call.successCallback = successCallback;
	    }

	    function clearSuccessParametersFromCall(call) {
	        call.successCallback = null;
	    }

	    function isRemoteEndFirefox(pSdp) {
	        if (!pSdp) {
	            return false;
	        }
	        return pSdp.indexOf("SDPARTA") !== -1;
	    }

	    self.onCredentialsReceived = function() {
	        if (rtcAdaptor) {
	            rtcAdaptor.setIceServerUrl(self.addTurnCredentialsToUrl());
	        }
	    };

	    _turnCredentialsManager.onCredentialsReceived = self.onCredentialsReceived;

	    self.addTurnCredentialsToUrl = function() {
	        var i, serverType,
	            iceServerUrl = rtcAdaptor.getIceServerUrl(),
	            turnCredentials = _turnCredentialsManager.get();
	        if (turnCredentials) {
	            logger.info("Turn credentials are avaliable.");
	            if (iceServerUrl instanceof Array) {
	                for (i = 0; i < iceServerUrl.length; i++) {
	                    serverType = iceServerUrl[i].url.substring(0, iceServerUrl[i].url.indexOf(':'));
	                    if (serverType === 'turn' || serverType === 'turns') {
	                        iceServerUrl[i].credential = turnCredentials.credential;
	                        iceServerUrl[i].username = turnCredentials.username;
	                    }
	                }
	            }
	        }
	        return iceServerUrl;
	    };

	    self.canOriginatorSendLocalVideo = function(call) {
	        return rtcAdaptor.canOriginatorSendLocalVideo(call);
	    };

	    self.canOriginatorReceiveRemoteVideo = function(call) {
	        return rtcAdaptor.canOriginatorReceiveRemoteVideo(call);
	    };

	    self.onFcsSetupCompleted = function(fcsConfig) {
	        self.initMedia(null, null, fcsConfig);
	    };

	    self.initMedia = function(onSuccess, onFailure, options) {
	        logger.info("Initializing media for call");

	        if (!rtcAdaptor) {
	            rtcAdaptor = _webRtcAdaptorFactory.getWebRtcAdaptor(options);
	        }

	        if (options) {
	            if (options.iceserver) {
	                // Adding raw iceserver config to adaptor
	                // to make addTurnCredentialsToUrl method work properly
	                rtcAdaptor.setIceServerUrl(options.iceserver);
	                rtcAdaptor.setIceServerUrl(self.addTurnCredentialsToUrl(options.iceserver));
	            }
	            if (options.webrtcdtls) {
	                rtcAdaptor.setDtlsEnabled(options.webrtcdtls);
	            }

	            if (options.localVideoContainer) {
	                rtcAdaptor.setLocalVideoContainer(options.localVideoContainer);
	            }

	            if (options.remoteVideoContainer) {
	                rtcAdaptor.setRemoteVideoContainer(options.remoteVideoContainer);
	            }

	            if (options.videoContainer) {
	                rtcAdaptor.setDefaultVideoContainer(options.videoContainer);
	            }
	        }

	        if (rtcAdaptor.isInitialized()) {
	            _utils.callFunctionIfExist(onSuccess);
	        } else {
	            rtcAdaptor.initMedia(onSuccess, onFailure, options);
	        }
	    };

	    self.privateGetUserMedia = function(onSuccess, onFailure, options) {
	        var returnParams = {
	            onSuccess: onSuccess,
	            onFailure: onFailure,
	            options: {
	                audioConstraints: options.audio,
	                videoConstraints: options.video,
	                privateStream: options.privateStream
	            }
	        };

	        if (!options.audio && !options.video) {
	            _utils.callFunctionIfExist(onFailure, _fcs.call.MediaErrors.INVALID_PARAMETER);
	            return;
	        }
	        rtcAdaptor.privateGetUserMedia(returnParams);
	    };

	    self.getWebRtcStats = function(call, onSuccess, onFailure) {
	        rtcAdaptor.getWebRtcStats(call, onSuccess, onFailure);
	    };

	    self.getNativeWebRtcStats = function(call, onSuccess, onFailure) {
	        rtcAdaptor.getNativeWebRtcStats(call, onSuccess, onFailure);
	    };

	    self.startWebRtcStatsTimer = function(call, interval, onSuccess, onFailure) {
	        self.stopWebRtcStatsTimer(call);

	        call.statsTimer = setInterval(function() {
	            rtcAdaptor.getWebRtcStats(call, onSuccess, onFailure);
	        }, interval);
	    };

	    self.stopWebRtcStatsTimer = function(call) {
	        if (call.statsTimer) {
	            clearInterval(call.statsTimer);
	            call.statsTimer = undefined;
	        }
	    };

	    self.getUserMedia = function(onSuccess, onFailure, options) {
	        var audioConstraints = false,
	            videoConstraints = false,
	            returnParams = {
	                onSuccess: onSuccess,
	                onFailure: onFailure
	            };

	        if (options) {
	            rtcAdaptor.setMediaAudio(options.audio);
	            audioConstraints = options.audio;

	            rtcAdaptor.setMediaVideo(options.video);
	            videoConstraints = options.video;
	        }

	        if (!audioConstraints && !videoConstraints) {
	            _utils.callFunctionIfExist(onFailure, _fcs.call.MediaErrors.INVALID_PARAMETER);
	            return;
	        }

	        returnParams.options = {
	            audioConstraints: audioConstraints,
	            videoConstraints: videoConstraints
	        };

	        logger.info("getting user media - userAgent: " + _navigator.userAgent +
	            " constraints: ", {
	                audio: audioConstraints,
	                video: videoConstraints
	            });

	        rtcAdaptor.getUserMedia(returnParams);
	    };

	    self.startScreenMedia = function(onSuccess, onFailure, options, onEnded) {
	        logger.info("getting screen media for call: started - userAgent: " + _navigator.userAgent);

	        if (options) {
	            if (options.width) {
	                rtcAdaptor.setScreenWidth(options.width);
	            }

	            if (options.height) {
	                rtcAdaptor.setScreenHeight(options.height);
	            }

	            if (options.frameRate) {
	                rtcAdaptor.setScreenFrameRate(options.frameRate);
	            }

	            if(options.mediaSourceId) {
	                rtcAdaptor.setMediaSourceId(options.mediaSourceId);
	            }
	        }

	        rtcAdaptor.startScreenMedia(onSuccess, onFailure, onEnded);
	    };

	    self.stopScreenMedia = function() {

	        // If media source id was set via options, unset it.
	        if(rtcAdaptor.getMediaSourceId()) {
	            rtcAdaptor.setMediaSourceId('');
	        }

	        rtcAdaptor.stopScreenMedia();
	    };

	    self.createDataChannelOffer = function(dataChannelWrapperObj, successCallback, failureCallback, options, useIceServer) {
	        var successCallbackWrapper = function(sdp) {
	                clearSuccessParametersFromCall(dataChannelWrapperObj);
	                _utils.callFunctionIfExist(successCallback, sdp);
	            },
	            mandatorySettings = {
	                'mandatory': {
	                    'OfferToReceiveAudio': false,
	                    'OfferToReceiveVideo': false
	                }
	            };

	        setSuccessCallbacktoCall(dataChannelWrapperObj, successCallbackWrapper);

	        logger.info("open data channel: options= " + options);

	        rtcAdaptor.createPeer(
	            dataChannelWrapperObj,
	            useIceServer,
	            function createPeerSuccessCallback() {
	                rtcAdaptor.createDataChannel(
	                    dataChannelWrapperObj,
	                    function createDataChannelSuccessCallback() {
	                        rtcAdaptor.createDataChannelOffer(
	                            dataChannelWrapperObj,
	                            successCallbackWrapper,
	                            function createOfferFailureCallback(error) {
	                                clearSuccessParametersFromCall(dataChannelWrapperObj);
	                                _utils.callFunctionIfExist(failureCallback, error);
	                            }, mandatorySettings);
	                    },
	                    function createDataChannelFailureCallback(error) {
	                        _utils.callFunctionIfExist(failureCallback, error);
	                    });
	            },
	            function createPeerFailureCallback(error) {
	                _utils.callFunctionIfExist(failureCallback, error);
	            });
	    };

	    self.createDataChannelAnswer = function(dataChannelWrapperObj, successCallback, failureCallback, useIceServer) {
	        var successCallbackWrapper = function(sdp) {
	                clearSuccessParametersFromCall(dataChannelWrapperObj);
	                _utils.callFunctionIfExist(successCallback, sdp);
	            },
	            mandatorySettings = {
	                'mandatory': {
	                    'OfferToReceiveAudio': false,
	                    'OfferToReceiveVideo': false
	                }
	            };

	        setSuccessCallbacktoCall(dataChannelWrapperObj, successCallbackWrapper);

	        rtcAdaptor.createPeer(
	            dataChannelWrapperObj,
	            useIceServer,
	            function createPeerSuccessCallback() {
	                rtcAdaptor.createDataChannelAnswer(
	                    dataChannelWrapperObj,
	                    successCallbackWrapper,
	                    function createDataChannelAnswerFailureCallback(error) {
	                        clearSuccessParametersFromCall(dataChannelWrapperObj);
	                        _utils.callFunctionIfExist(failureCallback, error);
	                    }, mandatorySettings);
	            },
	            function createPeerFailureCallback(error) {
	                _utils.callFunctionIfExist(failureCallback, error);
	            });
	    };

	    self.createOffer = function(call, successCallback, failureCallback, sendInitialVideo, useIceServer) {
	        logger.info("create offer SDP: sendInitialVideo= " + sendInitialVideo);

	        var successCallbackWrapper = function(sdp) {
	            clearSuccessParametersFromCall(call);
	            call.initialVideoState = sendInitialVideo;
	            call.lastLocalSdp = sdp;
	            rtcAdaptor.restoreMuteStateOfCall(call);
	            rtcAdaptor.setOriginatorSendLocalVideo(call, sdp, sendInitialVideo);
	            if (typeof(successCallback) === 'function') {
	                successCallback(sdp);
	            }
	        };

	        setSuccessCallbacktoCall(call, successCallbackWrapper);

	        if (!call.peer) {
	            rtcAdaptor.createPeer(
	                call,
	                useIceServer,
	                function createPeerSuccessCallback() {
	                    rtcAdaptor.createOffer(call, successCallbackWrapper, function(err) {
	                        clearSuccessParametersFromCall(call);
	                        if (typeof(failureCallback) === 'function') {
	                            failureCallback(err);
	                        }
	                    }, sendInitialVideo);
	                },
	                function createPeerFailureCallback() {
	                    _utils.callFunctionIfExist(failureCallback, 2);
	                }
	            );
	        }
	    };

	    self.createAnswer = function(call, successCallback, failureCallback, isVideoEnabled, useIceServer) {
	        logger.info("creating answer SDP: callid= " + call.id);
	        logger.info("creating answer SDP: isVideoEnabled= " + isVideoEnabled);

	        var successCallbackWrapper = function(sdp) {
	            clearSuccessParametersFromCall(call);
	            call.initialVideoState = isVideoEnabled;
	            call.stableLocalSdp = sdp;
	            rtcAdaptor.setOriginatorSendLocalVideo(call, sdp, isVideoEnabled);
	            rtcAdaptor.setOriginatorReceiveRemoteVideo(call);
	            rtcAdaptor.setTcpSetupAttiributesOnCreateAnswer(call, sdp);
	            call.isRemoteEndFirefox = isRemoteEndFirefox(call.sdp);
	            if (typeof(successCallback) === 'function') {
	                successCallback(sdp);
	            }
	        };

	        setSuccessCallbacktoCall(call, successCallbackWrapper);

	        rtcAdaptor.addCallIdInPluginContainer(call);

	        if (!call.peer) {
	            rtcAdaptor.createPeer(
	                call,
	                useIceServer,
	                function createPeerSuccessCallback() {
	                    rtcAdaptor.performSdpWorkaroundsBeforeProcessingIncomingSdp(call);
	                    rtcAdaptor.createAnswer(call, successCallbackWrapper, function(err) {
	                        clearSuccessParametersFromCall(call);
	                        if (typeof(failureCallback) === 'function') {
	                            failureCallback(err);
	                        }
	                    }, isVideoEnabled);
	                },
	                function createPeerFailureCallback() {
	                    _utils.callFunctionIfExist(failureCallback, 2);
	                }
	            );
	        }
	    };

	    self.processDataChannelAnswer = function(call, successCallback, failureCallback) {
	        if (call.peer) {

	            var successCallbackWrapper = function() {
	                clearSuccessParametersFromCall(call);
	                if (typeof(successCallback) === 'function') {
	                    successCallback();
	                }
	            };

	            setSuccessCallbacktoCall(call, successCallbackWrapper);

	            rtcAdaptor.processDataChannelAnswer(call, successCallbackWrapper, function(err) {
	                clearSuccessParametersFromCall(call);
	                if (typeof(failureCallback) === 'function') {
	                    failureCallback(err);
	                }
	            });
	        }
	    };

	    self.processAnswer = function(call, successCallback, failureCallback) {
	        if (call.peer) {

	            var successCallbackWrapper = function() {
	                clearSuccessParametersFromCall(call);
	                call.stableLocalSdp = call.lastLocalSdp;
	                rtcAdaptor.restoreMuteStateOfCall(call);
	                rtcAdaptor.setOriginatorReceiveRemoteVideo(call);
	                if (typeof(successCallback) === 'function') {
	                    successCallback();
	                }
	            };

	            setSuccessCallbacktoCall(call, successCallbackWrapper);

	            rtcAdaptor.performSdpWorkaroundsBeforeProcessingIncomingSdp(call);
	            rtcAdaptor.setTcpSetupAttiributesOnProcessAnswer(call, call.sdp);
	            call.isRemoteEndFirefox = isRemoteEndFirefox(call.sdp);
	            rtcAdaptor.addCallIdInPluginContainer(call);

	            rtcAdaptor.processAnswer(call, successCallbackWrapper, function(err) {
	                clearSuccessParametersFromCall(call);
	                if (typeof(failureCallback) === 'function') {
	                    failureCallback(err);
	                }
	            });
	        }
	    };

	    self.processRespond = function(call, successCallback, failureCallback, isJoin) {
	        if (call.peer) {

	            var successCallbackWrapper = function() {
	                clearSuccessParametersFromCall(call);
	                call.stableLocalSdp = call.lastLocalSdp;
	                rtcAdaptor.setOriginatorReceiveRemoteVideo(call);
	                call.isRemoteEndFirefox = isRemoteEndFirefox(call.sdp);
	                if (typeof(successCallback) === 'function') {
	                    successCallback();
	                }
	            };

	            setSuccessCallbacktoCall(call, successCallbackWrapper);

	            rtcAdaptor.performSdpWorkaroundsBeforeProcessingIncomingSdp(call);
	            rtcAdaptor.setTcpSetupAttiributesOnProcessAnswer(call, call.sdp);
	            rtcAdaptor.addCallIdInPluginContainer(call);

	            rtcAdaptor.processRespond(call, successCallbackWrapper, function(err) {
	                clearSuccessParametersFromCall(call);
	                if (typeof(failureCallback) === 'function') {
	                    failureCallback(err);
	                }
	            }, isJoin);
	        }
	    };

	    self.createUpdate = function(call, successCallback, failureCallback, isVideoStart, useIceServer) {
	        logger.info("createUpdate: isVideoStart= " + isVideoStart);

	        if (call.peer) {

	            var successCallbackWrapper = function(sdp) {
	                clearSuccessParametersFromCall(call);
	                call.lastLocalSdp = sdp;
	                rtcAdaptor.muteVideoTrack(call, !isVideoStart, true);
	                rtcAdaptor.setOriginatorSendLocalVideo(call, sdp, isVideoStart);
	                if (typeof(successCallback) === 'function') {
	                    successCallback(sdp);
	                }
	            };

	            setSuccessCallbacktoCall(call, successCallbackWrapper);

	            rtcAdaptor.createUpdate(call, successCallbackWrapper, failureCallback, isVideoStart, useIceServer);
	        }
	    };

	    self.processUpdate = function(call, successCallback, failureCallback, local_hold_status, useIceServer) {
	        logger.info("processUpdate: local_hold_status:" + local_hold_status);

	        if (call.peer) {

	            var successCallbackWrapper = function(sdp) {
	                clearSuccessParametersFromCall(call);
	                call.stableLocalSdp = sdp;
	                rtcAdaptor.restoreMuteStateOfCall(call);
	                rtcAdaptor.setOriginatorReceiveRemoteVideo(call);
	                if (typeof(successCallback) === 'function') {
	                    successCallback(sdp);
	                }
	            };

	            setSuccessCallbacktoCall(call, successCallbackWrapper);

	            rtcAdaptor.performSdpWorkaroundsBeforeProcessingIncomingSdp(call);
	            call.isRemoteEndFirefox = isRemoteEndFirefox(call.sdp);
	            rtcAdaptor.addCallIdInPluginContainer(call);

	            rtcAdaptor.processUpdate(call, successCallbackWrapper, function(err) {
	                clearSuccessParametersFromCall(call);
	                if (typeof(failureCallback) === 'function') {
	                    failureCallback(err);
	                }
	            }, local_hold_status, useIceServer);
	        }
	    };

	    self.createReOffer = function(call, successCallback, failureCallback, usePreviousMediaDirection, useIceServer) {
	        if (call.peer) {

	            var successCallbackWrapper = function(sdp) {
	                clearSuccessParametersFromCall(call);
	                call.lastLocalSdp = sdp;
	                rtcAdaptor.restoreMuteStateOfCall(call);
	                rtcAdaptor.clearTcpSetupParameters(call);
	                if (typeof(successCallback) === 'function') {
	                    successCallback(sdp);
	                }
	            };

	            setSuccessCallbacktoCall(call, successCallbackWrapper);

	            rtcAdaptor.createReOffer(call, successCallbackWrapper, function(err) {
	                clearSuccessParametersFromCall(call);
	                if (typeof(failureCallback) === 'function') {
	                    failureCallback(err);
	                }
	            }, usePreviousMediaDirection, useIceServer);
	        }
	    };

	    self.createHoldUpdate = function(call, hold, remote_hold_status, successCallback, failureCallback, useIceServer) {
	        logger.info("create hold update local hold= " + hold + " remote hold= " + remote_hold_status);

	        if (call.peer) {

	            var successCallbackWrapper = function(sdp) {
	                clearSuccessParametersFromCall(call);
	                call.lastLocalSdp = sdp;
	                if (hold || remote_hold_status) {
	                    rtcAdaptor.muteOnHold(call, true);
	                } else {
	                    rtcAdaptor.restoreMuteStateOfCall(call);
	                }
	                if (typeof(successCallback) === 'function') {
	                    successCallback(sdp);
	                }
	            };

	            setSuccessCallbacktoCall(call, successCallbackWrapper);

	            rtcAdaptor.createHoldUpdate(call, hold, remote_hold_status, successCallbackWrapper,
	                function(err) {
	                    clearSuccessParametersFromCall(call);
	                    if (typeof(failureCallback) === 'function') {
	                        failureCallback(err);
	                    }
	                }, useIceServer);
	        }
	    };

	    self.processRemoteOfferOnLocalHold = function(call, successCallback, failureCallback) {
	        if (call.peer) {

	            var successCallbackWrapper = function(sdp) {
	                clearSuccessParametersFromCall(call);
	                rtcAdaptor.restoreMuteStateOfCall(call);
	                call.isRemoteEndFirefox = isRemoteEndFirefox(call.sdp);
	                if (typeof(successCallback) === 'function') {
	                    successCallback(sdp);
	                }
	            };

	            setSuccessCallbacktoCall(call, successCallbackWrapper);

	            rtcAdaptor.processRemoteOfferOnLocalHold(call, successCallbackWrapper,
	                function(err) {
	                    clearSuccessParametersFromCall(call);
	                    if (typeof(failureCallback) === 'function') {
	                        failureCallback(err);
	                    }
	                });
	        }
	    };

	    self.processEnd = function(call) {
	        if (call.peer) {
	            rtcAdaptor.processEnd(call);
	        }
	    };

	    self.processHold = function(call, hold, local_hold_status, successCallback, failureCallback, useIceServer) {
	        logger.info("processHold: local hold= " + local_hold_status + " remote hold= " + hold);

	        if (call.peer) {

	            var successCallbackWrapper = function(sdp) {
	                clearSuccessParametersFromCall(call);
	                call.stableLocalSdp = sdp;
	                if (!local_hold_status && !hold) {
	                    rtcAdaptor.restoreMuteStateOfCall(call);
	                    rtcAdaptor.setOriginatorSendLocalVideo(call, sdp, true);
	                }
	                if (!call.call.isVideoNegotiationAvailable()) {
	                    rtcAdaptor.muteVideoTrack(call, true, true);
	                    rtcAdaptor.setOriginatorSendLocalVideo(call, sdp, false);
	                }
	                rtcAdaptor.setOriginatorReceiveRemoteVideo(call);
	                if (typeof(successCallback) === 'function') {
	                    successCallback(sdp);
	                }
	            };

	            setSuccessCallbacktoCall(call, successCallbackWrapper);

	            rtcAdaptor.performSdpWorkaroundsBeforeProcessingIncomingSdp(call);
	            call.isRemoteEndFirefox = isRemoteEndFirefox(call.sdp);
	            rtcAdaptor.addCallIdInPluginContainer(call);

	            rtcAdaptor.processHold(call, hold, local_hold_status, successCallbackWrapper, function(err) {
	                clearSuccessParametersFromCall(call);
	                if (typeof(failureCallback) === 'function') {
	                    failureCallback(err);
	                }
	            }, useIceServer);
	        }
	    };

	    self.processHoldRespond = function(call, successCallback, failureCallback, isJoin) {
	        logger.info("Processing response to hold offer sent");

	        if (call.peer) {

	            var successCallbackWrapper = function() {
	                clearSuccessParametersFromCall(call);
	                call.stableLocalSdp = call.lastLocalSdp;
	                rtcAdaptor.setOriginatorReceiveRemoteVideo(call);
	                call.isRemoteEndFirefox = isRemoteEndFirefox(call.sdp);
	                if (typeof(successCallback) === 'function') {
	                    successCallback();
	                }
	            };

	            setSuccessCallbacktoCall(call, successCallbackWrapper);

	            rtcAdaptor.performSdpWorkaroundsBeforeProcessingIncomingSdp(call);
	            rtcAdaptor.setTcpSetupAttiributesOnProcessAnswer(call, call.sdp);
	            rtcAdaptor.addCallIdInPluginContainer(call);

	            rtcAdaptor.processHoldRespond(call, successCallbackWrapper, function(err) {
	                clearSuccessParametersFromCall(call);
	                if (typeof(failureCallback) === 'function') {
	                    failureCallback(err);
	                }
	            }, isJoin);
	        }
	    };

	    self.processPreAnswer = function(call, successCallback, failureCallback) {
	        logger.info("processing preanswer from the offer we sent");

	        if (call.peer) {
	            rtcAdaptor.performSdpWorkaroundsBeforeProcessingIncomingSdp(call);
	            rtcAdaptor.processPreAnswer(call, function() {
	                if (typeof(successCallback) === 'function') {
	                    successCallback();
	                }
	            }, function(err) {
	                if (typeof(failureCallback) === 'function') {
	                    failureCallback(err);
	                }
	            });

	        }

	    };

	    self.isDtlsEnabled = function() {
	        return rtcAdaptor.isDtlsEnabled();
	    };

	    self.revertRtcState = function(call, successCallback, failureCallback) {
	        var successCallbackWrapper = function() {
	            clearSuccessParametersFromCall(call);
	            if (typeof(successCallback) === 'function') {
	                successCallback(call);
	            }
	        };

	        setSuccessCallbacktoCall(call, successCallbackWrapper);

	        rtcAdaptor.revertRtcState(call, successCallbackWrapper, failureCallback);
	    };

	    self.getRemoteVideoResolutions = function() {
	        return rtcAdaptor.getRemoteVideoResolutions();
	    };

	    self.getLocalVideoResolutions = function() {
	        return rtcAdaptor.getLocalVideoResolutions();
	    };

	    self.isAudioSourceAvailable = function() {
	        return rtcAdaptor.getAudioSourceAvailable();
	    };

	    self.isVideoSourceAvailable = function() {
	        return rtcAdaptor.getVideoSourceAvailable();
	    };

	    self.refreshVideoRenderer = function() {
	        rtcAdaptor.refreshVideoRenderer();
	    };

	    self.sendIntraFrame = function(internalCall) {
	        rtcAdaptor.sendIntraFrame(internalCall);
	    };

	    self.sendBlackFrame = function(internalCall) {
	        rtcAdaptor.sendBlackFrame(internalCall);
	    };

	    self.muteAudioTrack = function(call, mute) {
	        return rtcAdaptor.muteAudioTrack(call, mute, true);
	    };

	    self.isAudioMuted = function(call) {
	        return rtcAdaptor.isAudioMuted(call);
	    };

	    self.addLocalStream = function(call) {
	        rtcAdaptor.addLocalStream(call);
	    };

	    self.isPluginEnabled = function() {
	        return rtcAdaptor.isPluginEnabled();
	    };

	    self.sendDTMF = function(call, tone) {
	        rtcAdaptor.sendDTMF(call, tone);
	    };

	    self.showSettingsWindow = function() {
	        rtcAdaptor.showSettingsWindow();
	    };

	    self.createStreamRenderer = function(streamId, container, options) {
	        return rtcAdaptor.createStreamRenderer(streamId, container, options);
	    };

	    self.disposeStreamRenderer = function(container) {
	        rtcAdaptor.disposeStreamRenderer(container);
	    };

	    self.set_logSeverityLevel = function(level) {
	        rtcAdaptor.set_logSeverityLevel(level);
	    };

	    self.enable_logCallback = function() {
	        rtcAdaptor.enable_logCallback();
	    };

	    self.disable_logCallback = function() {
	        rtcAdaptor.disable_logCallback();
	    };

	    self.get_audioInDeviceCount = function() {
	        return rtcAdaptor.get_audioInDeviceCount();
	    };

	    self.get_audioOutDeviceCount = function() {
	        return rtcAdaptor.get_audioOutDeviceCount();
	    };

	    self.get_videoDeviceCount = function() {
	        return rtcAdaptor.get_videoDeviceCount();
	    };

	    self.storeLocalStreamToCall = function(call, localStreamId) {
	        rtcAdaptor.storeLocalStreamToCall(call, localStreamId);
	    };

	    self.updateLocalStreamToCall = function(call, localStreamId) {
	        rtcAdaptor.updateLocalStreamToCall(call, localStreamId);
	    };

	    self.getStreamById = function(id) {
	        return rtcAdaptor.getStreamById(id);
	    };

	    self.removeStreamById = function(id) {
	        rtcAdaptor.removeStreamById(id);
	    };

	    self.setSelectedMicrophoneId = function(_selectedMicrophoneId) {
	        rtcAdaptor.setSelectedMicrophoneId(_selectedMicrophoneId);
	    };

	    self.setSelectedSpeakerId = function(_selectedSpeakerId) {
	        rtcAdaptor.setSelectedSpeakerId(_selectedSpeakerId);
	    };

	    self.setSelectedCameraId = function(_selectedCameraId) {
	        rtcAdaptor.setSelectedCameraId(_selectedCameraId);
	    };

	    self.getSelectedMicrophoneId = function() {
	        return rtcAdaptor.getSelectedMicrophoneId();
	    };

	    self.getSelectedSpeakerId = function() {
	        return rtcAdaptor.getSelectedSpeakerId();
	    };

	    self.getSelectedCameraId = function() {
	        return rtcAdaptor.getSelectedCameraId();
	    };

	    self.getCameraList = function(onSuccess) {
	        rtcAdaptor.getCameraList(function(cameraList) {
	            _utils.callFunctionIfExist(onSuccess, cameraList);
	        });
	    };

	    self.getMicrophoneList = function(onSuccess) {
	        rtcAdaptor.getMicrophoneList(function(microphoneList) {
	            _utils.callFunctionIfExist(onSuccess, microphoneList);
	        });
	    };

	    self.getSpeakerList = function(onSuccess) {
	        rtcAdaptor.getSpeakerList(function(speakerList) {
	            _utils.callFunctionIfExist(onSuccess, speakerList);
	        });
	    };

	    _globalBroadcaster.subscribe(CONSTANTS.EVENT.FCS_SETUP_COMPLETED, self.onFcsSetupCompleted);

	    
	};

	//@{fcs-jsl-prod}
	var webRtcManager = new WebRtcManager(webRtcAdaptorFactory, logManager, turnCredentialsManager, navigator, utils, fcs, globalBroadcaster);
	//@{fcs-jsl-prod}



	var SubscriptionServiceImpl = function(_server, _fcsConfig, _fcs, _window, _getWAMUrl, _getUrl, _turnCredentialsManager) {

	    var SUBSCRIPTION_URL = "/subscription",
	        SUBSCRITION_KEYS_FOR_ASSIGNED_SERVICES = {
	            "CallControl": "call",
	            "call": "call",
	            "IM": "IM",
	            "Presence": "Presence",
	            "custom": "custom",
	            "callMe": "callMe",
	            "RCC": "RCC",
	            "MWI": "mwi",
	            "DataChannel": "DataChannel"
	        },
	        DEFAULT_SERVICES = [SUBSCRITION_KEYS_FOR_ASSIGNED_SERVICES.IM,
	            SUBSCRITION_KEYS_FOR_ASSIGNED_SERVICES.Presence,
	            SUBSCRITION_KEYS_FOR_ASSIGNED_SERVICES.CallControl
	        ],
	        DEFAULT_ANONYMOUS_SERVICES = [SUBSCRITION_KEYS_FOR_ASSIGNED_SERVICES.callMe],
	        DEFAULT_SUBSCRIPTION_EXPIRY_VALUE = 3600;

	    function getNotificationType() {
	        // if SNMP is set return specific data to be sent to the server
	        if (_fcsConfig.currentNotificationType === _fcs.notification.NotificationTypes.WEBSOCKET && _window.WebSocket) {
	            return {
	                notificationType: "WebSocket",
	                clientIp: _fcsConfig.clientIp
	            };
	        } else {
	            return {
	                notificationType: "LongPolling",
	                pollingTimer: _fcsConfig.polling
	            };
	        }
	    }

	    function composeServicesToSubscribeFromAssignedServices(assignedServices) {
	        var i, services = [];
	        for (i in SUBSCRITION_KEYS_FOR_ASSIGNED_SERVICES) {
	            if (SUBSCRITION_KEYS_FOR_ASSIGNED_SERVICES.hasOwnProperty(i)) {
	                if (assignedServices.indexOf(i) !== -1) {
	                    services.push(SUBSCRITION_KEYS_FOR_ASSIGNED_SERVICES[i]);
	                }
	            }
	        }

	        return services;
	    }

	    function composeSubscribeRequestData(forceLogout, isSubscribe) {
	        var notificationTypeData = getNotificationType(),
	            i,
	            subscribeRequest;

	        subscribeRequest = {
	            "expires": Math.floor(_fcsConfig.expires),
	            "service": _fcs.notification.isAnonymous() ? composeServicesToSubscribeFromAssignedServices(_fcsConfig.anonymousServices ? _fcsConfig.anonymousServices : DEFAULT_ANONYMOUS_SERVICES) : composeServicesToSubscribeFromAssignedServices(_fcsConfig.services ? _fcsConfig.services : DEFAULT_SERVICES),
	            "localization": "English_US"
	        };

	        if (isSubscribe && _fcsConfig.serverProvidedTurnCredentials) {
	            subscribeRequest.useTurn = (_fcsConfig.serverProvidedTurnCredentials === true ? true : false);
	        }

	        if (forceLogout === true) {
	            subscribeRequest.forceLogOut = "true";
	        }

	        for (i in notificationTypeData) {
	            if (notificationTypeData.hasOwnProperty(i)) {
	                subscribeRequest[i] = notificationTypeData[i];
	            }
	        }

	        return subscribeRequest;
	    }

	    this.extendSubscription = function(subscriptionURL, onSuccess, onFailure) {
	        if (_fcsConfig.expires === 0) {
	            _fcsConfig.expires = DEFAULT_SUBSCRIPTION_EXPIRY_VALUE;
	        }

	        _server.sendPutRequest({
	                url: _getUrl() + subscriptionURL,
	                data: {
	                    "subscribeRequest": composeSubscribeRequestData()
	                }
	            },
	            function(data) {
	                var response = data.subscribeResponse,
	                    params = response.subscriptionParams;
	                onSuccess(params.notificationChannel, params.assignedService, params.service);
	            },
	            onFailure
	        );
	    };

	    this.subscribe = function(onSuccess, onFailure, forceLogout, token) {
	        var dummy, realm = getRealm();
	        _fcsConfig.expires = DEFAULT_SUBSCRIPTION_EXPIRY_VALUE;
	        _server.sendPostRequest({
	                url: _getWAMUrl(1, SUBSCRIPTION_URL + (realm ? ("?tokenrealm=" + realm) : "")),
	                data: {
	                    "subscribeRequest": composeSubscribeRequestData(forceLogout, true)
	                }
	            },
	            function(data) {
	                var response = data.subscribeResponse,
	                    params = response.subscriptionParams,
	                    turnParams;
	                if (params.turnActive === true) {
	                    if (params.turnCredentials && params.turnCredentials.username && params.turnCredentials.password) {
	                        turnParams = {
	                            username: params.turnCredentials.username,
	                            credential: params.turnCredentials.password
	                        };
	                        _turnCredentialsManager.save(turnParams);
	                    }
	                }
	                onSuccess(response.subscription,
	                    params.notificationChannel,
	                    params.expires,
	                    params.pollingTimer,
	                    params.assignedService,
	                    params.service,
	                    params.sessionId);
	            },
	            onFailure, dummy, dummy, dummy, dummy, token
	        );
	    };

	    this.deleteSubscription = function(subscriptionURL, onSuccess, onFailure) {
	        _turnCredentialsManager.remove();
	        _server.sendDeleteRequest({
	                url: _getUrl() + subscriptionURL
	            },
	            onSuccess,
	            onFailure
	        );
	    };
	};

	//@{fcs-jsl-prod}
	var subscriptionService = new SubscriptionServiceImpl(server,
	    fcsConfig,
	    fcs,
	    window,
	    getWAMUrl,
	    getUrl,
	    turnCredentialsManager);
	//@{fcs-jsl-prod}



	var LongpollingServiceImpl = function(_server, _getUrl) {

	    this.retrieveNotification = function(retrieveData) {
	        return _server.sendGetRequest({
	                url: _getUrl() + retrieveData.notificationUrl
	            },
	            function(data) {
	                var type = null,
	                    notificationMessage;
	                if (data !== null) {
	                    notificationMessage = data.notificationMessage;
	                    if (notificationMessage) {
	                        type = notificationMessage.eventType;
	                    }
	                }
	                retrieveData.notificationSuccess({
	                    type: type,
	                    data: notificationMessage,
	                    notificationURL: retrieveData.notificationUrl
	                });
	            },
	            function(status) {
	                retrieveData.notificationFailure({
	                    error: status,
	                    notificationChannelURL: retrieveData.notificationUrl
	                });
	            });
	    };
	};

	//@{fcs-jsl-prod}
	var LongpollingService = function(_server, _getUrl) {
	    return new LongpollingServiceImpl(_server || server,
	        _getUrl || getUrl);
	};
	var longpollingService = new LongpollingService();
	//@{fcs-jsl-prod}



	var ConnectivityServiceImpl = function(_server, _getUrl, _utils) {

	    var CONNECTION_URL = "/rest/version/latest/isAlive";

	    this.checkConnectivity = function(onSuccess, onFailure) {
	        _server.sendGetRequest({
	            url: _getUrl() + CONNECTION_URL + "?" + _utils.getTimestamp()
	        }, onSuccess, onFailure);
	    };

	};

	//@{fcs-jsl-prod}
	var ConnectivityService = function(_server, _getUrl, _utils) {
	    return new ConnectivityServiceImpl(_server || server,
	        _getUrl || getUrl,
	        _utils || utils);
	};
	var connectivityService = new ConnectivityService();
	//@{fcs-jsl-prod}



	var LongpollingManagerImpl = function(_logManager, _service, _CONSTANTS) {
	    var logger = _logManager.getLogger("longpollingManager"),
	        triggeredFetch = false,
	        lastLongpollingRequest = null,
	        self = this;

	    this.clearConnection = function() {
	        if (lastLongpollingRequest) {
	            logger.trace("aborting last long polling request.");
	            lastLongpollingRequest.abort();
	            lastLongpollingRequest = null;
	        } else {
	            logger.info("lastLongpollingRequest is undefined, cannot clear connection");
	        }
	    };

	    this.connect = function(data) {
	        if (data.notificationURL) {
	            self.clearConnection();
	            data.onSuccess(_CONSTANTS.LONG_POLLING.STATUS.TRIGGERED_CONNECT);
	            lastLongpollingRequest = _service.retrieveNotification({
	                notificationUrl: data.notificationURL,
	                notificationSuccess: data.onNotificationReceived,
	                notificationFailure: data.onFailure
	            });
	        } else {
	            logger.error("notification URL is undefined, cannot fetch notification");
	        }
	    };

	    this.trigger = function(data) {
	        if (!triggeredFetch) {
	            self.connect({
	                notificationURL: data.notificationUrl,
	                onSuccess: function() {
	                    return;
	                },
	                onNotificationReceived: data.notificationSuccess,
	                onFailure: data.notificationFailure
	            });
	            triggeredFetch = true;
	        } else {
	            logger.error("trigger could not fetch notification");
	        }
	    };

	};

	//@{fcs-jsl-prod}
	var LongpollingManager = function(_logManager, _service, _CONSTANTS) {
	    return new LongpollingManagerImpl(_logManager || logManager,
	        _service || longpollingService,
	        _CONSTANTS || CONSTANTS);
	};
	var longpollingManager = new LongpollingManager();
	//@{fcs-jsl-prod}




	var WebsocketManagerImpl = function(_logManager, _window, _CONSTANTS, _fcsConfig, _globalBroadcaster) {
	    var logger = _logManager.getLogger("websocketManager"),
	        WEBSOCKET_CONSTANTS = _CONSTANTS.WEBSOCKET,
	        webSocket = null,
	        DEFAULT_INTERVAL_VALUE = 10000,
	        connectivityTimerID,
	        self = this;


	    function isWebsocketOpened() {
	        if (webSocket && webSocket.readyState === webSocket.OPEN) {
	            return true;
	        }
	        return false;
	    }

	    this.websocketConnectionCheck = function() {
	        if (isWebsocketOpened()) {
	            try {
	                webSocket.send("test");
	            } catch (e) {
	                logger.trace("Exception occured while executing connecitivy handler: ", e);
	            }
	        }
	    };

	    this.handleWebsocketTestIntervalValueValidation = function(time) {
	        if (isNaN(time) || (time < 1000 && time !== 0) || time > 10000) {
	            return DEFAULT_INTERVAL_VALUE;
	        } else {
	            return time;
	        }
	    };

	    function stopWebSocketConnectivityCheck() {
	        logger.debug("check web socket is stopped.");
	        clearInterval(connectivityTimerID);
	    }

	    function startWebSocketConnectivityCheck() {
	        var interval;
	        stopWebSocketConnectivityCheck();
	        interval = self.handleWebsocketTestIntervalValueValidation(parseInt(_fcsConfig.websocketInterval, 10));
	        if (interval !== 0) {
	            logger.debug("check web socket is started." + interval);
	            connectivityTimerID = setInterval(self.websocketConnectionCheck, interval);
	        } else {
	            logger.debug("check web socket is not started." + interval);
	        }
	    }

	    this.clearConnection = function() {
	        if (webSocket) {
	            webSocket.onmessage = null;
	            webSocket.onopen = null;
	            webSocket.onclose = null;
	            webSocket.onerror = null;
	            if (webSocket.close) {
	                webSocket.close();
	            }
	            webSocket = null;
	        }
	        stopWebSocketConnectivityCheck();
	    };

	    this.connect = function(connectionData) {
	        var protocolValue = WEBSOCKET_CONSTANTS.PROTOCOL.NONSECURE;

	        function callOnSuccess(successData) {
	            logger.trace("websocket connection created successfully: " + successData.status);

	            // Make sure to set our internal state to connected
	            _globalBroadcaster.publish(_CONSTANTS.EVENT.WEBSOCKET_CONNECTED);

	            if (typeof connectionData.onSuccess === 'function') {
	                connectionData.onSuccess(successData.status);
	            }
	        }

	        function callOnFailure(failureData) {
	            logger.trace("websocket connection failed: " + failureData.status);
	            self.clearConnection();

	            // Make sure to set our internal state to disconnected
	            _globalBroadcaster.publish(_CONSTANTS.EVENT.WEBSOCKET_DISCONNECTED);

	            if (typeof connectionData.onFailure === 'function') {
	                connectionData.onFailure(failureData.status);
	            }
	        }

	        // Always cleanup in case there is already a websocket
	        self.clearConnection();

	        try {
	            if (_fcsConfig.websocketProtocol) {
	                if (_fcsConfig.websocketProtocol === WEBSOCKET_CONSTANTS.PROTOCOL.SECURE) {
	                    protocolValue = WEBSOCKET_CONSTANTS.PROTOCOL.SECURE;
	                }
	            }
	            webSocket = new _window.WebSocket(protocolValue + "://" + (_fcsConfig.websocketIP ? _fcsConfig.websocketIP : _window.location.hostname) + ":" + (_fcsConfig.websocketPort ? _fcsConfig.websocketPort : WEBSOCKET_CONSTANTS.DEFAULT_PORT) + connectionData.notificationURL);
	        } catch (exception) {
	            logger.error("WebSocket create error: ", exception);
	            callOnFailure({
	                status: WEBSOCKET_CONSTANTS.STATUS.CREATE_ERROR
	            });
	            return;
	        }

	        if (webSocket !== null) {
	            webSocket.onmessage = function(event) {
	                var data = JSON.parse(event.data),
	                    notificationMessage, type;
	                if (data) {
	                    notificationMessage = data.notificationMessage;
	                    if (notificationMessage) {
	                        type = notificationMessage.eventType;
	                        connectionData.onNotificationReceived({
	                            type: type,
	                            data: notificationMessage,
	                            notificationURL: connectionData.notificationURL
	                        });
	                    }
	                }
	            };
	            webSocket.onopen = function() {
	                logger.info("WebSocket opened");
	                startWebSocketConnectivityCheck();
	                callOnSuccess({
	                    status: WEBSOCKET_CONSTANTS.STATUS.OPENED
	                });
	            };
	            webSocket.onclose = function() {
	                logger.info("WebSocket closed");
	                callOnFailure({
	                    status: WEBSOCKET_CONSTANTS.STATUS.CONNECTION_CLOSED
	                });
	            };
	            webSocket.onerror = function() {
	                logger.error("Error on Web Socket connection.");
	                callOnFailure({
	                    status: WEBSOCKET_CONSTANTS.STATUS.CONNECTION_ERROR
	                });
	            };
	        } else {
	            callOnFailure({
	                status: WEBSOCKET_CONSTANTS.STATUS.NOT_FOUND
	            });

	        }
	    };

	    
	};

	//@{fcs-jsl-prod}
	var WebsocketManager = function(_logManager, _window, _CONSTANTS, _fcsConfig, _globalBroadcaster) {
	    return new WebsocketManagerImpl(_logManager || logManager,
	        _window || window,
	        _CONSTANTS || CONSTANTS,
	        _fcsConfig || fcsConfig,
	        _globalBroadcaster || globalBroadcaster);
	};
	var websocketManager = new WebsocketManager();
	//@{fcs-jsl-prod}



	var ConnectivityManagerImpl = function(_service, _logManager, _window, _globalBroadcaster, _CONSTANTS, _setConnected, _fcsConfig) {
	    var logger = _logManager.getLogger("connectivityManager"),
	        PRIORITY = 1,
	        isConnected = true,
	        connectivityTimer;

	    function stopCheckConnectivityTimer(params) {
	        logger.info("check connectivity timer is stopped.");
	        if (params && params.resetConnectivity) {
	            clearInterval(connectivityTimer);
	            isConnected = true;
	            _setConnected(isConnected);
	        }
	    }

	    function onCheckConnectivitySuccess() {
	        if (!isConnected) {
	            isConnected = true;
	            _setConnected(isConnected);
	            logger.trace("Connectivity re-established...");
	            _globalBroadcaster.publish(_CONSTANTS.EVENT.CONNECTION_REESTABLISHED);
	        }
	    }

	    function onCheckConnectivityFailure() {
	        if (isConnected) {
	            isConnected = false;
	            _setConnected(isConnected);
	            logger.trace("Connectivity is lost...");
	            _globalBroadcaster.publish(_CONSTANTS.EVENT.CONNECTION_LOST);
	        }
	    }

	    function checkConnectivity() {
	        _service.checkConnectivity(onCheckConnectivitySuccess, onCheckConnectivityFailure);
	    }

	    function isPositiveNumber(str) {
	        var pattern = /^(?:0|[1-9][0-9]*)$/;
	        // returns a boolean
	        return pattern.test(str);
	    }

	    function checkConnectivityViaContainer() {
	        logger.info("connectivity check via Container");
	        checkConnectivity();
	    }

	    function initConnectivityCheck() {
	        var interval = isPositiveNumber(_fcsConfig.connectivityInterval) ? _fcsConfig.connectivityInterval : _CONSTANTS.TIMEOUT.DEFAULT_CONNECTIVITY_CHECK_INTERVAL;

	        stopCheckConnectivityTimer({
	            resetConnectivity: true
	        });
	        if (interval !== "0") {
	            connectivityTimer = setInterval(checkConnectivity, interval);
	        }
	        if (_window.registerNetworkInternetCallback) {
	            _window.registerNetworkInternetCallback(checkConnectivityViaContainer);
	        }
	    }

	    _globalBroadcaster.subscribe(_CONSTANTS.EVENT.DEVICE_SUBSCRIPTION_STARTED, initConnectivityCheck, PRIORITY);
	    _globalBroadcaster.subscribe(_CONSTANTS.EVENT.DEVICE_SUBSCRIPTION_ENDED, stopCheckConnectivityTimer, PRIORITY);
	    _globalBroadcaster.subscribe(_CONSTANTS.EVENT.XHR_REQUEST_NOT_INITIALIZED, onCheckConnectivityFailure, PRIORITY);
	    _globalBroadcaster.subscribe(_CONSTANTS.EVENT.WEBSOCKET_DISCONNECTED, onCheckConnectivityFailure, PRIORITY);
	    _globalBroadcaster.subscribe(_CONSTANTS.EVENT.WEBSOCKET_CONNECTED, onCheckConnectivitySuccess, PRIORITY);
	    _globalBroadcaster.subscribe(_CONSTANTS.EVENT.FORCE_CONNECTIVITY_CHECK, checkConnectivity, PRIORITY);

	    

	};

	//@{fcs-jsl-prod}
	var ConnectivityManager = function(_service, _logManager, _window, _globalBroadcaster, _CONSTANTS, _setConnected, _fcsConfig) {
	    return new ConnectivityManagerImpl(_service || connectivityService,
	        _logManager || logManager,
	        _window || window,
	        _globalBroadcaster || globalBroadcaster,
	        _CONSTANTS || CONSTANTS,
	        _setConnected || setConnected,
	        _fcsConfig || fcsConfig);
	};

	var connectivityManager = new ConnectivityManager();
	//@{fcs-jsl-prod}


	var NotificationCallBacks = {};
	var NotificationManagerImpl = function(_logManager, _globalBroadcaster, _websocketManager, _longpollingManager, _fcs, _utils, _CONSTANTS, _fcsConfig, _NotificationCallBacks) {
	    var logger = _logManager.getLogger("notificationManager"),
	        notificationEventIdQueue = [],
	        isNotificationFailureDetected = false,
	        notificationSuccess,
	        notificationFailure,
	        onNotificationSuccessAfterFailure,
	        onNotificationFailure,
	        webSocketRetryAuditTimer,
	        originalWebsocketRetry,
	        websocketRetry,
	        websocketRetryTime,
	        websocketNotificationURL,
	        self = this,
	        DEFAULT_RETRY_TIME = 5000,
	        DEFAULT_RETRY_NUMBER = 5,
	        NOTIFICATION_EVENT_ID_QUEUE_MAX_LENGTH = 100,
	        onLongPollingFailure;

	    this.NotificationTypes = {
	        LONGPOLLING: "longpolling",
	        SNMP: "snmp",
	        WEBSOCKET: "websocket",
	        WEBSOCKET_ONLY: "websocketonly"
	    };

	    this.isWebSocketConnection = function(data) {
	        if (data && data.notificationURL) {
	            return data.notificationURL.indexOf("/websocket/") !== -1;
	        }
	    };

	    this.isLongPollingConnection = function(data) {
	        if (data && data.notificationURL) {
	            return data.notificationURL.indexOf("/notification/") !== -1;
	        }
	    };

	    function longPollingFailureHandler(failureData) {
	        logger.debug("Long polling failure...");
	        notificationFailure(failureData);
	        // might not be set in trigger cases...
	        _utils.callFunctionIfExist(onLongPollingFailure, failureData.error);
	    }

	    function lPConnectWorker(url, successCallback) {
	        logger.debug("Connect long polling to: ", url);
	        _longpollingManager.connect({
	            notificationURL: url,
	            onSuccess: successCallback,
	            onFailure: longPollingFailureHandler,
	            onNotificationReceived: notificationSuccess
	        });
	    }

	    function wsConnectWorker(url, successCallback, failureCallback) {
	        logger.debug("Connect web socket to: ", url);
	        _websocketManager.connect({
	            notificationURL: url,
	            onSuccess: successCallback,
	            onFailure: failureCallback,
	            onNotificationReceived: notificationSuccess
	        });
	    }

	    this.handleWebsocketRetry = function(data) {
	        logger.debug("WebSocket Connection Retry..." + " retry : " + websocketRetry);
	        if (websocketRetry && websocketRetry > 0) {
	            websocketRetry = websocketRetry - 1;

	            webSocketRetryAuditTimer = setTimeout(
	                function() {
	                    wsConnectWorker(websocketNotificationURL,
	                        function(status) {
	                            logger.debug("WebSocket re-connection success.");
	                            websocketRetry = originalWebsocketRetry;
	                            data.successCallback(status);
	                        },
	                        function(status) {
	                            logger.debug("WebSocket re-connection failure.The left trial : " + websocketRetry);
	                            self.handleWebsocketRetry({
	                                message: status,
	                                successCallback: data.successCallback,
	                                failureCallback: data.failureCallback
	                            });
	                        });
	                }, websocketRetryTime);
	        } else {
	            logger.debug("WebSocket re-connection failure.WebSocket URL out of use !");
	            data.failureCallback(data.message);
	        }
	    };

	    this.handleWebsocketRetryValueValidation = function(retry) {
	        if (isNaN(retry) || retry < 0 || retry > 10) {
	            return DEFAULT_RETRY_NUMBER;
	        } else {
	            return retry;
	        }
	    };

	    this.handleWebsocketRetryTimeValidation = function(time) {
	        if (isNaN(time) || time < 1000 || time > 10000) {
	            return DEFAULT_RETRY_TIME;
	        } else {
	            return time;
	        }
	    };

	    this.setNotificationSuccessAfterFailureCallback = function(data) {
	        onNotificationSuccessAfterFailure = data.callback;
	    };

	    this.setNotificationFailureCallback = function(data) {
	        onNotificationFailure = data.callback;
	    };

	    // Handles successfully fetched notification
	    notificationSuccess = function(successData) {
	        var data = successData.data,
	            type = successData.type;
	        if (data && type) {
	            if (notificationEventIdQueue.indexOf(data.eventId) !== -1) {
	                logger.info("event received previously: " + data.eventId);
	            } else {
	                notificationEventIdQueue.push(data.eventId);
	                if (notificationEventIdQueue.length === NOTIFICATION_EVENT_ID_QUEUE_MAX_LENGTH) {
	                    notificationEventIdQueue.splice(0, 50);
	                }
	                _utils.callFunctionIfExist(_NotificationCallBacks[type], data);
	            }
	        }

	        if (self.isLongPollingConnection({
	                notificationURL: successData.notificationURL
	            })) {
	            lPConnectWorker(successData.notificationURL, function() {
	                return;
	            });
	        }
	    };

	    notificationFailure = function(failuredata) {
	        logger.error("received notification error:" + failuredata.error);
	        _globalBroadcaster.publish(_CONSTANTS.EVENT.NOTIFICATION_CHANNEL_LOST);
	        if (!_fcs.isConnected()) {
	            logger.debug("Connection is lost, no need to handle notification failure...");
	            return;
	        }
	        logger.trace("It was set isNotificationFailureDetected parameter as true");
	        isNotificationFailureDetected = true;
	        onNotificationFailure(failuredata.error);
	    };

	    this.trigger = function(data) {
	        _longpollingManager.trigger({
	            notificationUrl: data.notificationUrl,
	            notificationSuccess: notificationSuccess,
	            notificationFailure: longPollingFailureHandler
	        });
	    };

	    this.connect = function(data) {
	        logger.trace("Clear web socket timer");
	        clearTimeout(webSocketRetryAuditTimer);

	        function handleConnectSuccess(status) {
	            if (typeof data.onSuccess === 'function') {
	                data.onSuccess(status);
	            }
	            if (isNotificationFailureDetected) {
	                logger.trace("It was set isNotificationFailureDetected parameter as false");
	                isNotificationFailureDetected = false;
	                if (typeof onNotificationSuccessAfterFailure === 'function') {
	                    onNotificationSuccessAfterFailure(status);
	                }
	            }
	        }

	        if (self.isWebSocketConnection({
	                notificationURL: data.notificationURL
	            })) {
	            originalWebsocketRetry = self.handleWebsocketRetryValueValidation(parseInt(_fcsConfig.serverRetryNumber, 10));
	            websocketRetry = self.handleWebsocketRetryValueValidation(parseInt(_fcsConfig.serverRetryNumber, 10));
	            websocketRetryTime = self.handleWebsocketRetryTimeValidation(parseInt(_fcsConfig.serverRetryInterval, 10));
	            websocketNotificationURL = data.notificationURL;

	            wsConnectWorker(data.notificationURL,
	                handleConnectSuccess,
	                function(status) {
	                    logger.debug("WebSocket Connection Failed...");
	                    notificationFailure(status);
	                    self.handleWebsocketRetry({
	                        message: status,
	                        successCallback: handleConnectSuccess,
	                        failureCallback: data.onFailure
	                    });
	                });
	        } else {
	            // We need to keep this function to call connect in each
	            // notification success.
	            onLongPollingFailure = data.onFailure;
	            lPConnectWorker(data.notificationURL, handleConnectSuccess);
	        }
	    };

	    this.clearConnection = function(data) {
	        if (data && data.notificationType === self.NotificationTypes.LONGPOLLING) {
	            _longpollingManager.clearConnection();
	        } else if (data && data.notificationType === self.NotificationTypes.WEBSOCKET) {
	            _websocketManager.clearConnection();
	        } else {
	            _longpollingManager.clearConnection();
	            _websocketManager.clearConnection();
	        }

	        if (data && data.withNotificationFailure) {
	            logger.trace("It was set isNotificationFailureDetected parameter as true");
	            isNotificationFailureDetected = true;
	        }
	        logger.trace("Clear web socket timer");
	        clearTimeout(webSocketRetryAuditTimer);
	    };

	    
	};

	//@{fcs-jsl-prod}
	var NotificationManager = function(_logManager, _globalBroadcaster, _websocketManager, _longpollingManager, _fcs, _utils, _CONSTANTS, _fcsConfig, _NotificationCallBacks) {
	    return new NotificationManagerImpl(
	        _logManager || logManager,
	        _globalBroadcaster || globalBroadcaster,
	        _websocketManager || websocketManager,
	        _longpollingManager || longpollingManager,
	        _fcs || fcs,
	        _utils || utils,
	        _CONSTANTS || CONSTANTS,
	        _fcsConfig || fcsConfig,
	        _NotificationCallBacks || NotificationCallBacks);
	};

	var notificationManager = new NotificationManager();
	//@{fcs-jsl-prod}



	var SubscriptionManagerImpl = function(_fcsConfig, _fcs, _service, _logManager, _globalBroadcaster, _cache, _notificationManager, _utils, _CONSTANTS, _notificationCallBacks) {
	    var
	        logger = _logManager.getLogger("subscriptionManager"),
	        CACHEIDS = _CONSTANTS.CACHE,
	        isAnonymous = false,
	        extendNotificationSubscription,
	        extendNotificationSubscriptionTimer = null,
	        onConnectionLost,
	        onConnectionEstablished,
	        onSubscriptionSuccess = null,
	        onSubscriptionFailure = null,
	        startNotificationTimerAfterConnectionReEstablished,
	        restartSubscriptionTimer,
	        token = null,
	        session = null,
	        notificationErrorCallback,
	        notificationSuccessAfterErrorCallback,
	        notificationCachePrefix = "",
	        notifier,
	        useNewStyleConfig,
	        serverIndex,
	        numberOfServers,
	        nType = _notificationManager.NotificationTypes,
	        restartSubscription;

	    function onTokenAuth(data) {
	        token = data.token;
	    }

	    function clearCache() {
	        _cache.removeItem(notificationCachePrefix + CACHEIDS.NOTIFYURL);
	        _cache.removeItem(notificationCachePrefix + CACHEIDS.NOTIFYID);
	        _cache.removeItem(notificationCachePrefix + CACHEIDS.SUBSCRIBEURL);
	        _cache.removeItem(notificationCachePrefix + CACHEIDS.SUBSCRIBEEXPIRY);
	        _cache.removeItem(notificationCachePrefix + CACHEIDS.SUBSCRIBEEXTENDINTERVAL);
	        _cache.removeItem(notificationCachePrefix + CACHEIDS.SESSION);
	    }

	    function clearUserNamePasswordFromCache() {
	        _cache.removeItem(notificationCachePrefix + CACHEIDS.USERNAME);
	        _cache.removeItem(CACHEIDS.PASSWORD);
	    }

	    function publishDeviceSubscriptionStartedMessage(message) {
	        _globalBroadcaster.publish(_CONSTANTS.EVENT.DEVICE_SUBSCRIPTION_STARTED, message);
	    }

	    function publishDeviceSubscriptionEndedMessage(params) {
	        _globalBroadcaster.publish(_CONSTANTS.EVENT.DEVICE_SUBSCRIPTION_ENDED, params);
	    }

	    this.isAnonymous = function() {
	        return isAnonymous;
	    };

	    function stopRestartSubscriptionTimer() {
	        clearTimeout(restartSubscriptionTimer);
	        restartSubscriptionTimer = null;
	    }

	    function onNotificationSubscriptionSuccess() {
	        logger.debug("Notification subscription success");
	        if (_fcsConfig.currentNotificationType === nType.WEBSOCKET) {
	            _notificationManager.clearConnection({
	                notificationType: nType.LONGPOLLING
	            });
	        }

	        publishDeviceSubscriptionStartedMessage({
	            "session": session
	        });

	        if (onSubscriptionSuccess) {
	            _utils.callFunctionIfExist(onSubscriptionSuccess);
	            onSubscriptionSuccess = null;
	        }
	    }

	    function stopStartNotificationTimerAfterConnectionReEstablishedTimer() {
	        clearTimeout(startNotificationTimerAfterConnectionReEstablished);
	        startNotificationTimerAfterConnectionReEstablished = null;
	    }

	    function stopExtendNotificationSubscriptionTimer() {
	        logger.debug("extend notification subscription timer is stopped.");
	        clearInterval(extendNotificationSubscriptionTimer);
	        extendNotificationSubscriptionTimer = null;
	    }

	    function stopTimers() {
	        stopExtendNotificationSubscriptionTimer();
	        stopStartNotificationTimerAfterConnectionReEstablishedTimer();
	        stopRestartSubscriptionTimer();
	    }

	    function clearSubscription(params) {
	        logger.debug("Clearing subscription.");
	        notifier = null;
	        clearCache();
	        _notificationManager.clearConnection();
	        stopTimers();
	        publishDeviceSubscriptionEndedMessage(params);
	        if (!params || !params.doNotDeleteConfig) {
	            _fcsConfig.currentNotificationType = undefined;
	        }
	    }

	    function updateOldStyleConfigValues() {
	        if (serverIndex < numberOfServers) {
	            logger.debug("server index: ", serverIndex);
	            logger.debug("updating config values to: ", _fcsConfig.servers[serverIndex]);
	            _fcsConfig.restUrl = _fcsConfig.servers[serverIndex].restUrl;
	            _fcsConfig.restPort = _fcsConfig.servers[serverIndex].restPort;
	            _fcsConfig.protocol = _fcsConfig.servers[serverIndex].protocol;
	            _fcsConfig.websocketIP = _fcsConfig.servers[serverIndex].websocketIP;
	            _fcsConfig.websocketPort = _fcsConfig.servers[serverIndex].websocketPort;
	            _fcsConfig.websocketProtocol = _fcsConfig.servers[serverIndex].websocketProtocol;
	            return true;
	        }

	        return false;
	    }

	    function initializeServerIndex() {
	        serverIndex = 0;
	    }

	    function isThereAnyMoreAvailableServers() {
	        return (serverIndex + 1) < numberOfServers;
	    }

	    function configureNextServer() {
	        ++serverIndex;
	        return updateOldStyleConfigValues();
	    }

	    function clearForOnSubscriptionFailure(err) {
	        logger.debug("Clear for on subscription failure.");
	        if (_fcs.isConnected()) {
	            clearSubscription({
	                resetConnectivity: true
	            });
	            _utils.callFunctionIfExist(onSubscriptionFailure, err);
	        }
	    }

	    function notificationFailureHandler(error) {
	        logger.debug("notification failure: ", error);
	        _utils.callFunctionIfExist(notificationErrorCallback, error);
	    }

	    function hasSubscribed() {
	        return notifier;
	    }

	    function handleLongPollingFailure(err) {
	        logger.debug("Handle long polling failure..");
	        if (useNewStyleConfig && isThereAnyMoreAvailableServers()) {
	            logger.debug("Try next server.");
	            restartSubscription({
	                changeServerCallback: configureNextServer
	            });
	        } else {
	            clearForOnSubscriptionFailure(err);
	        }
	    }

	    function handleWebSocketFailure(err) {
	        logger.debug("Handle web socket failure..");
	        if (useNewStyleConfig && isThereAnyMoreAvailableServers()) {
	            logger.debug("Try next server.");
	            restartSubscription({
	                changeServerCallback: configureNextServer
	            });
	        } else if (_fcsConfig.currentNotificationType === nType.WEBSOCKET) {
	            logger.debug("New server could not be configured. Try long polling.");
	            restartSubscription({
	                newNotificationType: nType.LONGPOLLING,
	                forceDeviceSubscription: true
	            });
	        } else {
	            clearForOnSubscriptionFailure(err);
	        }
	    }

	    function handleWebSocketOnlyFailure(err) {
	        logger.debug("Handle web socket only failure..");
	        if (useNewStyleConfig && isThereAnyMoreAvailableServers()) {
	            logger.debug("Try next server.");
	            restartSubscription({
	                changeServerCallback: configureNextServer
	            });
	        } else {
	            clearForOnSubscriptionFailure(err);
	        }
	    }

	    function subscriptionNotificationFailureHandler(err) {
	        if (_fcsConfig.notificationType === nType.LONGPOLLING) {
	            handleLongPollingFailure(err);
	        } else if (_fcsConfig.notificationType === nType.WEBSOCKET) {
	            handleWebSocketFailure(err);
	        } else if (_fcsConfig.notificationType === nType.WEBSOCKET_ONLY) {
	            handleWebSocketOnlyFailure(err);
	        }
	    }

	    function onNotificationSubscriptionFailure(err) {
	        subscriptionNotificationFailureHandler(err);
	    }

	    function onDeviceSubscriptionFailure(err) {
	        subscriptionNotificationFailureHandler(err);
	    }

	    // Subscribe for getting notifications
	    function deviceSubscribe(forceLogout) {
	        if (!_fcs.isConnected()) {
	            logger.debug("Connection is lost, no need to subscribe...");
	            onDeviceSubscriptionFailure(_fcs.Errors.CONNECTION_ISSUE);
	            return;
	        }

	        stopExtendNotificationSubscriptionTimer();
	        logger.debug("Subscribing...");
	        _service.subscribe(function(subscribeUrl, notificationChannel, exp, poll, assignedService, servicesReceivingNotification, sessionId) {

	            token = null;
	            _fcs.setServices(_fcsConfig.services || assignedService);
	            _fcsConfig.services = _fcsConfig.services || assignedService;
	            _fcsConfig.servicesReceivingNotification = servicesReceivingNotification;
	            _fcsConfig.polling = poll;
	            _fcsConfig.expires = exp;
	            _fcsConfig.extendInterval = exp / 2;
	            notifier = {};
	            notifier.notificationURL = notificationChannel;
	            notifier.notificationId = notificationChannel.substr(notificationChannel.lastIndexOf("/") + 1);
	            notifier.subscriptionURL = subscribeUrl;

	            _cache.setItem(notificationCachePrefix + CACHEIDS.NOTIFYURL, notifier.notificationURL);
	            _cache.setItem(notificationCachePrefix + CACHEIDS.NOTIFYID, notifier.notificationId);
	            _cache.setItem(notificationCachePrefix + CACHEIDS.SUBSCRIBEURL, notifier.subscriptionURL);
	            _cache.setItem(notificationCachePrefix + CACHEIDS.SUBSCRIBEEXPIRY, _fcsConfig.expires);
	            _cache.setItem(notificationCachePrefix + CACHEIDS.SUBSCRIBEEXTENDINTERVAL, _fcsConfig.extendInterval);
	            _cache.setItem(notificationCachePrefix + CACHEIDS.USERNAME, _fcs.getUser());
	            if (sessionId) {
	                session = sessionId;
	                _cache.setItem(notificationCachePrefix + CACHEIDS.SESSION, session);
	            }

	            extendNotificationSubscriptionTimer = setInterval(extendNotificationSubscription, _fcsConfig.extendInterval * 1000);

	            logger.debug("Subscription successfull - notifier: ", notifier);

	            _notificationManager.connect({
	                notificationURL: notificationChannel,
	                onSuccess: onNotificationSubscriptionSuccess,
	                onFailure: onNotificationSubscriptionFailure
	            });

	        }, function(err) {
	            if (err !== _fcs.Errors.CONNECTION_ISSUE) {
	                logger.error("Subscription is failed - error: " + err);

	                onDeviceSubscriptionFailure(err);
	            }
	        }, forceLogout, token);
	    }

	    function clearOnExtendError() {
	        _notificationManager.clearConnection({
	            withNotificationFailure: true
	        });
	        notificationFailureHandler(_CONSTANTS.NOTIFICATION.STATUS.STOP_FOR_RESTART);
	        publishDeviceSubscriptionEndedMessage();
	    }

	    function sendExtendSubscriptionRequest() {
	        if (!_fcs.isConnected()) {
	            logger.debug("Connection is lost, no need to extend subscribe...");
	            return;
	        }

	        stopExtendNotificationSubscriptionTimer();

	        logger.debug("Extending subscription... - subscription URL: ", notifier.subscriptionURL);
	        _service.extendSubscription(notifier.subscriptionURL, function(notificationChannel, assignedService, servicesReceivingNotification) {

	            _fcs.setServices(_fcsConfig.services || assignedService);
	            _fcsConfig.services = _fcsConfig.services || assignedService;
	            _fcsConfig.servicesReceivingNotification = servicesReceivingNotification;
	            notifier.notificationURL = notificationChannel;
	            _cache.setItem(notificationCachePrefix + CACHEIDS.NOTIFYURL, notificationChannel);

	            extendNotificationSubscriptionTimer = setInterval(extendNotificationSubscription, _fcsConfig.extendInterval * 1000);

	            logger.debug("Extending subscription successful - notifier: ", notifier);

	            _notificationManager.connect({
	                notificationURL: notificationChannel,
	                onSuccess: onNotificationSubscriptionSuccess,
	                onFailure: onNotificationSubscriptionFailure
	            });

	        }, function(err) {
	            if (_fcs.isConnected()) {
	                logger.error("Extending subscription is failed - error: " + err);
	                logger.error("Fail reusing existing subscription, re-subscribing.");
	                _globalBroadcaster.publish(_CONSTANTS.EVENT.FORCE_CONNECTIVITY_CHECK);
	                // notify the user first
	                clearOnExtendError();
	                deviceSubscribe();
	            } else {
	                logger.error("Extending subscription is failed and connection is lost - error: " + err);
	            }
	        });
	    }

	    function subscribeToNewServer(changeServerCallback) {
	        clearSubscription({
	            doNotDeleteConfig: true
	        });
	        changeServerCallback();
	        deviceSubscribe();
	    }

	    function handleRestartChangingServer(changeServerCallback) {
	        if (!hasSubscribed()) {
	            changeServerCallback();
	            deviceSubscribe();
	        } else {
	            _service.deleteSubscription(notifier.subscriptionURL,
	                function() {
	                    subscribeToNewServer(changeServerCallback);
	                },
	                function() {
	                    subscribeToNewServer(changeServerCallback);
	                });
	        }
	    }

	    function handleRestartSameServer(forceDeviceSubscription) {
	        if (!hasSubscribed()) {
	            deviceSubscribe();
	        } else {
	            if (forceDeviceSubscription) {
	                _service.deleteSubscription(notifier.subscriptionURL,
	                    function() {
	                        deviceSubscribe();
	                    },
	                    function() {
	                        logger.debug("Un usbscription failed for old subscription with websocket");
	                        deviceSubscribe();
	                    });
	            } else {
	                sendExtendSubscriptionRequest();
	            }
	        }
	    }

	    restartSubscription = function(data) {
	        stopRestartSubscriptionTimer();
	        restartSubscriptionTimer = setTimeout(function() {
	            if (!_fcs.isConnected()) {
	                logger.debug("Connection is lost, no need to restart subscription...");
	                return;
	            }

	            logger.debug("Restarting subscription...");

	            if (data.newNotificationType) {
	                _fcsConfig.currentNotificationType = data.newNotificationType;
	                logger.debug("Current notification type is set as: ", _fcsConfig.currentNotificationType);
	            }

	            if (data.clearConnectionAndNotifiyUser) {
	                _notificationManager.clearConnection({
	                    withNotificationFailure: true
	                });
	                notificationFailureHandler(_CONSTANTS.NOTIFICATION.STATUS.STOP_FOR_RESTART);
	            }

	            if (data.changeServerCallback) {
	                handleRestartChangingServer(data.changeServerCallback);
	            } else {
	                handleRestartSameServer(data.forceDeviceSubscription);
	            }
	        }, Math.random() * _CONSTANTS.TIMEOUT.INTERVAL_TO_PREVENT_CONFLICTS);
	    };

	    function initToFirstServer() {
	        initializeServerIndex();
	        updateOldStyleConfigValues();
	    }

	    function tryRecoveringFromLongPolling() {
	        if (useNewStyleConfig && numberOfServers > 1) {
	            restartSubscription({
	                newNotificationType: nType.WEBSOCKET,
	                clearConnectionAndNotifiyUser: true,
	                changeServerCallback: initToFirstServer
	            });
	        } else {
	            restartSubscription({
	                newNotificationType: nType.WEBSOCKET,
	                clearConnectionAndNotifiyUser: true
	            });
	        }
	    }

	    extendNotificationSubscription = function() {
	        if (!_fcs.isConnected()) {
	            logger.debug("Connection is lost, no need to extend subscribe...");
	            return;
	        }

	        if (hasSubscribed()) {
	            if (_fcsConfig.notificationType === nType.WEBSOCKET &&
	                _fcsConfig.currentNotificationType === nType.LONGPOLLING) {
	                logger.debug("Try recovering from long polling...");
	                tryRecoveringFromLongPolling();
	            } else {
	                sendExtendSubscriptionRequest();
	            }
	        } else {
	            logger.debug("Cannot reuse existing subscription, re-subscribing.");
	            deviceSubscribe();
	        }
	    };

	    this.stop = function(onStopSuccess, onStopFailure, force) {
	        if (!force && !_fcs.isConnected()) {
	            logger.debug("Connection is lost, no need to unsubscribe...");
	            if (typeof onStopFailure === 'function') {
	                onStopFailure(_fcs.Errors.CONNECTION_ISSUE);
	            }
	            return;
	        }

	        logger.debug("Unsubscribing... - notifier: ", notifier);
	        if (hasSubscribed()) {
	            _service.deleteSubscription(notifier.subscriptionURL, function() {
	                logger.debug("Unsubscription successfull");

	                clearSubscription({
	                    resetConnectivity: true
	                });

	                if (typeof onStopSuccess === 'function') {
	                    onStopSuccess();
	                }
	            }, function(err) {
	                if (force) {
	                    logger.debug("Forced Unsubscription successfull");
	                    clearSubscription({
	                        resetConnectivity: true
	                    });
	                    if (typeof onStopSuccess === 'function') {
	                        onStopSuccess();
	                    }
	                } else {
	                    logger.error("Unsubscribe if failed - error:" + err);
	                    if (typeof onStopFailure === 'function') {
	                        onStopFailure();
	                    }
	                }
	            });
	        } else {
	            logger.trace("subscription URL is unknown, cannot send unsubscribe request.");

	            if (typeof onStopSuccess === 'function') {
	                onStopSuccess();
	            }
	        }
	    };

	    function startExtendNotification(forceLogout) {
	        if (!_fcs.isConnected()) {
	            logger.debug("Connection is lost, no need to subscribe...");
	            return;
	        }

	        logger.debug("start - notification subscription...");

	        var nurl = _cache.getItem(notificationCachePrefix + CACHEIDS.NOTIFYURL),
	            nid = _cache.getItem(notificationCachePrefix + CACHEIDS.NOTIFYID),
	            surl = _cache.getItem(notificationCachePrefix + CACHEIDS.SUBSCRIBEURL),
	            exp = _cache.getItem(notificationCachePrefix + CACHEIDS.SUBSCRIBEEXPIRY),
	            extendInterval = _cache.getItem(notificationCachePrefix + CACHEIDS.SUBSCRIBEEXTENDINTERVAL),
	            user = _cache.getItem(notificationCachePrefix + CACHEIDS.USERNAME);

	        logger.debug("start - cached data - nurl: " + nurl +
	            " nid: " + nid + " surl: " + surl +
	            " exp: " + exp + " extendInterval: " + extendInterval + " user: " + user);

	        if (nurl && nid && surl && exp && extendInterval && (_fcs.getUser() === user)) {
	            notifier = {};
	            notifier.notificationURL = nurl;
	            notifier.notificationId = nid;
	            notifier.subscriptionURL = surl;
	            _fcsConfig.expires = exp;
	            _fcsConfig.extendInterval = extendInterval;

	            extendNotificationSubscription();
	        } else {
	            deviceSubscribe(forceLogout);
	        }
	    }

	    function decideNumberOfServers() {
	        numberOfServers = _fcsConfig.servers.length;
	        logger.debug("Number of servers to be tried: ", numberOfServers);
	    }

	    function setupConfiguration() {
	        if (_fcsConfig.servers) {
	            useNewStyleConfig = true;
	            decideNumberOfServers();
	            initializeServerIndex();
	            return updateOldStyleConfigValues();
	        }
	        return true;
	    }

	    function setupInternalVariables(onSuccess, onFailure, anonymous, cachePrefix) {
	        onSubscriptionSuccess = onSuccess;
	        onSubscriptionFailure = onFailure;
	        isAnonymous = anonymous;

	        if (cachePrefix) {
	            notificationCachePrefix = cachePrefix;
	        }
	    }

	    function initializeRequiredConfigVariables() {
	        // Default is long polling
	        if (!_fcsConfig.notificationType) {
	            _fcsConfig.notificationType = nType.LONGPOLLING;
	        }

	        if (_fcsConfig.notificationType === nType.WEBSOCKET_ONLY) {
	            // for server only websocket and longpolling types exist.
	            _fcsConfig.currentNotificationType = nType.WEBSOCKET;
	        } else {
	            _fcsConfig.currentNotificationType = _fcsConfig.notificationType;
	        }
	        logger.debug("Current notification type is set as: ", _fcsConfig.currentNotificationType);

	    }

	    this.start = function(onSuccess, onFailure, anonymous, cachePrefix, forceLogout) {
	        if (!setupConfiguration()) {
	            _utils.callFunctionIfExist(onFailure, _CONSTANTS.NOTIFICATION.STATUS.CONFIGURATION_ERROR);
	            return;
	        }

	        setupInternalVariables(onSuccess, onFailure, anonymous, cachePrefix);
	        initializeRequiredConfigVariables();

	        startExtendNotification(forceLogout);
	    };

	    function hasStarted() {
	        return _fcsConfig.currentNotificationType;
	    }

	    this.extend = function(onSuccess, onFailure) {
	        if (!hasStarted()) {
	            _utils.callFunctionIfExist(onFailure, _CONSTANTS.NOTIFICATION.STATUS.NOT_STARTED);
	            return;
	        }

	        onSubscriptionSuccess = onSuccess;
	        onSubscriptionFailure = onFailure;

	        startExtendNotification();
	    };

	    function handleConnectionEstablished() {
	        stopStartNotificationTimerAfterConnectionReEstablishedTimer();
	        startNotificationTimerAfterConnectionReEstablished = setTimeout(function() {
	            startExtendNotification();
	            if (_fcs.isConnected()) {
	                _utils.callFunctionIfExist(onConnectionEstablished);
	            }
	        }, Math.random() * _CONSTANTS.TIMEOUT.INTERVAL_TO_PREVENT_CONFLICTS);
	    }

	    function handleConnectionLost() {
	        stopTimers();
	        _notificationManager.clearConnection();
	        _utils.callFunctionIfExist(onConnectionLost);
	    }

	    this.setOnConnectionLost = function(callback) {
	        onConnectionLost = callback;
	    };

	    this.setOnConnectionEstablished = function(callback) {
	        onConnectionEstablished = callback;
	    };

	    this.setOnError = function(callback) {
	        notificationErrorCallback = callback;
	    };

	    this.getNotificationId = function() {
	        if (notifier) {
	            return notifier.notificationId;
	        }
	    };

	    _notificationManager.setNotificationFailureCallback({
	        callback: notificationFailureHandler
	    });

	    this.setOnSuccess = function(callback) {
	        notificationSuccessAfterErrorCallback = callback;
	    };

	    _notificationManager.setNotificationSuccessAfterFailureCallback({
	        callback: function() {
	            logger.debug("notification success after notification failure.");
	            _utils.callFunctionIfExist(notificationSuccessAfterErrorCallback);
	        }
	    });

	    this.trigger = function() {
	        logger.debug("Trigger called to fetch notification.");
	        _notificationManager.trigger({
	            notificationUrl: notifier.notificationURL
	        });
	    };

	    function handleGoneNotification(data) {
	        clearSubscription({
	            resetConnectivity: true
	        });
	        clearUserNamePasswordFromCache();
	        _utils.callFunctionIfExist(_fcs.notification.onGoneReceived, data);
	    }

	    function handleTokenOrSessionLoss() {
	        clearSubscription({
	            resetConnectivity: true
	        });
	        clearUserNamePasswordFromCache();
	        _utils.callFunctionIfExist(onSubscriptionFailure, _CONSTANTS.SUBSCRIPTION_EVENT.TOKEN_OR_SESSION_LOSS);
	    }

	    _notificationCallBacks.gone = function(data) {
	        handleGoneNotification(data);
	    };

	    _globalBroadcaster.subscribe(_CONSTANTS.EVENT.CONNECTION_REESTABLISHED, handleConnectionEstablished);
	    _globalBroadcaster.subscribe(_CONSTANTS.EVENT.CONNECTION_LOST, handleConnectionLost);
	    _globalBroadcaster.subscribe(_CONSTANTS.EVENT.TOKEN_AUTH_STARTED, onTokenAuth, 10);
	    _globalBroadcaster.subscribe(_CONSTANTS.EVENT.TOKEN_NOT_FOUND, handleTokenOrSessionLoss);
	    _globalBroadcaster.subscribe(_CONSTANTS.EVENT.SESSION_EXPIRED, handleTokenOrSessionLoss);

	    

	};

	//@{fcs-jsl-prod}
	var SubscriptionManager = function(_fcsConfig, _fcs, _service, _logManager, _globalBroadcaster, _cache, _notificationManager, _utils, _CONSTANTS, _notificationCallBacks) {
	    return new SubscriptionManagerImpl(_fcsConfig || fcsConfig,
	        _fcs || fcs,
	        _service || subscriptionService,
	        _logManager || logManager,
	        _globalBroadcaster || globalBroadcaster,
	        _cache || cache,
	        _notificationManager || notificationManager,
	        _utils || utils,
	        _CONSTANTS || CONSTANTS,
	        _notificationCallBacks || NotificationCallBacks);
	};

	var subscriptionManager = new SubscriptionManager();
	//@{fcs-jsl-prod}



	/**
	 * Manages a user's subscriptions to remote notifications.  A user may subscribe to specific
	 * event types (calls, instant messages, presence updates) using websocket or long polling.
	 *
	 * Note that call/im/presence event handlers must be assigned in other objects before calling
	 * notificationSubscribe/extendNotificationSubscription.
	 *
	 * @name notification
	 * @namespace
	 * @memberOf fcs
	 *
	 * @version 4.2.0
	 * @since 3.0.0
	 *
	 * @see fcs.config#notificationType
	 * @see fcs.im#event:onReceived
	 * @see fcs.call#event:onReceived
	 * @see fcs.presence#event:onReceived
	 *
	 */
	var NotificationImpl = function(_manager) {
	    /**
	     * Called on receipt of a 410 GONE message
	     *
	     * @name fcs.notification#onGoneReceived
	     * @event
	     *
	     * @since 3.0.0
	     *
	     * @example
	     * var goneReceived = function(data){
	     *    // do something here
	     * };
	     *
	     * fcs.notification.onGoneReceived = function() {
	     *     window.console.log("Your service has ended...");
	     *     // navigate to login page, etc...
	     * };
	     */
	    this.onGoneReceived = null;

	    /**
	     * Enum for notification types.
	     *
	     * @name fcs.notification#NotificationTypes
	     * @property {string} LONGPOLLING Long polling type
	     * @property {string} WEBSOCKET WebSocket type
	     * @property {string} WEBSOCKET_ONLY WebSocketOnly type
	     * @readonly
	     */
	    this.NotificationTypes = {
	        LONGPOLLING: "longpolling",
	        WEBSOCKET: "websocket",
	        WEBSOCKET_ONLY: "websocketonly"
	    };

	    /**
	     * Boolean for anonymous users.
	     * Used by rest requests to determine some parameters at URL and body).
	     *
	     * @name fcs.notification#isAnonymous
	     * @return isAnonymous true if the user is anonymous
	     * @since 3.0.0
	     */
	    this.isAnonymous = function() {
	        return _manager.isAnonymous();
	    };

	    /**
	     * Unsubscribe from getting notifications
	     *
	     * @name fcs.notification#stop
	     * @param {function} onSuccess Success callback
	     * @param {function} onFailure The onFailure({@link fcs#Errors}) callback function to be called
	     * @param {boolean} [force] if true, success callback will be called ignoring all failures etc...
	     * @function
	     * @since 3.0.0
	     * @example
	     * fcs.notification.stop(
	     * //Success callback
	     * function(){
	     *     window.console.log("Notification system is stopped successfully!!")
	     * },
	     * //Failure callback
	     * function(){
	     *     window.console.log("Something Wrong Here!!!")
	     * }
	     * );
	     */
	    this.stop = function(onSuccess, onFailure, force) {
	        _manager.stop(onSuccess, onFailure, force);
	    };

	    /**
	     * Subscribe and fetch the notifications <BR />
	     * NOTE: Before subscribing, you have to set handlers for received notification. Only handlers registered before starting the notification will receive events.
	     * @name fcs.notification#start
	     * @param {function} onSuccess Success callback
	     * @param {function} onFailure Failure callback
	     * @param {boolean} anonymous Is this an anonymous
	     * @param {string} cachePrefix Prefix of the cache key to be used (this allows for multiple subscriptions)
	     * @param {string} forceLogout Kills the session of the oldest device.(For more information : User Guide Demo Examples in Api Doc )
	     * @function
	     *
	     * @since 3.0.0
	     *
	     * @example
	     *
	     * //Sets up connection and notification types
	     * fcs.setup({
	     *        "restUrl": "&lt;rest_url&gt;",
	     *        "restPort": "rest_port",
	     *        "websocketIP": "&lt;websocket_ip&gt;",
	     *        "websocketPort": "&lt;websocket_port&gt;",
	     *        "notificationType": "websocket",
	     *        "callAuditTimer": "30000",
	     *        "clientControlled" : true,
	     *        "protocol" : "http",
	     *        "serverProvidedTurnCredentials": "false"
	     *});
	     *
	     * // Login
	     * // User must login SPiDR to be able to receive and make calls
	     * // Login includes authentication and subscription steps. After logging in you can receive notifications
	     * // Provide username and password to the setUserAuth method
	     * var incomingCall,outgoingCall;
	     * fcs.setUserAuth("user@somedomain.com","password");
	     * fcs.notification.start(function(){
	     *       //Initialize media
	     *       fcs.call.initMedia(function(){},function(){},{
	     *                 "pluginLogLevel" : 2,
	     *                 "videoContainer" : "",
	     *                 "pluginMode" : "auto",
	     *                 "iceserver" : [{"url":"stun:206.165.51.23:3478"}]
	     *             });
	     *       fcs.call.onReceived = function(call) {
	     *       //Handle incoming notifications here (incomingCall, callEnd, etc.)
	     *       //window.alert("incoming call");
	     *       //call.onStateChange(state);
	     *       //call.onStreamAdded(streamURL);
	     *       incomingCall=call;
	     *     }
	     * },
	     * function(){
	     * window.console.log("Something Wrong Here!!!")
	     * },
	     * false,false,false
	     * );
	     *
	     */
	    this.start = function(onSuccess, onFailure, anonymous, cachePrefix, forceLogout) {
	        _manager.start(onSuccess, onFailure, anonymous, cachePrefix, forceLogout);
	    };

	    /**
	     * Extending subscription and fetch the notifications
	     *
	     * @name fcs.notification#extend
	     * @param {function} onSuccess Success callback
	     * @param {function} onFailure Failure callback
	     * @function
	     */
	    this.extend = function(onSuccess, onFailure) {
	        _manager.extend(onSuccess, onFailure);
	    };

	    /**
	     * Sets the notification error handler.
	     * This callback is executed when there is an error with notitifcation channel.
	     * Websocket failure etc...
	     *
	     * @name fcs.notification#setOnError
	     * @param {function(error)} callback The failure callback to be called.
	     * @function
	     * @since 3.0.0
	     *
	     * @example
	     *
	     * fcs.notification.setOnError(function() {
	     *    window.console.log("Notification channel lost");
	     *    // block ui and show a loading spinner
	     * });
	     */
	    this.setOnError = function(callback) {
	        _manager.setOnError(callback);
	    };

	    /**
	     * Sets the notification success handler.
	     * This callback is executed once notitifcation channel is re-establised after a failure.
	     *
	     * @name fcs.notification#setOnSuccess
	     * @param {function} callback The success callback to be called.
	     * @function
	     * @since 3.0.0
	     *
	     * @example
	     *
	     * fcs.notification.setOnSuccess(function() {
	     *    window.console.log("Notification channel is re-establibshed");
	     *    // unblock ui and hide loading spinner
	     * });
	     */
	    this.setOnSuccess = function(callback) {
	        _manager.setOnSuccess(callback);
	    };

	    /**
	     * Sets the connection lost handler.
	     * This callback is executed when connection to server is lost.
	     *
	     * @name fcs.notification#setOnConnectionLost
	     * @function
	     * @since 3.0.0
	     *
	     * fcs.notification.setOnConnectionLost(function() {
	     *    window.console.log("Connection lost");
	     *    // block ui and show a loading spinner
	     * });
	     */
	    this.setOnConnectionLost = function(callback) {
	        _manager.setOnConnectionLost(callback);
	    };

	    /**
	     * Sets the connection established handler.
	     * This callback is executed when connection to server is re-established.
	     *
	     * @name fcs.notification#setOnConnectionEstablished
	     * @function
	     * @since 3.0.0
	     *
	     * fcs.notification.setOnConnectionEstablished(function() {
	     *    window.console.log("Connection is re-establibshed");
	     *    // unblock ui and hide loading spinner
	     * });
	     */
	    this.setOnConnectionEstablished = function(callback) {
	        _manager.setOnConnectionEstablished(callback);
	    };

	    /**
	     * @deprecated
	     * Will be used by external triggers to fetch notifications.
	     *
	     * @name fcs.notification#trigger
	     * @function
	     * @since 3.0.0
	     * @example
	     *
	     * fcs.notification.start();
	     *
	     * //Native code received SNMP Trigger so retrieve the notification
	     *
	     * fcs.notification.trigger();
	     *
	     */
	    this.trigger = function() {
	        _manager.trigger();
	    };
	};

	//@{fcs-jsl-prod}
	var NotificationInt = function(_manager) {
	    return new NotificationImpl(_manager || subscriptionManager);
	};

	fcs.notification = new NotificationInt(subscriptionManager);
	//@{fcs-jsl-prod}



	/*
	 * Finite State machine that defines state transition of basic call model.
	 * State machine fires events during state transitions.
	 * Components should register to FSM  in order to receive transition events
	 *
	 */

	var CallFSMImpl = function(_logManager) {

	    this.CallFSMState = {
	        INIT: "INIT",
	        RINGING: "RINGING",
	        TRYING: "TRYING",
	        ANSWERING: "ANSWERING",
	        COMPLETED: "COMPLETED",
	        RINGING_SLOW: "RINGING_SLOW",
	        LOCAL_HOLD: "LOCAL_HOLD",
	        LOCAL_HOLDING: "LOCAL_HOLDING",
	        LOCAL_UNHOLDING: "LOCAL_UNHOLDING",
	        LOCAL_VIDEO_STOP_START: "LOCAL_VIDEO_STOP_START",
	        REMOTE_OFFER: "REMOTE_OFFER",
	        REMOTE_HOLD: "REMOTE_HOLD",
	        REMOTE_HOLDING: "REMOTE_HOLDING",
	        REMOTE_UNHOLDING: "REMOTE_UNHOLDING",
	        BOTH_HOLD: "BOTH_HOLD",
	        JOINING: "JOINING",
	        PROVISIONRECEIVED: "PROVISIONRECEIVED",
	        REFER: "REFER",
	        TRANSFERING: "TRANSFERING",
	        LOCAL_SLOW_START_OFFER: "LOCAL_SLOW_START_OFFER",
	        LOCAL_REOFFER: "LOCAL_REOFFER",
	        REPLACING: "REPLACING",
	        LOCAL_REJECTING: "LOCAL_REJECTING",
	        LOCAL_ENDING: "LOCAL_ENDING"
	    };

	    //CallFSM returns TransferEvent after state change
	    this.TransferEvent = {
	        unknownNotification_fsm: "unknownNotification_fsm",
	        ignoredNotification_fsm: "ignoredNotification_fsm",
	        callStart_fsm: "callStart_fsm",
	        callReceived_fsm: "callReceived_fsm",
	        answer_fsm: "answer_fsm",
	        reject_GUI: "reject_GUI",
	        rejectWithoutClearCallObject_GUI: "rejectWithoutClearCallObject_GUI",
	        ignore_GUI: "ignore_GUI",
	        callCompleted_fsm: "callCompleted_fsm",
	        noAnswer_fsm: "noAnswer_fsm",
	        localEnding_fsm: "localEnding_fsm",
	        localEndingWithoutClearCallObject_fsm: "localEndingWithoutClearCallObject_fsm",
	        localEnd_fsm: "localEnd_fsm",
	        localReject_fsm: "localReject_fsm",
	        remoteEnd_fsm: "remoteEnd_fsm",
	        answeringRingingSlow_fsm: "answeringRingingSlow_fsm",
	        callCompletedAnswering_fsm: "callCompletedAnswering_fsm",
	        localHold_fsm: "localHold_fsm",
	        localHolding_fsm: "localHolding_fsm",
	        remoteHold_fsm: "remoteHold_fsm",
	        remoteHolding_fsm: "remoteHolding_fsm",
	        localUnHold_fsm: "localUnHold_fsm",
	        localUnHolding_fsm: "localUnHolding_fsm",
	        remoteUnHold_fsm: "remoteUnHold_fsm",
	        remoteUnHolding_fsm: "remoteUnHolding_fsm",
	        localVideoStopStart_fsm: "localVideoStopStart_fsm",
	        remoteOffer_fsm: "remoteOffer_fsm",
	        joining_fsm: "joining_fsm",
	        sessionComplete_fsm: "sessionComplete_fsm",
	        joiningSuccess_fsm: "joiningSuccess_fsm",
	        sessionFail_fsm: "sessionFail_fsm",
	        ringing_fsm: "ringing_fsm",
	        respondCallUpdate_fsm: "respondCallUpdate_fsm",
	        remoteCallUpdate_fsm: "remoteCallUpdate_fsm",
	        remotePranswer_fsm: "remotePranswer_fsm",
	        forward_fsm: "forward_fsm",
	        refer_fsm: "refer_fsm",
	        accepted_fsm: "accepted_fsm",
	        transfering_fsm: "transfering_fsm",
	        transferSuccess_fsm: "transferSuccess_fsm",
	        transferFail_fsm: "transferFail_fsm",
	        respondCallHoldUpdate_fsm: "respondCallHoldUpdate_fsm",
	        remoteOfferDuringLocalHold_fsm: "remoteOfferDuringHold_fsm",
	        renegotiationCompleted_fsm: "renegotiationCompleted_fsm",
	        slowStartOfferDuringRemoteHold_fsm: "slowStartOfferDuringRemoteHold_fsm",
	        slowStartOfferDuringOnCall_fsm: "slowStartOfferDuringOnCall_fsm",
	        stateReverted_fsm: "stateReverted_fsm",
	        glareCondition_fsm: "glareCondition_fsm",
	        slowStartOfferProcessed_fsm: "slowStartOfferProcessed_fsm",
	        performReconnectWorkaround_fsm: "performReconnectWorkaround_fsm",
	        consultativeTransfer_fsm: "consultativeTransfer_fsm",
	        performCreateNewPeerWorkaround_fsm: "performCreateNewPeerWorkaround_fsm",
	        startCallReplace_fsm: "startCallReplace_fsm",
	        startCallReplaceRejected_fsm: "startCallReplaceRejected_fsm",
	        respondedFromAnotherDevice_fsm: "respondedFromAnotherDevice_fsm",
	        deviceChange_fsm: "deviceChange_fsm"
	    };

	    //CallFSM receives NotificationEvent
	    this.NotificationEvent = {
	        callStart_GUI: "callStart_GUI",
	        callNotify: "callNotify",
	        ringing_Notify: "ringing_Notify",
	        answer_GUI: "answer_GUI",
	        end_GUI: "end_GUI",
	        respondCallUpdate_Notify: "respondCallUpdate_Notify",
	        respondCallUpdate_glareCondition_Notify: "respondCallUpdate_glareCondition_Notify",
	        callCompleted_fsm: "callCompleted_fsm",
	        callEnd_Notify: "callEnd_Notify",
	        callNotify_noSDP: "callNotify_noSDP",
	        startCallUpdate_slowStart_Notify: "startCallUpdate_slowStart_Notify",
	        startCallUpdate_remoteHold_Notify: "startCallUpdate_remoteHold_Notify",
	        startCallUpdate_remoteOffer_Notify: "startCallUpdate_remoteOffer_Notify",
	        joining_Notify: "joining_Notify",
	        sessionComplete_Notify: "sessionComplete_Notify",
	        joiningSuccess_Notify: "joiningSuccess_Notify",
	        sessionFail_Notify: "sessionFail_Notify",
	        hold_GUI: "hold_GUI",
	        unhold_GUI: "unhold_GUI",
	        videoStopStart_GUI: "videoStopStart_GUI",
	        sessionProgress: "sessionProgress",
	        callCancel_Notify: "callCancel_Notify",
	        forward_GUI: "forward_GUI",
	        refer_JSL: "refer_JSL",
	        accepted_Notify: "accepted_Notify",
	        transfering: "transfering",
	        requestFailure_JSL: "requestFailure_JSL",
	        webrtcFailure_JSL: "webrtcFailure_JSL",
	        remoteOfferProcessed_JSL: "remoteOfferProcessed_JSL",
	        remoteHoldProcessed_JSL: "remoteHoldProcessed_JSL",
	        remoteUnHoldProcessed_JSL: "remoteUnHoldProcessed_JSL",
	        slowStartOfferProcessed_JSL: "slowStartOfferProcessed_JSL",
	        performReconnectWorkaround_JSL: "performReconnectWorkaround_JSL",
	        consultativeTransfer_GUI: "consultativeTransfer_GUI",
	        performCreateNewPeerWorkaround_JSL: "performCreateNewPeerWorkaround_JSL",
	        startCallReplace_Notify: "startCallReplace_Notify",
	        endReject_GUI: "endReject_GUI",
	        endIgnore_GUI: "endIgnore_GUI",
	        revertState_JSL: "revertState_JSL",
	        deviceChange_GUI: "deviceChange_GUI"
	    };

	    var self = this,
	        logger = _logManager.getLogger("callFsm");

	    function FSM(call, event, onSuccess, onFailure) {
	        var callState = self.getCurrentState(call);
	        switch (callState) {
	            case self.CallFSMState.INIT:
	                switch (event) {
	                    case self.NotificationEvent.callStart_GUI:
	                        call.currentState = self.CallFSMState.TRYING;
	                        onSuccess(call, self.TransferEvent.callStart_fsm);
	                        break;
	                    case self.NotificationEvent.callNotify:
	                        call.currentState = self.CallFSMState.RINGING;
	                        onSuccess(call, self.TransferEvent.callReceived_fsm);
	                        break;
	                    case self.NotificationEvent.callNotify_noSDP:
	                        call.currentState = self.CallFSMState.RINGING_SLOW;
	                        onSuccess(call, self.TransferEvent.callReceived_fsm);
	                        break;
	                    case self.NotificationEvent.joiningSuccess_Notify:
	                        call.currentState = self.CallFSMState.PROVISIONRECEIVED;
	                        onSuccess(call, self.TransferEvent.joiningSuccess_fsm);
	                        break;
	                    default:
	                        onFailure(call, self.TransferEvent.unknownNotification_fsm);
	                        break;
	                }
	                break;
	            case self.CallFSMState.REPLACING:
	                switch (event) {
	                    case self.NotificationEvent.startCallReplace_Notify:
	                        onSuccess(call, self.TransferEvent.startCallReplace_fsm);
	                        break;
	                    case self.NotificationEvent.end_GUI:
	                        call.currentState = self.CallFSMState.INIT;
	                        onSuccess(call, self.TransferEvent.startCallReplaceRejected_fsm);
	                        break;
	                    case self.NotificationEvent.callEnd_Notify:
	                    case self.NotificationEvent.callCancel_Notify:
	                        call.currentState = self.CallFSMState.INIT;
	                        onSuccess(call, self.TransferEvent.startCallReplaceRejected_fsm);
	                        break;
	                    case self.NotificationEvent.sessionProgress:
	                    case self.NotificationEvent.ringing_Notify:
	                        onSuccess(call, self.TransferEvent.ringing_fsm);
	                        break;
	                    case self.NotificationEvent.respondCallUpdate_Notify:
	                        call.currentState = self.CallFSMState.COMPLETED;
	                        onSuccess(call, self.TransferEvent.callCompleted_fsm);
	                        break;
	                }
	                break;
	            case self.CallFSMState.RINGING:
	                switch (event) {
	                    case self.NotificationEvent.answer_GUI:
	                        call.currentState = self.CallFSMState.COMPLETED;
	                        onSuccess(call, self.TransferEvent.answer_fsm);
	                        break;
	                    case self.NotificationEvent.endReject_GUI:
	                        call.currentState = self.CallFSMState.LOCAL_REJECTING;
	                        onSuccess(call, self.TransferEvent.rejectWithoutClearCallObject_GUI);
	                        break;
	                    case self.NotificationEvent.endIgnore_GUI:
	                        call.currentState = self.CallFSMState.INIT;
	                        onSuccess(call, self.TransferEvent.ignore_GUI);
	                        break;
	                    case self.NotificationEvent.callNotify_noSDP:
	                        call.currentState = self.CallFSMState.RINGING_SLOW;
	                        onSuccess(call, self.TransferEvent.callReceived_fsm);
	                        break;
	                    case self.NotificationEvent.callEnd_Notify:
	                        call.currentState = self.CallFSMState.INIT;
	                        onSuccess(call, self.TransferEvent.remoteEnd_fsm);
	                        break;
	                    case self.NotificationEvent.callCancel_Notify:
	                        call.currentState = self.CallFSMState.INIT;
	                        onSuccess(call, self.TransferEvent.respondedFromAnotherDevice_fsm);
	                        break;
	                    case self.NotificationEvent.forward_GUI:
	                        call.currentState = self.CallFSMState.INIT;
	                        onSuccess(call, self.TransferEvent.forward_fsm);
	                        break;
	                    default:
	                        onFailure(call, self.TransferEvent.unknownNotification_fsm);
	                        break;
	                }
	                break;
	            case self.CallFSMState.RINGING_SLOW:
	                switch (event) {
	                    case self.NotificationEvent.answer_GUI:
	                        call.currentState = self.CallFSMState.ANSWERING;
	                        onSuccess(call, self.TransferEvent.answerRingingSlow_fsm);
	                        break;
	                    case self.NotificationEvent.endReject_GUI:
	                        call.currentState = self.CallFSMState.INIT;
	                        onSuccess(call, self.TransferEvent.reject_GUI);
	                        break;
	                    case self.NotificationEvent.callEnd_Notify:
	                    case self.NotificationEvent.callCancel_Notify:
	                        call.currentState = self.CallFSMState.INIT;
	                        onSuccess(call, self.TransferEvent.remoteEnd_fsm);
	                        break;
	                    case self.NotificationEvent.forward_GUI:
	                        call.currentState = self.CallFSMState.INIT;
	                        onSuccess(call, self.TransferEvent.forward_fsm);
	                        break;
	                    default:
	                        onFailure(call, self.TransferEvent.unknownNotification_fsm);
	                        break;
	                }
	                break;
	            case self.CallFSMState.ANSWERING:
	                switch (event) {
	                    case self.NotificationEvent.respondCallUpdate_Notify:
	                        call.currentState = self.CallFSMState.COMPLETED;
	                        onSuccess(call, self.TransferEvent.callCompletedAnswering_fsm);
	                        break;
	                    case self.NotificationEvent.end_GUI:
	                        call.currentState = self.CallFSMState.INIT;
	                        onSuccess(call, self.TransferEvent.localEnding_fsm);
	                        break;
	                    case self.NotificationEvent.callEnd_Notify:
	                        call.currentState = self.CallFSMState.INIT;
	                        onSuccess(call, self.TransferEvent.remoteEnd_fsm);
	                        break;
	                    default:
	                        onFailure(call, self.TransferEvent.unknownNotification_fsm);
	                        break;
	                }
	                break;
	            case self.CallFSMState.TRYING:
	                switch (event) {
	                    case self.NotificationEvent.sessionProgress:
	                        call.currentState = self.CallFSMState.PROVISIONRECEIVED;
	                        onSuccess(call, self.TransferEvent.remotePranswer_fsm);
	                        break;
	                    case self.NotificationEvent.ringing_Notify:
	                        call.currentState = self.CallFSMState.PROVISIONRECEIVED;
	                        onSuccess(call, self.TransferEvent.ringing_fsm);
	                        break;
	                    case self.NotificationEvent.end_GUI:
	                        call.currentState = self.CallFSMState.INIT;
	                        onSuccess(call, self.TransferEvent.localEnding_fsm);
	                        break;
	                    case self.NotificationEvent.callEnd_Notify:
	                        call.currentState = self.CallFSMState.INIT;
	                        onSuccess(call, self.TransferEvent.noAnswer_fsm);
	                        break;
	                    case self.NotificationEvent.respondCallUpdate_Notify:
	                        call.currentState = self.CallFSMState.COMPLETED;
	                        onSuccess(call, self.TransferEvent.callCompleted_fsm);
	                        break;
	                    default:
	                        onFailure(call, self.TransferEvent.unknownNotification_fsm);
	                        break;
	                }
	                break;
	            case self.CallFSMState.PROVISIONRECEIVED:
	                switch (event) {
	                    case self.NotificationEvent.respondCallUpdate_Notify:
	                        call.currentState = self.CallFSMState.COMPLETED;
	                        onSuccess(call, self.TransferEvent.callCompleted_fsm);
	                        break;
	                    case self.NotificationEvent.end_GUI:
	                        call.currentState = self.CallFSMState.LOCAL_ENDING;
	                        onSuccess(call, self.TransferEvent.localEndingWithoutClearCallObject_fsm);
	                        break;
	                    case self.NotificationEvent.callEnd_Notify:
	                        call.currentState = self.CallFSMState.INIT;
	                        onSuccess(call, self.TransferEvent.remoteEnd_fsm);
	                        break;
	                    case self.NotificationEvent.ringing_Notify:
	                        onSuccess(call, self.TransferEvent.ringing_fsm);
	                        break;
	                    case self.NotificationEvent.sessionProgress:
	                        onSuccess(call, self.TransferEvent.remotePranswer_fsm);
	                        break;
	                    default:
	                        onFailure(call, self.TransferEvent.unknownNotification_fsm);
	                        break;
	                }
	                break;
	            case self.CallFSMState.COMPLETED:
	                switch (event) {
	                    case self.NotificationEvent.end_GUI:
	                        call.currentState = self.CallFSMState.INIT;
	                        onSuccess(call, self.TransferEvent.localEnding_fsm);
	                        break;
	                    case self.NotificationEvent.callEnd_Notify:
	                        call.currentState = self.CallFSMState.INIT;
	                        onSuccess(call, self.TransferEvent.remoteEnd_fsm);
	                        break;
	                    case self.NotificationEvent.startCallUpdate_remoteHold_Notify:
	                        call.previousState = call.currentState;
	                        call.currentState = self.CallFSMState.REMOTE_HOLDING;
	                        onSuccess(call, self.TransferEvent.remoteHolding_fsm);
	                        break;
	                    case self.NotificationEvent.startCallUpdate_slowStart_Notify:
	                        call.previousState = call.currentState;
	                        call.currentState = self.CallFSMState.LOCAL_SLOW_START_OFFER;
	                        onSuccess(call, self.TransferEvent.slowStartOfferDuringOnCall_fsm);
	                        break;
	                    case self.NotificationEvent.hold_GUI:
	                        call.previousState = call.currentState;
	                        call.currentState = self.CallFSMState.LOCAL_HOLDING;
	                        onSuccess(call, self.TransferEvent.localHolding_fsm);
	                        break;
	                    case self.NotificationEvent.videoStopStart_GUI:
	                        call.previousState = call.currentState;
	                        call.currentState = self.CallFSMState.LOCAL_VIDEO_STOP_START;
	                        onSuccess(call, self.TransferEvent.localVideoStopStart_fsm);
	                        break;
	                    case self.NotificationEvent.startCallUpdate_remoteOffer_Notify:
	                        call.previousState = call.currentState;
	                        call.currentState = self.CallFSMState.REMOTE_OFFER;
	                        onSuccess(call, self.TransferEvent.remoteOffer_fsm);
	                        break;
	                    case self.NotificationEvent.transfering:
	                        call.previousState = call.currentState;
	                        call.currentState = self.CallFSMState.TRANSFERING;
	                        onSuccess(call, self.TransferEvent.transfering_fsm);
	                        break;
	                    case self.NotificationEvent.callCancel_Notify:
	                        onSuccess(call, self.TransferEvent.ignoredNotification_fsm);
	                        break;
	                    case self.NotificationEvent.performReconnectWorkaround_JSL:
	                        call.previousState = call.currentState;
	                        call.currentState = self.CallFSMState.LOCAL_REOFFER;
	                        onSuccess(call, self.TransferEvent.performReconnectWorkaround_fsm);
	                        break;
	                    case self.NotificationEvent.performCreateNewPeerWorkaround_JSL:
	                        call.previousState = call.currentState;
	                        call.currentState = self.CallFSMState.LOCAL_REOFFER;
	                        onSuccess(call, self.TransferEvent.performCreateNewPeerWorkaround_fsm);
	                        break;
	                    case self.NotificationEvent.deviceChange_GUI:
	                        call.previousState = call.currentState;
	                        call.currentState = self.CallFSMState.LOCAL_REOFFER;
	                        onSuccess(call, self.TransferEvent.deviceChange_fsm);
	                        break;
	                    default:
	                        onFailure(call, self.TransferEvent.unknownNotification_fsm);
	                        break;
	                }
	                break;
	            case self.CallFSMState.LOCAL_REOFFER:
	                switch (event) {
	                    case self.NotificationEvent.end_GUI:
	                        call.currentState = self.CallFSMState.INIT;
	                        onSuccess(call, self.TransferEvent.localEnding_fsm);
	                        break;
	                    case self.NotificationEvent.callEnd_Notify:
	                        call.currentState = self.CallFSMState.INIT;
	                        onSuccess(call, self.TransferEvent.remoteEnd_fsm);
	                        break;
	                    case self.NotificationEvent.respondCallUpdate_Notify:
	                        call.currentState = call.previousState;
	                        onSuccess(call, self.TransferEvent.respondCallUpdate_fsm);
	                        break;
	                    case self.NotificationEvent.webrtcFailure_JSL:
	                    case self.NotificationEvent.requestFailure_JSL:
	                        call.currentState = call.previousState;
	                        onSuccess(call, self.TransferEvent.stateReverted_fsm);
	                        break;
	                    default:
	                        onFailure(call, self.TransferEvent.unknownNotification_fsm);
	                        break;
	                }
	                break;
	            case self.CallFSMState.REMOTE_OFFER:
	                switch (event) {
	                    case self.NotificationEvent.end_GUI:
	                        call.currentState = self.CallFSMState.INIT;
	                        onSuccess(call, self.TransferEvent.localEnding_fsm);
	                        break;
	                    case self.NotificationEvent.callEnd_Notify:
	                        call.currentState = self.CallFSMState.INIT;
	                        onSuccess(call, self.TransferEvent.remoteEnd_fsm);
	                        break;
	                    case self.NotificationEvent.remoteOfferProcessed_JSL:
	                        call.currentState = call.previousState;
	                        onSuccess(call, self.TransferEvent.renegotiationCompleted_fsm);
	                        break;
	                    case self.NotificationEvent.requestFailure_JSL:
	                    case self.NotificationEvent.webrtcFailure_JSL:
	                        call.currentState = call.previousState;
	                        onSuccess(call, self.TransferEvent.stateReverted_fsm);
	                        break;
	                    default:
	                        onFailure(call, self.TransferEvent.unknownNotification_fsm);
	                        break;
	                }
	                break;
	            case self.CallFSMState.LOCAL_VIDEO_STOP_START:
	                switch (event) {
	                    case self.NotificationEvent.end_GUI:
	                        call.currentState = self.CallFSMState.INIT;
	                        onSuccess(call, self.TransferEvent.localEnding_fsm);
	                        break;
	                    case self.NotificationEvent.callEnd_Notify:
	                        call.currentState = self.CallFSMState.INIT;
	                        onSuccess(call, self.TransferEvent.remoteEnd_fsm);
	                        break;
	                    case self.NotificationEvent.respondCallUpdate_Notify:
	                        call.currentState = call.previousState;
	                        onSuccess(call, self.TransferEvent.respondCallUpdate_fsm);
	                        break;
	                    case self.NotificationEvent.requestFailure_JSL:
	                    case self.NotificationEvent.webrtcFailure_JSL:
	                        call.currentState = call.previousState;
	                        onSuccess(call, self.TransferEvent.stateReverted_fsm);
	                        break;
	                    case self.NotificationEvent.respondCallUpdate_glareCondition_Notify:
	                        call.currentState = call.previousState;
	                        onSuccess(call, self.TransferEvent.glareCondition_fsm);
	                        break;
	                    default:
	                        onFailure(call, self.TransferEvent.unknownNotification_fsm);
	                        break;
	                }
	                break;
	            case self.CallFSMState.LOCAL_HOLDING:
	                switch (event) {
	                    case self.NotificationEvent.end_GUI:
	                        call.currentState = self.CallFSMState.INIT;
	                        onSuccess(call, self.TransferEvent.localEnding_fsm);
	                        break;
	                    case self.NotificationEvent.callEnd_Notify:
	                        call.currentState = self.CallFSMState.INIT;
	                        onSuccess(call, self.TransferEvent.remoteEnd_fsm);
	                        break;
	                    case self.NotificationEvent.respondCallUpdate_Notify:
	                        call.currentState = self.CallFSMState.LOCAL_HOLD;
	                        if (call.previousState === self.CallFSMState.REMOTE_HOLD) {
	                            call.currentState = self.CallFSMState.BOTH_HOLD;
	                        }
	                        call.previousState = callState;
	                        onSuccess(call, self.TransferEvent.respondCallHoldUpdate_fsm);
	                        break;
	                    case self.NotificationEvent.requestFailure_JSL:
	                    case self.NotificationEvent.webrtcFailure_JSL:
	                        call.currentState = call.previousState;
	                        onSuccess(call, self.TransferEvent.stateReverted_fsm);
	                        break;
	                    case self.NotificationEvent.respondCallUpdate_glareCondition_Notify:
	                        call.currentState = call.previousState;
	                        onSuccess(call, self.TransferEvent.glareCondition_fsm);
	                        break;
	                    default:
	                        onFailure(call, self.TransferEvent.unknownNotification_fsm);
	                        break;
	                }
	                break;
	            case self.CallFSMState.LOCAL_UNHOLDING:
	                switch (event) {
	                    case self.NotificationEvent.end_GUI:
	                        call.currentState = self.CallFSMState.INIT;
	                        onSuccess(call, self.TransferEvent.localEnding_fsm);
	                        break;
	                    case self.NotificationEvent.callEnd_Notify:
	                        call.currentState = self.CallFSMState.INIT;
	                        onSuccess(call, self.TransferEvent.remoteEnd_fsm);
	                        break;
	                    case self.NotificationEvent.respondCallUpdate_Notify:
	                        call.currentState = self.CallFSMState.COMPLETED;
	                        if (call.previousState === self.CallFSMState.BOTH_HOLD) {
	                            call.currentState = self.CallFSMState.REMOTE_HOLD;
	                        }
	                        call.previousState = callState;
	                        onSuccess(call, self.TransferEvent.respondCallHoldUpdate_fsm);
	                        break;
	                    case self.NotificationEvent.requestFailure_JSL:
	                    case self.NotificationEvent.webrtcFailure_JSL:
	                        call.currentState = call.previousState;
	                        onSuccess(call, self.TransferEvent.stateReverted_fsm);
	                        break;
	                    case self.NotificationEvent.respondCallUpdate_glareCondition_Notify:
	                        call.currentState = call.previousState;
	                        onSuccess(call, self.TransferEvent.glareCondition_fsm);
	                        break;
	                    default:
	                        onFailure(call, self.TransferEvent.unknownNotification_fsm);
	                        break;
	                }
	                break;
	            case self.CallFSMState.LOCAL_HOLD:
	                switch (event) {
	                    case self.NotificationEvent.end_GUI:
	                        call.currentState = self.CallFSMState.INIT;
	                        onSuccess(call, self.TransferEvent.localEnding_fsm);
	                        break;
	                    case self.NotificationEvent.callEnd_Notify:
	                        call.currentState = self.CallFSMState.INIT;
	                        onSuccess(call, self.TransferEvent.remoteEnd_fsm);
	                        break;
	                    case self.NotificationEvent.startCallUpdate_remoteHold_Notify:
	                        call.previousState = call.currentState;
	                        call.currentState = self.CallFSMState.REMOTE_HOLDING;
	                        onSuccess(call, self.TransferEvent.remoteHolding_fsm);
	                        break;
	                    case self.NotificationEvent.startCallUpdate_remoteOffer_Notify:
	                        onSuccess(call, self.TransferEvent.remoteOfferDuringLocalHold_fsm);
	                        break;
	                    case self.NotificationEvent.unhold_GUI:
	                        call.previousState = call.currentState;
	                        call.currentState = self.CallFSMState.LOCAL_UNHOLDING;
	                        onSuccess(call, self.TransferEvent.localUnHolding_fsm);
	                        break;
	                    case self.NotificationEvent.joining_Notify:
	                        call.previousState = call.currentState;
	                        call.currentState = self.CallFSMState.JOINING;
	                        onSuccess(call, self.TransferEvent.joining_fsm);
	                        break;
	                    case self.NotificationEvent.transfering:
	                        call.previousState = call.currentState;
	                        call.currentState = self.CallFSMState.TRANSFERING;
	                        onSuccess(call, self.TransferEvent.transfering_fsm);
	                        break;
	                    case self.NotificationEvent.performReconnectWorkaround_JSL:
	                        call.previousState = call.currentState;
	                        call.currentState = self.CallFSMState.LOCAL_REOFFER;
	                        onSuccess(call, self.TransferEvent.performReconnectWorkaround_fsm);
	                        break;
	                    case self.NotificationEvent.consultativeTransfer_GUI:
	                        call.previousState = call.currentState;
	                        call.currentState = self.CallFSMState.TRANSFERING;
	                        onSuccess(call, self.TransferEvent.transfering_fsm);
	                        break;
	                    default:
	                        onFailure(call, self.TransferEvent.unknownNotification_fsm);
	                        break;
	                }
	                break;
	            case self.CallFSMState.REMOTE_HOLDING:
	                switch (event) {
	                    case self.NotificationEvent.end_GUI:
	                        call.currentState = self.CallFSMState.INIT;
	                        onSuccess(call, self.TransferEvent.localEnding_fsm);
	                        break;
	                    case self.NotificationEvent.callEnd_Notify:
	                        call.currentState = self.CallFSMState.INIT;
	                        onSuccess(call, self.TransferEvent.remoteEnd_fsm);
	                        break;
	                    case self.NotificationEvent.remoteHoldProcessed_JSL:
	                        call.currentState = self.CallFSMState.REMOTE_HOLD;
	                        if (call.previousState === self.CallFSMState.LOCAL_HOLD) {
	                            call.currentState = self.CallFSMState.BOTH_HOLD;
	                        }
	                        call.previousState = callState;
	                        onSuccess(call, self.TransferEvent.remoteHold_fsm);
	                        break;
	                    case self.NotificationEvent.requestFailure_JSL:
	                    case self.NotificationEvent.webrtcFailure_JSL:
	                        call.currentState = call.previousState;
	                        onSuccess(call, self.TransferEvent.stateReverted_fsm);
	                        break;
	                    default:
	                        onFailure(call, self.TransferEvent.unknownNotification_fsm);
	                        break;
	                }
	                break;
	            case self.CallFSMState.REMOTE_UNHOLDING:
	                switch (event) {
	                    case self.NotificationEvent.end_GUI:
	                        call.currentState = self.CallFSMState.INIT;
	                        onSuccess(call, self.TransferEvent.localEnding_fsm);
	                        break;
	                    case self.NotificationEvent.callEnd_Notify:
	                        call.currentState = self.CallFSMState.INIT;
	                        onSuccess(call, self.TransferEvent.remoteEnd_fsm);
	                        break;
	                    case self.NotificationEvent.remoteUnHoldProcessed_JSL:
	                        call.currentState = self.CallFSMState.COMPLETED;
	                        if (call.previousState === self.CallFSMState.BOTH_HOLD) {
	                            call.currentState = self.CallFSMState.LOCAL_HOLD;
	                        }
	                        call.previousState = callState;
	                        onSuccess(call, self.TransferEvent.remoteUnHold_fsm);
	                        break;
	                    case self.NotificationEvent.requestFailure_JSL:
	                    case self.NotificationEvent.webrtcFailure_JSL:
	                        call.currentState = call.previousState;
	                        onSuccess(call, self.TransferEvent.stateReverted_fsm);
	                        break;
	                    default:
	                        onFailure(call, self.TransferEvent.unknownNotification_fsm);
	                        break;
	                }
	                break;
	            case self.CallFSMState.REMOTE_HOLD:
	                switch (event) {
	                    case self.NotificationEvent.end_GUI:
	                        call.currentState = self.CallFSMState.INIT;
	                        onSuccess(call, self.TransferEvent.localEnding_fsm);
	                        break;
	                    case self.NotificationEvent.callEnd_Notify:
	                        call.currentState = self.CallFSMState.INIT;
	                        onSuccess(call, self.TransferEvent.remoteEnd_fsm);
	                        break;
	                    case self.NotificationEvent.startCallUpdate_remoteHold_Notify:
	                        call.previousState = call.currentState;
	                        call.currentState = self.CallFSMState.REMOTE_HOLDING;
	                        onSuccess(call, self.TransferEvent.remoteHolding_fsm);
	                        break;
	                    case self.NotificationEvent.startCallUpdate_remoteOffer_Notify:
	                        call.previousState = call.currentState;
	                        call.currentState = self.CallFSMState.REMOTE_UNHOLDING;
	                        onSuccess(call, self.TransferEvent.remoteUnHolding_fsm);
	                        break;
	                    case self.NotificationEvent.startCallUpdate_slowStart_Notify:
	                        call.previousState = call.currentState;
	                        call.currentState = self.CallFSMState.LOCAL_SLOW_START_OFFER;
	                        onSuccess(call, self.TransferEvent.slowStartOfferDuringRemoteHold_fsm);
	                        break;
	                    case self.NotificationEvent.hold_GUI:
	                        call.previousState = call.currentState;
	                        call.currentState = self.CallFSMState.LOCAL_HOLDING;
	                        onSuccess(call, self.TransferEvent.localHolding_fsm);
	                        break;
	                    case self.NotificationEvent.joining_Notify:
	                        call.previousState = call.currentState;
	                        call.currentState = self.CallFSMState.JOINING;
	                        onSuccess(call, self.TransferEvent.joining_fsm);
	                        break;
	                    case self.NotificationEvent.performReconnectWorkaround_JSL:
	                        call.previousState = call.currentState;
	                        call.currentState = self.CallFSMState.LOCAL_REOFFER;
	                        onSuccess(call, self.TransferEvent.performReconnectWorkaround_fsm);
	                        break;
	                    default:
	                        onFailure(call, self.TransferEvent.unknownNotification_fsm);
	                        break;
	                }
	                break;
	            case self.CallFSMState.BOTH_HOLD:
	                switch (event) {
	                    case self.NotificationEvent.end_GUI:
	                        call.currentState = self.CallFSMState.INIT;
	                        onSuccess(call, self.TransferEvent.localEnding_fsm);
	                        break;
	                    case self.NotificationEvent.callEnd_Notify:
	                        call.currentState = self.CallFSMState.INIT;
	                        onSuccess(call, self.TransferEvent.remoteEnd_fsm);
	                        break;
	                    case self.NotificationEvent.startCallUpdate_remoteHold_Notify:
	                    case self.NotificationEvent.startCallUpdate_remoteOffer_Notify:
	                        call.previousState = call.currentState;
	                        call.currentState = self.CallFSMState.REMOTE_UNHOLDING;
	                        onSuccess(call, self.TransferEvent.remoteUnHolding_fsm);
	                        break;
	                    case self.NotificationEvent.unhold_GUI:
	                        call.previousState = call.currentState;
	                        call.currentState = self.CallFSMState.LOCAL_UNHOLDING;
	                        onSuccess(call, self.TransferEvent.localUnHolding_fsm);
	                        break;
	                    case self.NotificationEvent.joining_Notify:
	                        call.previousState = call.currentState;
	                        call.currentState = self.CallFSMState.JOINING;
	                        onSuccess(call, self.TransferEvent.joining_fsm);
	                        break;
	                    case self.NotificationEvent.transfering:
	                        call.previousState = call.currentState;
	                        call.currentState = self.CallFSMState.TRANSFERING;
	                        onSuccess(call, self.TransferEvent.transfering_fsm);
	                        break;
	                    case self.NotificationEvent.performReconnectWorkaround_JSL:
	                        call.previousState = call.currentState;
	                        call.currentState = self.CallFSMState.LOCAL_REOFFER;
	                        onSuccess(call, self.TransferEvent.performReconnectWorkaround_fsm);
	                        break;
	                    case self.NotificationEvent.consultativeTransfer_GUI:
	                        call.previousState = call.currentState;
	                        call.currentState = self.CallFSMState.TRANSFERING;
	                        onSuccess(call, self.TransferEvent.transfering_fsm);
	                        break;
	                    case self.NotificationEvent.startCallUpdate_slowStart_Notify:
	                        call.previousState = call.currentState;
	                        call.currentState = self.CallFSMState.LOCAL_SLOW_START_OFFER;
	                        onSuccess(call, self.TransferEvent.slowStartOfferDuringRemoteHold_fsm);
	                        break;
	                    default:
	                        onFailure(call, self.TransferEvent.unknownNotification_fsm);
	                        break;
	                }
	                break;
	            case self.CallFSMState.LOCAL_SLOW_START_OFFER:
	                switch (event) {
	                    case self.NotificationEvent.end_GUI:
	                        call.currentState = self.CallFSMState.INIT;
	                        onSuccess(call, self.TransferEvent.localEnding_fsm);
	                        break;
	                    case self.NotificationEvent.callEnd_Notify:
	                        call.currentState = self.CallFSMState.INIT;
	                        onSuccess(call, self.TransferEvent.remoteEnd_fsm);
	                        break;
	                    case self.NotificationEvent.respondCallUpdate_Notify:
	                        call.previousState = call.currentState;
	                        call.currentState = self.CallFSMState.COMPLETED;
	                        onSuccess(call, self.TransferEvent.respondCallUpdate_fsm);
	                        break;
	                    case self.NotificationEvent.requestFailure_JSL:
	                    case self.NotificationEvent.webrtcFailure_JSL:
	                        call.currentState = call.previousState;
	                        onSuccess(call, self.TransferEvent.stateReverted_fsm);
	                        break;
	                    case self.NotificationEvent.slowStartOfferProcessed_JSL:
	                        onSuccess(call, self.TransferEvent.slowStartOfferProcessed_fsm);
	                        break;
	                    default:
	                        onFailure(call, self.TransferEvent.unknownNotification_fsm);
	                        break;
	                }
	                break;
	            case self.CallFSMState.JOINING:
	                switch (event) {
	                    case self.NotificationEvent.end_GUI:
	                        call.currentState = self.CallFSMState.INIT;
	                        onSuccess(call, self.TransferEvent.localEnding_fsm);
	                        break;
	                    case self.NotificationEvent.callEnd_Notify:
	                        call.currentState = self.CallFSMState.INIT;
	                        onSuccess(call, self.TransferEvent.remoteEnd_fsm);
	                        break;
	                    case self.NotificationEvent.sessionComplete_Notify:
	                        call.currentState = self.CallFSMState.INIT;
	                        onSuccess(call, self.TransferEvent.sessionComplete_fsm);
	                        break;
	                    case self.NotificationEvent.sessionFail_Notify:
	                        call.currentState = call.previousState;
	                        onSuccess(call, self.TransferEvent.sessionFail_fsm);
	                        break;
	                    case self.NotificationEvent.refer_JSL:
	                        call.currentState = self.CallFSMState.REFER;
	                        onSuccess(call, self.TransferEvent.refer_fsm);
	                        break;
	                    case self.NotificationEvent.revertState_JSL:
	                        call.currentState = call.previousState;
	                        onSuccess(call, self.TransferEvent.stateReverted_fsm);
	                        break;
	                    default:
	                        onFailure(call, self.TransferEvent.unknownNotification_fsm);
	                        break;
	                }
	                break;
	            case self.CallFSMState.REFER:
	                switch (event) {
	                    case self.NotificationEvent.end_GUI:
	                        call.currentState = self.CallFSMState.INIT;
	                        onSuccess(call, self.TransferEvent.localEnding_fsm);
	                        break;
	                    case self.NotificationEvent.callEnd_Notify:
	                        call.currentState = self.CallFSMState.INIT;
	                        onSuccess(call, self.TransferEvent.remoteEnd_fsm);
	                        break;
	                    case self.NotificationEvent.sessionComplete_Notify:
	                        call.currentState = self.CallFSMState.INIT;
	                        onSuccess(call, self.TransferEvent.sessionComplete_fsm);
	                        break;
	                    case self.NotificationEvent.sessionFail_Notify:
	                        call.currentState = call.previousState;
	                        onSuccess(call, self.TransferEvent.sessionFail_fsm);
	                        break;
	                        //TODO Tolga - talk with lale
	                    case self.NotificationEvent.accepted_Notify:
	                        onSuccess(call, self.TransferEvent.accepted_fsm);
	                        break;
	                    default:
	                        onFailure(call, self.TransferEvent.unknownNotification_fsm);
	                        break;
	                }
	                break;
	            case self.CallFSMState.TRANSFERING:
	                switch (event) {
	                    case self.NotificationEvent.end_GUI:
	                        call.currentState = self.CallFSMState.INIT;
	                        onSuccess(call, self.TransferEvent.localEnding_fsm);
	                        break;
	                    case self.NotificationEvent.callEnd_Notify:
	                        call.currentState = self.CallFSMState.INIT;
	                        onSuccess(call, self.TransferEvent.remoteEnd_fsm);
	                        break;
	                    case self.NotificationEvent.sessionComplete_Notify:
	                        call.currentState = self.CallFSMState.INIT;
	                        onSuccess(call, self.TransferEvent.transferSuccess_fsm);
	                        break;
	                    case self.NotificationEvent.sessionFail_Notify:
	                        call.currentState = call.previousState;
	                        onSuccess(call, self.TransferEvent.transferFail_fsm);
	                        break;
	                        //TODO this notification is consumed for now - it is there for completeness
	                    case self.NotificationEvent.accepted_Notify:
	                        onSuccess(call, self.TransferEvent.accepted_fsm);
	                        break;
	                    case self.NotificationEvent.startCallUpdate_slowStart_Notify:
	                    case self.NotificationEvent.startCallUpdate_remoteHold_Notify:
	                    case self.NotificationEvent.startCallUpdate_remoteOffer_Notify:
	                        // Some client send hold during transfer
	                        onSuccess(call, self.TransferEvent.remoteCallUpdate_fsm);
	                        break;
	                    default:
	                        onFailure(call, self.TransferEvent.unknownNotification_fsm);
	                        break;
	                }
	                break;
	            case self.CallFSMState.LOCAL_ENDING:
	                switch (event) {
	                    case self.NotificationEvent.callEnd_Notify:
	                    case self.NotificationEvent.callCancel_Notify:
	                        call.currentState = self.CallFSMState.INIT;
	                        onSuccess(call, self.TransferEvent.localEnd_fsm);
	                        break;
	                }
	                break;
	            case self.CallFSMState.LOCAL_REJECTING:
	                switch (event) {
	                    case self.NotificationEvent.callEnd_Notify:
	                    case self.NotificationEvent.callCancel_Notify:
	                        call.currentState = self.CallFSMState.INIT;
	                        onSuccess(call, self.TransferEvent.localReject_fsm);
	                        break;
	                }
	        }
	    }

	    self.getCurrentState = function(call) {
	        return (call.currentState ? call.currentState : self.CallFSMState.INIT);
	    };

	    this.handleEvent = function(call, event, handler) {
	        var initialCallState;
	        if (call) {
	            initialCallState = self.getCurrentState(call);
	            logger.info("FSM received NotificationEvent: " + event + " @ " +
	                initialCallState + " state" + ". Call Id: " + call.id);

	            FSM(call, event,
	                function(call, transferEvent) {
	                    logger.debug("FSM handleEvent successful. (Call FSM) State Passed from " +
	                        initialCallState + " to " +
	                        self.getCurrentState(call) + ". TransferEvent: " +
	                        transferEvent + ". Call Id: " + call.id);
	                    handler(call, transferEvent);
	                },
	                function(call, transferEvent) {
	                    logger.error("FSM handleEvent failure: " + transferEvent +
	                        " @ " + self.getCurrentState(call) + ". Call Id: " +
	                        call.id);
	                    handler(call, transferEvent);
	                });
	        }
	    };
	};

	//@{fcs-jsl-prod}
	var CallFSM = function(_logManager) {
	    return new CallFSMImpl(_logManager || logManager);
	};

	var callFSM = new CallFSM();
	//@{fcs-jsl-prod}



	var CallControlServiceImpl = function(_server, _logManager, _cache, _fcs, _fcsConfig, _getWAMUrl) {

	    var logger = _logManager.getLogger("callControlService");

	    function addNotificationChannel(data) {
	        if (_fcs.notification.isAnonymous() && _cache.getItem("NotificationId")) {
	            data.callMeRequest.notifyChannelId = _cache.getItem("NotificationId");
	        }
	    }

	    function errorParser(jqXHR) {
	        if (jqXHR && jqXHR.responseText) {
	            return JSON.parse(jqXHR.responseText).callControlResponse;
	        }
	    }

	    this.startCall = function(from, to, sdp, onSuccess, onFailure) {

	        logger.info("Call Start Function: " + from + " --> " + to);
	        logger.info("Call Start Function: sdp : " + sdp);

	        // response of the startCall contains callid/sessionData
	        // callMe and callControl returns same response but object types have different namse
	        function parseCallStart(data) {
	            var callid, response = _fcs.notification.isAnonymous() ? data.callMeResponse : data.callControlResponse;
	            if (response) {
	                callid = response.sessionData;
	            }
	            return callid;
	        }

	        function dataType() {
	            var data;
	            if (_fcs.notification.isAnonymous()) {
	                data = {
	                    "callMeRequest": {
	                        "type": "callStart",
	                        "from": from,
	                        "to": to,
	                        "sdp": sdp
	                    }
	                };
	            } else {
	                data = {
	                    "callControlRequest": {
	                        "type": "callStart",
	                        "from": from,
	                        "to": to,
	                        "sdp": sdp,

	                    }
	                };

	                if (_fcsConfig.earlyMedia === true ||
	                    _fcsConfig.callReplace === true) {
	                    data.callControlRequest.supported = [];
	                }
	                if (_fcsConfig.earlyMedia === true) {
	                    data.callControlRequest.supported.push("earlymedia");
	                }
	                if (_fcsConfig.callReplace === true) {
	                    data.callControlRequest.supported.push("replacecall");
	                }
	            }
	            return data;
	        }

	        var data = dataType(),
	            realm = getRealm();
	        addNotificationChannel(data);

	        _server.sendPostRequest({
	                "url": _getWAMUrl(1, _fcs.notification.isAnonymous() ? "/callMe" + (realm ? ("?tokenrealm=" + realm) : "") : "/callControl"),
	                "data": data
	            },
	            onSuccess,
	            onFailure,
	            parseCallStart,
	            errorParser
	        );
	    };

	    this.audit = function(callid, onSuccess, onFailure) {
	        var data, realm = getRealm();

	        if (_fcs.notification.isAnonymous()) {
	            data = {
	                "callMeRequest": {
	                    "type": "audit"
	                }
	            };
	        } else {
	            data = {
	                "callControlRequest": {
	                    "type": "audit"
	                }
	            };
	        }

	        //TODO JF verify if we need to always do that and not only for callme realm;
	        if (realm) {
	            callid = callid.split("%0A")[0];
	        }

	        _server.sendPutRequest({
	            "url": _getWAMUrl(1, (_fcs.notification.isAnonymous() ? "/callme/callSessions/" : "/callControl/callSessions/") + callid + (realm ? ("?tokenrealm=" + realm) : "")),
	            "data": data
	        }, onSuccess, onFailure, null, errorParser);
	    };

	    this.hold = function(callid, sdp, onSuccess, onFailure) {
	        logger.info("Hold Function : sdp : " + sdp);
	        var data = {
	            "callControlRequest": {
	                "type": "startCallUpdate",
	                "sdp": sdp
	            }
	        };

	        _server.sendPutRequest({
	            "url": _getWAMUrl(1, "/callControl/callSessions/" + callid),
	            "data": data
	        }, onSuccess, onFailure, null, errorParser);
	    };

	    this.unhold = function(callid, sdp, onSuccess, onFailure) {
	        logger.info("UnHold Function : sdp : " + sdp);
	        var data = {
	            "callControlRequest": {
	                "type": "startCallUpdate",
	                "sdp": sdp
	            }
	        };
	        _server.sendPutRequest({
	            "url": _getWAMUrl(1, "/callControl/callSessions/" + callid),
	            "data": data
	        }, onSuccess, onFailure, null, errorParser);
	    };

	    this.reinvite = function(callid, sdp, onSuccess, onFailure) {
	        logger.info("reinvite Function : sdp : " + sdp);

	        var data = {
	            "callControlRequest": {
	                "type": "startCallUpdate",
	                "sdp": sdp
	            }
	        };

	        _server.sendPutRequest({
	            "url": _getWAMUrl(1, "/callControl/callSessions/" + callid),
	            "data": data
	        }, onSuccess, onFailure, null, errorParser);
	    };

	    this.respondCallUpdate = function(callid, sdp, onSuccess, onFailure) {
	        logger.info("Respond Call Update Function : sdp : " + sdp);
	        var data = {
	            "callControlRequest": {
	                "type": "respondCallUpdate",
	                "sdp": sdp
	            }
	        };
	        _server.sendPutRequest({
	            "url": _getWAMUrl(1, "/callControl/callSessions/" + callid),
	            "data": data
	        }, onSuccess, onFailure, null, errorParser);
	    };

	    this.join = function(firstSessionData, secondSessionData, sdp, onSuccess, onFailure) {
	        logger.info("Join Function : sdp : " + sdp);

	        function parseJoin(data) {
	            var callid, response = data.callControlResponse;

	            if (response) {
	                callid = response.sessionData;
	            }

	            return callid;
	        }

	        var data = {
	            "callControlRequest": {
	                "type": "join",
	                "firstSessionData": firstSessionData,
	                "secondSessionData": secondSessionData,
	                "sdp": sdp
	            }
	        };

	        if (_fcsConfig.clientControlled === "true") {
	            data.callControlRequest.clientControlled = "true";
	        }


	        _server.sendPostRequest({
	                "url": _getWAMUrl(1, "/callControl/"),
	                "data": data
	            },
	            onSuccess,
	            onFailure,
	            parseJoin,
	            errorParser
	        );
	    };

	    this.refer = function(callid, referTo, referredBy, onSuccess, onFailure) {
	        logger.info("Refer Function : refer to: " + referTo);
	        var data = {
	            "callControlRequest": {
	                "type": "refer",
	                "from": referredBy,
	                "to": referTo
	            }
	        };

	        _server.sendPutRequest({
	            "url": _getWAMUrl(1, "/callControl/callSessions/" + callid),
	            "data": data
	        }, onSuccess, onFailure, null, errorParser);
	    };

	    function makeCallControlRequest(type, callid, sdp, onSuccess, onFailure) {
	        logger.info("makeCallControlRequest Function : sdp : " + sdp);
	        var data = {
	            "callControlRequest": {
	                "type": type,
	                "sdp": sdp

	            }
	        };

	        if (_fcsConfig.callReplace === true) {
	            data.callControlRequest.supported = ["replacecall"];
	        }

	        _server.sendPutRequest({
	            "url": _getWAMUrl(1, "/callControl/callSessions/" + callid),
	            "data": data
	        }, onSuccess, onFailure, null, errorParser);
	    }

	    function makeCallControlEndRequest(callid, onSuccess, onFailure) {
	        var realm = getRealm();
	        logger.info("makeCallControlEndRequest Function: " + callid);

	        _server.sendDeleteRequest({
	                "url": _getWAMUrl(1, (_fcs.notification.isAnonymous() ? "/callme/callSessions/" : "/callControl/callSessions/") + callid + (realm ? ("?tokenrealm=" + realm) : "")),
	                "data": {}
	            },
	            onSuccess,
	            onFailure,
	            null,
	            errorParser
	        );
	    }

	    this.endCall = function(callid, onSuccess, onFailure) {
	        logger.info("endCall Function: " + callid);
	        makeCallControlEndRequest(callid, onSuccess, onFailure, null, errorParser);
	    };

	    this.answerCall = function(callid, sdp, onSuccess, onFailure) {
	        logger.info("Answer Call Function : sdp : " + sdp);
	        makeCallControlRequest("callAnswer", callid, sdp, onSuccess, onFailure, null, errorParser);
	    };

	    function makeRequest(action, sessionData, onSuccess, onFailure, address) {
	        logger.info("makeRequest Function with action : " + action);
	        var data = {
	            "callDispositionRequest": {
	                "action": action,
	                "sessionData": sessionData
	            }
	        };
	        if (address) {
	            data.callDispositionRequest.address = address;
	        }
	        _server.sendPostRequest({
	                "url": _getWAMUrl(1, "/calldisposition"),
	                "data": data
	            },
	            onSuccess,
	            onFailure,
	            null,
	            errorParser
	        );
	    }

	    this.reject = function(callid, onSuccess, onFailure) {
	        var dummy;
	        logger.info("Reject Function: " + callid);
	        makeRequest("reject", callid, onSuccess, onFailure, dummy, errorParser);
	    };


	    this.forward = function(callid, address, onSuccess, onFailure) {
	        logger.info("Forward Function : address: " + address);
	        makeRequest("forward", callid, onSuccess, onFailure, address);
	    };

	    this.transfer = function(callid, address, sessiondataToTransfer, onSuccess, onFailure) {
	        logger.info("Call Transfer Function : target address: " + address);
	        var data = {
	            "callControlRequest": {
	                "type": "transfer",
	                "address": address,
	                "sessionData": sessiondataToTransfer
	            }
	        };

	        _server.sendPutRequest({
	            "url": _getWAMUrl(1, "/callControl/callSessions/" + callid),
	            "data": data
	        }, onSuccess, onFailure, null, errorParser);
	    };

	    this.clickToCall = function(callingParty, calledParty, onSuccess, onFailure) {
	        var data = {
	            "clickToCallRequest": {
	                "callingParty": callingParty,
	                "calledParty": calledParty
	            }
	        };
	        _server.sendPostRequest({
	                "url": _getWAMUrl(1, "/clicktocall"),
	                "data": data
	            },
	            onSuccess,
	            onFailure
	        );
	    };

	    this.getIMRN = function(realm, source, destination, onSuccess, onFailure) {
	        logger.info("(Wam Call) getIMRN Function ");

	        function parseIMRNResponse(IMRNdata) {
	            var receivedIMRN;
	            if (IMRNdata && IMRNdata.imrnResponse) {
	                receivedIMRN = utils.getProperty(IMRNdata.imrnResponse, 'imrn');
	            }
	            return receivedIMRN;
	        }

	        if (destination.match('@')) {
	            if (destination.split(':')[0] !== "sip") {
	                destination = "sip:" + destination;
	            }
	        }

	        var data = {
	            "imrnRequest": {
	                "realm": realm,
	                "sourceAddress": source,
	                "destinationAddress": destination
	            }
	        };
	        _server.sendPostRequest({
	                "url": _getWAMUrl(1, "/imrn"),
	                "data": data
	            },
	            onSuccess,
	            onFailure,
	            parseIMRNResponse
	        );
	    };

	    this.acceptCallReplace = function(callData, onSuccess, onFailure) {
	        function parseAcceptCallReplaceData(data) {
	            logger.info("acceptCallReplace.data: " + data);
	            return data;
	        }

	        function dataType() {
	            var data;
	            data = {
	                "callControlRequest": {
	                    "type": "acceptCallReplace",
	                    "sdp": callData.sdp
	                }
	            };
	            return data;
	        }
	        var data = dataType();

	        _server.sendPutRequest({
	                "url": _getWAMUrl(1, "/callControl/callSessions/" + callData.id),
	                "data": data
	            },
	            onSuccess,
	            onFailure,
	            parseAcceptCallReplaceData,
	            errorParser
	        );
	    };

	    this.rejectCallReplace = function(callData, onSuccess, onFailure) {
	        function parseAcceptCallReplaceData(data) {
	            logger.info("rejectCallReplace.data: " + data);
	            return data;
	        }

	        function dataType() {
	            var data;
	            data = {
	                "callControlRequest": {
	                    "type": "rejectCallReplace",
	                }
	            };
	            return data;
	        }
	        var data = dataType();
	        _server.sendPutRequest({
	                "url": _getWAMUrl(1, "/callControl/callSessions/" + callData.id),
	                "data": data
	            },
	            onSuccess,
	            onFailure,
	            parseAcceptCallReplaceData,
	            errorParser
	        );
	    };

	};

	//@{fcs-jsl-prod}
	var CallControlService = function(_server, _logManager, _cache, _fcs, _fcsConfig, _getWAMUrl) {
	    return new CallControlServiceImpl(_server || server,
	        _logManager || logManager,
	        _cache || cache,
	        _fcs || fcs,
	        _fcsConfig || fcsConfig,
	        _getWAMUrl || getWAMUrl);
	};

	var callControlService = new CallControlService();
	//@{fcs-jsl-prod}


	var CallManagerImpl = function(_webRtcManager, _callFSM, _callControlService, _sdpParser, _logManager, _globalBroadcaster, _utils, _fcs) {

	    /* AUDIT_KICKOFF_TIMEOUT is the interval we use to kickoff call audit after the call is setup.
	     * The timeout is there to ensure we do not hit call setup race conditions when we try to kickoff the call audit */
	    var calls = {},
	        logger = _logManager.getLogger("callManager"),
	        AUDIT_KICKOFF_TIMEOUT = 3000,
	        isReconnected = false,
	        fsmNotificationEvent = _callFSM.NotificationEvent,
	        fsmState = _callFSM.CallFSMState,
	        self = this,
	        isQueueEnabled = true,
	        NOTIFICATION_STATE = {
	            BUSY: 0,
	            IDLE: 1
	        },
	        CALL_STATES = {
	            IN_CALL: 0,
	            ON_HOLD: 1,
	            RINGING: 2,
	            ENDED: 3,
	            REJECTED: 4,
	            OUTGOING: 5,
	            INCOMING: 6,
	            ANSWERING: 7,
	            JOINED: 8,
	            RENEGOTIATION: 9,
	            TRANSFERRED: 10,
	            ON_REMOTE_HOLD: 11,
	            CALL_IN_PROGRESS: 12,
	            EARLY_MEDIA: 13,
	            TRANSFER_FAILURE: 14,
	            REPLACING: 15
	        },
	        CALL_HOLD_STATES = {
	            LOCAL_HOLD: 0,
	            REMOTE_HOLD: 1,
	            BOTH_HOLD: 2
	        },
	        LOCAL_STATUS_CODES = {
	            STATUS_CODE_NOT_PROVIDED: "9900",
	            ENDED_BY_LOCAL: "9901",
	            REJECTED_BY_LOCAL: "9902",
	            IGNORED_BY_LOCAL: "9903",
	            RESPONDED_FROM_ANOTHER_DEVICE: "9904",
	            SESSION_COMPLETED: "9905"
	        },
	        LOCAL_REASON_TEXTS = {
	            STATUS_CODE_NOT_PROVIDED: "Reason not provided",
	            ENDED_BY_LOCAL: "Ended by local user",
	            REJECTED_BY_LOCAL: "Rejected by local user",
	            IGNORED_BY_LOCAL: "Ignored by local user",
	            RESPONDED_FROM_ANOTHER_DEVICE: "Responded from another device",
	            SESSION_COMPLETED: "Session completed"
	        },
	        mediaConstraints = {
	            audio: {
	                optional: [{
	                    sourceId: ""
	                }]
	            },
	            video: {
	                mandatory: {
	                    minWidth: "320",
	                    minHeight: "240",
	                    maxWidth: "320",
	                    maxHeight: "240"
	                },
	                optional: [{
	                    sourceId: ""
	                }]
	            }
	        };

	    this.IncomingCall = function(callid, data) {
	        var id = callid,
	            options = data,
	            sendVideo = true,
	            isJoin = false,
	            buttonDisabler = false,
	            btnTimeout, auditTimer;

	        this.notificationQueue = new _utils.Queue();
	        this.onLocalStreamAdded = null;
	        this.onStreamAdded = null;
	        this.onMute = null;
	        this.onStateChange = null;

	        this.getRemoteVideoState = function() {
	            return self.getRemoteVideoState(callid);
	        };

	        this.mute = function() {
	            var param = {
	                callid: id,
	                mute: true
	            };

	            return self.mute(param);
	        };
	        this.unmute = function() {
	            var param = {
	                callid: id,
	                mute: false
	            };

	            return self.mute(param);
	        };

	        this.answer = function(onSuccess, onFailure, isVideoEnabled, videoQuality) {
	            var param = {
	                callid: id,
	                isVideoEnabled: isVideoEnabled,
	                videoQuality: videoQuality
	            };

	            if (options.answer) {
	                return self.answer(param, onSuccess, onFailure);
	            } else {
	                _utils.callFunctionIfExist(onFailure, _fcs.Errors.NOT_ALLOWED_SERVICE);
	            }
	        };

	        this.reject = function(onSuccess, onFailure) {
	            var param = {
	                callid: id
	            };

	            if (options.reject) {
	                return self.reject(param, onSuccess, onFailure);
	            } else {
	                _utils.callFunctionIfExist(onFailure, _fcs.Errors.NOT_ALLOWED_SERVICE);
	            }
	        };

	        this.ignore = function(onSuccess, onFailure) {
	            var param = {
	                callid: id
	            };

	            return self.ignore(param, onSuccess, onFailure);
	        };

	        this.forward = function(address, onSuccess, onFailure) {
	            var param = {
	                callid: id,
	                address: address
	            };

	            if (options.forward) {
	                return self.forward(param, onSuccess, onFailure);
	            } else {
	                _utils.callFunctionIfExist(onFailure, _fcs.Errors.NOT_ALLOWED_SERVICE);
	            }
	        };

	        this.canReject = function() {
	            return options.reject === true;
	        };

	        this.canForward = function() {
	            return options.forward === true;
	        };

	        this.canAnswer = function() {
	            return options.answer === true;
	        };

	        this.canSendVideo = function() {
	            var param = {
	                callid: id
	            };

	            return self.canOriginatorSendLocalVideo(param);
	        };

	        this.canReceiveVideo = function() {
	            var param = {
	                callid: id
	            };

	            return self.canOriginatorReceiveRemoteVideo(param);
	        };

	        this.getHoldState = function() {
	            var param = {
	                callid: id
	            };

	            return self.getHoldStateOfCall(param);

	        };

	        this.getId = function() {
	            return id;
	        };

	        this.end = function(onSuccess, onFailure) {
	            var param = {
	                callid: id
	            };

	            return self.end(param, onSuccess, onFailure);
	        };

	        this.hold = function(onSuccess, onFailure) {
	            var param = {
	                callid: id
	            };

	            return self.hold(param, onSuccess, onFailure);
	        };

	        this.unhold = function(onSuccess, onFailure) {
	            var param = {
	                callid: id
	            };

	            return self.unhold(param, onSuccess, onFailure);
	        };

	        this.getWebRtcStats = function(onSuccess, onFailure) {
	            var param = {
	                callid: id
	            };

	            return self.getWebRtcStats(param, onSuccess, onFailure);
	        };

	        this.getNativeWebRtcStats = function(onSuccess, onFailure) {
	            var param = {
	                callid: id
	            };

	            return self.getNativeWebRtcStats(param, onSuccess, onFailure);
	        };

	        this.startWebRtcStatsTimer = function(interval, onSuccess, onFailure) {
	            var param = {
	                callid: id,
	                interval: interval
	            };

	            return self.startWebRtcStatsTimer(param, onSuccess, onFailure);
	        };

	        this.stopWebRtcStatsTimer = function() {
	            var param = {
	                callid: id
	            };

	            return self.stopWebRtcStatsTimer(param);
	        };

	        this.directTransfer = function(address, onSuccess, onFailure) {
	            var param = {
	                callid: id,
	                address: address
	            };

	            return self.directTransfer(param, onSuccess, onFailure);
	        };

	        this.consultativeTransfer = function(transferredCallId, onSuccess, onFailure) {
	            var param = {
	                currentCallId: id,
	                targetCallId: transferredCallId
	            };

	            return self.consultativeTransfer(param, onSuccess, onFailure);
	        };

	        this.videoStop = function(onSuccess, onFailure) {
	            var param = {
	                callid: id,
	                isVideoStart: false
	            };

	            return self.videoStopStart(param, onSuccess, onFailure);
	        };

	        this.videoStart = function(onSuccess, onFailure, videoQuality) {
	            var param = {
	                callid: id,
	                isVideoStart: true,
	                videoQuality: videoQuality
	            };

	            return self.videoStopStart(param, onSuccess, onFailure);
	        };

	        this.getMediaStream = function() {
	            return self.getMediaStream(id);
	        };

	        /**
	         * Start sharing the screen for this call after the call is established.
	         *
	         * @name fcs.call.IncomingCall#screenSharingStart
	         * @function
	         * @param {function} [onSuccess] The onSuccess() to be called when the screen sharing is started
	         * @param {function} [onFailure] The onFailure() to be called when the screen sharing could not be started
	         * @param {function} [onStopped] The onStopped() to be called when the user has clicked to stop sharing the screen.
	         * @param {object} [options] The screen sharing options
	         * @param {number} [options.width=1024] The width of the screen to request.
	         * @param {number} [options.height=768] The height of the screen to request.
	         * @param {number} [options.frameRate=15] The number of frames per second to request.
	         */
	        this.screenSharingStart = function(onSuccess, onFailure, onStopped, options) {
	            self.screenStopStart(id, onSuccess, onFailure, onStopped, true, options);
	        };

	        /**
	         * Stop sharing the screen for this call after the call is established.
	         *
	         * @name fcs.call.OutgoingCall#screenSharingStop
	         * @function
	         * @param {function} [onSuccess] The onSuccess() to be called when the screen sharing is stopped.
	         * @param {function} [onFailure] The onFailure() to be called when the screen sharing could not be stopped.
	         */
	        this.screenSharingStop = function(onSuccess, onFailure) {
	            self.screenStopStart(id, onSuccess, onFailure, null, false);
	        };

	        this.join = function(anotherCall, onSuccess, onFailure, isVideoEnabled, videoQuality) {
	            var param = {
	                callid1: id,
	                callid2: anotherCall.getId()
	            };

	            return self.join(param, onSuccess, onFailure, isVideoEnabled, videoQuality);
	        };

	        this.sendDTMF = function(tone) {
	            var param = {
	                callid: id,
	                tone: tone
	            };

	            return self.sendDTMF(param);
	        };

	        this.sendIntraFrame = function() {
	            var param = {
	                callid: id
	            };

	            if (sendVideo) {
	                return self.sendIntraFrame(param);
	            }
	        };

	        this.sendBlackFrame = function() {
	            var param = {
	                callid: id
	            };

	            return self.sendBlackFrame(param);
	        };

	        this.refreshVideoRenderer = function() {
	            var param = {
	                callid: id
	            };

	            return self.refreshVideoRenderer(param);
	        };

	        this.getJoin = function() {
	            return isJoin;
	        };

	        this.setJoin = function(join) {
	            isJoin = join;
	        };

	        this.getButtonDisabler = function() {
	            return buttonDisabler;
	        };

	        this.setButtonDisabler = function(disable) {
	            buttonDisabler = disable;
	            if (buttonDisabler) {
	                btnTimeout = setTimeout(function() {
	                    buttonDisabler = false;
	                }, 4000);
	            }
	        };

	        this.clearBtnTimeout = function() {
	            clearTimeout(btnTimeout);
	        };

	        this.setAuditTimer = function(audit) {
	            auditTimer = setInterval(function() {
	                audit();
	            }, fcsConfig.callAuditTimer ? fcsConfig.callAuditTimer : 30000);
	        };

	        this.clearAuditTimer = function() {
	            clearInterval(auditTimer);
	        };

	        this.isCallMuted = function() {
	            var param = {
	                callid: id
	            };

	            return self.isCallMuted(param);
	        };

	        /* DEPRECIATED */
	        this.isVideoNegotationAvailable = function(id) {
	            var param = {
	                callid: id
	            };

	            return self.isVideoNegotationAvailable(param);
	        };

	        this.isVideoNegotiationAvailable = function() {
	            var param = {
	                callid: id
	            };

	            return self.isVideoNegotiationAvailable(param);
	        };
	    };
	    this.OutgoingCall = function(callid) {
	        var id = callid,
	            sendVideo = true,
	            isJoin = false,
	            buttonDisabler = false,
	            btnTimeout, auditTimer;

	        this.notificationQueue = new _utils.Queue();
	        this.onLocalStreamAdded = null;
	        this.onStreamAdded = null;
	        this.onMute = null;
	        this.onStateChange = null;

	        this.canSendVideo = function() {
	            var param = {
	                callid: id
	            };

	            return self.canOriginatorSendLocalVideo(param);
	        };

	        this.getRemoteVideoState = function() {
	            return self.getRemoteVideoState(callid);
	        };

	        this.canSendVideo = function() {
	            var param = {
	                callid: id
	            };

	            return self.canOriginatorSendLocalVideo(param);
	        };

	        this.canReceiveVideo = function() {
	            var param = {
	                callid: id
	            };

	            return self.canOriginatorReceiveRemoteVideo(param);
	        };

	        this.getHoldState = function() {
	            var param = {
	                callid: id
	            };

	            return self.getHoldStateOfCall(param);
	        };

	        this.getId = function() {
	            return id;
	        };

	        this.sendIntraFrame = function() {
	            var param = {
	                callid: id
	            };

	            if (sendVideo) {
	                return self.sendIntraFrame(param);
	            }
	        };

	        this.sendBlackFrame = function() {
	            var param = {
	                callid: id
	            };

	            return self.sendBlackFrame(param);
	        };

	        this.refreshVideoRenderer = function() {
	            var param = {
	                callid: id
	            };

	            return self.refreshVideoRenderer(param);
	        };

	        this.mute = function() {
	            var param = {
	                callid: id,
	                mute: true
	            };

	            return self.mute(param);
	        };

	        this.unmute = function() {
	            var param = {
	                callid: id,
	                mute: false
	            };

	            return self.mute(param);
	        };

	        this.end = function(onSuccess, onFailure) {
	            var param = {
	                callid: id
	            };

	            return self.end(param, onSuccess, onFailure);
	        };

	        this.hold = function(onSuccess, onFailure) {
	            var param = {
	                callid: id
	            };

	            return self.hold(param, onSuccess, onFailure);
	        };

	        this.unhold = function(onSuccess, onFailure) {
	            var param = {
	                callid: id
	            };

	            return self.unhold(param, onSuccess, onFailure);
	        };

	        this.getWebRtcStats = function(onSuccess, onFailure) {
	            var param = {
	                callid: id
	            };

	            return self.getWebRtcStats(param, onSuccess, onFailure);
	        };

	        this.getNativeWebRtcStats = function(onSuccess, onFailure) {
	            var param = {
	                callid: id
	            };

	            return self.getNativeWebRtcStats(param, onSuccess, onFailure);
	        };

	        this.startWebRtcStatsTimer = function(interval, onSuccess, onFailure) {
	            var param = {
	                callid: id,
	                interval: interval
	            };

	            return self.startWebRtcStatsTimer(param, onSuccess, onFailure);
	        };

	        this.stopWebRtcStatsTimer = function() {
	            var param = {
	                callid: id
	            };

	            return self.stopWebRtcStatsTimer(param);
	        };

	        this.directTransfer = function(address, onSuccess, onFailure) {
	            var param = {
	                callid: id,
	                address: address
	            };

	            return self.directTransfer(param, onSuccess, onFailure);
	        };

	        this.consultativeTransfer = function(transfaredCallId, onSuccess, onFailure) {
	            var param = {
	                currentCallId: id,
	                targetCallId: transfaredCallId
	            };
	            return self.consultativeTransfer(param, onSuccess, onFailure);
	        };

	        this.videoStop = function(onSuccess, onFailure) {
	            var param = {
	                callid: id,
	                isVideoStart: false
	            };

	            return self.videoStopStart(param, onSuccess, onFailure);
	        };

	        this.videoStart = function(onSuccess, onFailure, videoQuality) {
	            var param = {
	                callid: id,
	                isVideoStart: true,
	                videoQuality: videoQuality
	            };

	            return self.videoStopStart(param, onSuccess, onFailure);
	        };

	        this.getMediaStream = function() {
	            return self.getMediaStream(id);
	        };

	        /**
	         * Start sharing the screen for this call after the call is established.
	         *
	         * @name fcs.call.OutgoingCall#screenSharingStart
	         * @function
	         * @param {function} [onSuccess] The onSuccess() to be called when the screen sharing is started
	         * @param {function} [onFailure] The onFailure() to be called when the screen sharing could not be started
	         * @param {function} [onStopped] The onStopped() to be called when the user has clicked to stop sharing the screen.
	         * @param {object} [options] The screen sharing options
	         * @param {number} [options.width=1024] The width of the screen to request.
	         * @param {number} [options.height=768] The height of the screen to request.
	         * @param {number} [options.frameRate=15] The number of frames per second to request.
	         */
	        this.screenSharingStart = function(onSuccess, onFailure, onStopped, options) {
	            self.screenStopStart(id, onSuccess, onFailure, onStopped, true, options);
	        };

	        /**
	         * Stop sharing the screen for this call after the call is established.
	         *
	         * @name fcs.call.OutgoingCall#screenSharingStop
	         * @function
	         * @param {function} [onSuccess] The onSuccess() to be called when the screen sharing is stopped.
	         * @param {function} [onFailure] The onFailure() to be called when the screen sharing could not be stopped.
	         */
	        this.screenSharingStop = function(onSuccess, onFailure) {
	            self.screenStopStart(id, onSuccess, onFailure, null, false);
	        };

	        this.join = function(anotherCall, onSuccess, onFailure, isVideoEnabled, videoQuality) {
	            var param = {
	                callid1: id,
	                callid2: anotherCall.getId()
	            };

	            return self.join(param, onSuccess, onFailure, isVideoEnabled, videoQuality);
	        };

	        this.sendDTMF = function(tone) {
	            var param = {
	                callid: id,
	                tone: tone
	            };

	            return self.sendDTMF(param);
	        };

	        this.getJoin = function() {
	            return isJoin;
	        };

	        this.setJoin = function(join) {
	            isJoin = join;
	        };

	        this.getButtonDisabler = function() {
	            return buttonDisabler;
	        };

	        this.setButtonDisabler = function(disable) {
	            buttonDisabler = disable;
	            if (buttonDisabler) {
	                btnTimeout = setTimeout(function() {
	                    buttonDisabler = false;
	                }, 4000);
	            }
	        };

	        this.clearBtnTimeout = function() {
	            clearTimeout(btnTimeout);
	        };

	        this.setAuditTimer = function(audit) {
	            auditTimer = setInterval(function() {
	                audit();
	            }, fcsConfig.callAuditTimer ? fcsConfig.callAuditTimer : 30000);
	        };

	        this.clearAuditTimer = function() {
	            clearInterval(auditTimer);
	        };

	        this.isCallMuted = function() {
	            var param = {
	                callid: id
	            };

	            return self.isCallMuted(param);
	        };

	        /* DEPRECIATED */
	        this.isVideoNegotationAvailable = function(id) {
	            var param = {
	                callid: id
	            };

	            return self.isVideoNegotationAvailable(param);
	        };

	        this.isVideoNegotiationAvailable = function() {
	            var param = {
	                callid: id
	            };

	            return self.isVideoNegotiationAvailable(param);
	        };
	    };

	    self.consultativeTransfer = function(data, onSuccess, onFailure) {
	        var internalCall = calls[data.currentCallId],
	            targetCall = calls[data.targetCallId],
	            currentCallState, targetCallState;
	        internalCall.targetCallId = data.targetCallId;
	        if (targetCall.callerNumber) {
	            internalCall.targetAddress = targetCall.callerNumber;
	        } else {
	            internalCall.targetAddress = targetCall.call.callerNumber;
	        }
	        currentCallState = _callFSM.getCurrentState(internalCall);
	        targetCallState = _callFSM.getCurrentState(targetCall);
	        if ((currentCallState === fsmState.LOCAL_HOLD ||
	                currentCallState === fsmState.BOTH_HOLD) &&
	            (targetCallState === fsmState.LOCAL_HOLD ||
	                targetCallState === fsmState.BOTH_HOLD)) {
	            _callControlService.transfer(internalCall.id, internalCall.targetAddress, internalCall.targetCallId, function() {
	                logger.info("consultative transfer successful. callId: " + internalCall.id);
	                self.delegateToCallFSM(internalCall, fsmNotificationEvent.consultativeTransfer_GUI);
	                _utils.callFunctionIfExist(onSuccess);
	            }, function(e) {
	                logger.error("consultative transfer failed. callId: " + internalCall.id);
	                _utils.callFunctionIfExist(onFailure, e);
	            });
	        } else if (currentCallState === fsmState.LOCAL_HOLDING) {
	            if (!internalCall.transferTrigger) {
	                internalCall.transferTrigger = function() {
	                    self.consultativeTransfer(data, onSuccess, onFailure);
	                    delete this.transferTrigger;
	                };
	            } else {
	                _utils.callFunctionIfExist(onFailure, _fcs.Errors.STATE);
	            }
	        } else if (targetCallState === fsmState.LOCAL_HOLDING) {
	            if (!targetCall.transferTrigger) {
	                targetCall.transferTrigger = function() {
	                    self.consultativeTransfer(data, onSuccess, onFailure);
	                    delete this.transferTrigger;
	                };
	            } else {
	                _utils.callFunctionIfExist(onFailure, _fcs.Errors.STATE);
	            }
	        } else {
	            logger.error("Cannot consultative transfer in INIT callstate :" + _fcs.Errors.STATE);
	            _utils.callFunctionIfExist(onFailure, _fcs.Errors.STATE);
	        }
	    };

	    /*
	     * When connection re-establishes sets isReconnected flag true
	     */
	    function onConnectionLost() {
	        isReconnected = true;
	    }

	    /*
	     * clear call resources
	     * clear long call audit
	     * clear webrtc resources
	     * triger web part
	     *
	     * @param call call object
	     * @param state state that will be returned to web part
	     */
	    function clearResources(call, preserveCallObject) {
	        var onSuccess, onFailure, callStats = call;
	        if (call.call) {
	            call.call.clearAuditTimer();
	        }
	        if (call.pendingRequestTimer) {
	            clearTimeout(call.pendingRequestTimer);
	        }
	        _webRtcManager.stopWebRtcStatsTimer(call);
	        callStats.cache = true;
	        _webRtcManager.getWebRtcStats(callStats, onSuccess, onFailure);
	        //clear webRTC resources
	        _webRtcManager.processEnd(call);
	        if (typeof preserveCallObject === "undefined") {
	            clearCallObject(call);
	        }
	    }

	    function clearCallObject(call) {
	        //clear call object
	        delete calls[call.id];
	    }

	    function setNotificationStateOfCallToBusy(internalCall) {
	        logger.debug("Setting notification state to BUSY for call: " + internalCall.id);
	        internalCall.notificationState = NOTIFICATION_STATE.BUSY;
	    }

	    function setNotificationStateOfCallToIdle(internalCall) {
	        logger.debug("Setting notification state to IDLE for call: " + internalCall.id);
	        internalCall.notificationState = NOTIFICATION_STATE.IDLE;
	    }

	    function isNotificationStateOfCallBusy(internalCall) {
	        return internalCall.notificationState === NOTIFICATION_STATE.BUSY;
	    }

	    function triggerQueue(call) {
	        if (!isQueueEnabled) {
	            return;
	        }
	        logger.debug("NOTIFICATION_QUEUE: Process completed, notification queue state changed to IDLE");
	        setNotificationStateOfCallToIdle(call);
	        if (call.call.notificationQueue.size() > 0) {
	            logger.debug("NOTIFICATION_QUEUE: New notification found in queue, processing it!");
	            var notificationObj = call.call.notificationQueue.dequeue();
	            self.onNotificationEvent(notificationObj.type, notificationObj.sessionParams);
	        }
	    }

	    function onSubscriptionReEstablished() {
	        var id, internalCall;
	        if (isReconnected) {
	            isReconnected = false;
	            for (id in calls) {
	                if (calls.hasOwnProperty(id)) {
	                    internalCall = calls[id];
	                    if (internalCall && _callFSM.getCurrentState(internalCall) !== fsmState.RINGING) {
	                        setNotificationStateOfCallToBusy(internalCall);
	                        self.delegateToCallFSM(internalCall, fsmNotificationEvent.performReconnectWorkaround_JSL);
	                    } else {
	                        // If call signalingState is not stable, this call on ringing state. Call will be ended.
	                        // Send 0 to delete the call
	                        internalCall.call.onStateChange(CALL_STATES.ENDED, 0);
	                        clearResources(internalCall);
	                    }
	                }
	            }
	        }
	    }

	    /*
	     * TODO: add selected speaker to the audio constraint, after chrome implementation
	     */
	    function prepareAudioConstraints() {
	        var selectedMicrophoneId = self.getSelectedMicrophoneId();

	        if (selectedMicrophoneId) {
	            mediaConstraints.audio.optional[0].sourceId = selectedMicrophoneId;
	        }
	        return mediaConstraints.audio;
	    }

	    function prepareVideoConstraints(data) {
	        var videoResolutionArray, selectedCameraId = self.getSelectedCameraId(),
	            isVideoEnabled, videoQuality, videoNegotiationOnAnswer;

	        if (!data) {
	            data = {};
	        }
	        isVideoEnabled = data.isVideoEnabled;
	        videoQuality = data.videoQuality;
	        videoNegotiationOnAnswer = data.videoNegotiationOnAnswer;

	        if (isVideoEnabled) {
	            if (videoQuality && typeof videoQuality === "string") {
	                // First element of array will be Width and second element will be Height
	                videoResolutionArray = videoQuality.split("x");
	                if (!isNaN(videoResolutionArray[0]) && !isNaN(videoResolutionArray[1])) {
	                    mediaConstraints.video.mandatory.maxWidth = videoResolutionArray[0];
	                    mediaConstraints.video.mandatory.minWidth = videoResolutionArray[0];
	                    mediaConstraints.video.mandatory.maxHeight = videoResolutionArray[1];
	                    mediaConstraints.video.mandatory.minHeight = videoResolutionArray[1];
	                }
	            }

	            if (selectedCameraId) {
	                mediaConstraints.video.optional[0].sourceId = selectedCameraId;
	            }

	            return mediaConstraints.video;
	        } else {
	            if (videoNegotiationOnAnswer) {
	                return true;
	            } else {
	                return false;
	            }
	        }
	    }

	    self.CALL_STATES = CALL_STATES;
	    self.CALL_HOLD_STATES = CALL_HOLD_STATES;
	    self.LOCAL_STATUS_CODES = LOCAL_STATUS_CODES;
	    self.LOCAL_REASON_TEXTS = LOCAL_REASON_TEXTS;

	    self.initMedia = function(data, onSuccess, onFailure) {
	        _webRtcManager.initMedia(function() {
	            _utils.callFunctionIfExist(onSuccess);
	        }, function(e) {
	            _utils.callFunctionIfExist(onFailure, e);
	        }, data.options);
	    };

	    self.set_logSeverityLevel = function(data) {
	        _webRtcManager.set_logSeverityLevel(data.level);
	    };

	    self.enable_logCallback = function() {
	        _webRtcManager.enable_logCallback();
	    };

	    self.disable_logCallback = function() {
	        _webRtcManager.disable_logCallback();
	    };

	    self.get_audioInDeviceCount = function() {
	        return _webRtcManager.get_audioInDeviceCount();
	    };

	    self.get_audioOutDeviceCount = function() {
	        return _webRtcManager.get_audioOutDeviceCount();
	    };

	    self.get_videoDeviceCount = function() {
	        return _webRtcManager.get_videoDeviceCount();
	    };

	    function mapGetUserMediaErrorToFcsError(e) {
	        switch (e) {
	            case _fcs.call.MediaErrors.NOT_FOUND:
	                return _fcs.Errors.MEDIA_NOT_FOUND;
	            case _fcs.call.MediaErrors.NOT_ALLOWED:
	                return _fcs.Errors.MEDIA_NOT_ALLOWED;
	            case _fcs.call.MediaErrors.INVALID_PARAMETER:
	                return _fcs.Errors.INVALID_PARAMETER;
	            default:
	                return e;
	        }
	    }

	    self.getUserMedia = function(data, onSuccess, onFailure) {
	        if (data.privateStream) {
	            var audioConstraints = prepareAudioConstraints(),
	                videoConstraints = prepareVideoConstraints({
	                    isVideoEnabled: true
	                });

	            if (data.options) {
	                if (data.options.audio !== undefined) {
	                    audioConstraints = data.options.audio;
	                }
	                if (data.options.video !== undefined) {
	                    videoConstraints = data.options.video;
	                }
	            }

	            _webRtcManager.privateGetUserMedia(
	                onSuccess,
	                function(e) {
	                    _utils.callFunctionIfExist(onFailure, mapGetUserMediaErrorToFcsError(e));
	                }, {
	                    audio: audioConstraints,
	                    video: videoConstraints,
	                    privateStream: true
	                });
	        } else {
	            _webRtcManager.getUserMedia(
	                onSuccess,
	                function(e) {
	                    _utils.callFunctionIfExist(onFailure, mapGetUserMediaErrorToFcsError(e));
	                },
	                data.options);
	        }
	    };

	    self.getWebRtcStats = function(data, onSuccess, onFailure) {
	        var internalCall = calls[data.callid];

	        return _webRtcManager.getWebRtcStats(internalCall, onSuccess, onFailure);
	    };

	    self.getNativeWebRtcStats = function(data, onSuccess, onFailure) {
	        var internalCall = calls[data.callid];

	        return _webRtcManager.getNativeWebRtcStats(internalCall, onSuccess, onFailure);
	    };

	    self.startWebRtcStatsTimer = function(data, onSuccess, onFailure) {
	        var internalCall = calls[data.callid],
	            interval;

	        if (data.interval !== parseInt(data.interval, 10)) {
	            return;
	        }
	        // Change interval value(seconds) to miliseconds
	        interval = parseInt(data.interval) * 1000;
	        return _webRtcManager.startWebRtcStatsTimer(internalCall, interval, onSuccess, onFailure);
	    };

	    self.stopWebRtcStatsTimer = function(data) {
	        var internalCall = calls[data.callid];

	        return _webRtcManager.stopWebRtcStatsTimer(internalCall);
	    };

	    self.showSettingsWindow = function(data, onSuccess, onFailure) {
	        _webRtcManager.showSettingsWindow(function() {
	            _utils.callFunctionIfExist(onSuccess);
	        }, function(e) {
	            _utils.callFunctionIfExist(onFailure, e);
	        }, data.options);
	    };

	    self.createStreamRenderer = function(data) {
	        return _webRtcManager.createStreamRenderer(data.streamId, data.container, data.options);
	    };

	    self.disposeStreamRenderer = function(data) {
	        _webRtcManager.disposeStreamRenderer(data.container);
	    };

	    self.isPluginEnabled = function() {
	        return _webRtcManager.isPluginEnabled();
	    };

	    self.hasGotCalls = function() {
	        var callid, internalCall;
	        for (callid in calls) {
	            if (calls.hasOwnProperty(callid)) {
	                internalCall = calls[callid];
	                if (internalCall) {
	                    logger.info("has got call - id: " + callid + " - state: " + _callFSM.getCurrentState(internalCall));
	                    return true;
	                }
	            }
	        }
	        return false;
	    };

	    self.getCalls = function() {
	        return calls;
	    };

	    self.sendIntraFrame = function(data) {
	        var internalCall = calls[data.callid];
	        if (internalCall) {
	            _webRtcManager.sendIntraFrame(internalCall);
	        }
	    };

	    self.sendBlackFrame = function(data) {
	        var internalCall = calls[data.callid];
	        if (internalCall) {
	            _webRtcManager.sendBlackFrame(internalCall);
	        }
	    };

	    self.delegateToCallFSM = function(call, stateMessage) {
	        _callFSM.handleEvent(call, stateMessage, self.onStateChange);
	    };

	    // Check the other calls' states.
	    // returns true, if the current call is active only
	    function isOnlyCurrentCallActive(intCallId) {
	        var internalCall = calls[intCallId],
	            callid, otherCallState;

	        if (window.Object.keys(calls).length > 1) {
	            for (callid in calls) {
	                if (calls[callid].id !== internalCall.id) {
	                    otherCallState = _callFSM.getCurrentState(calls[callid]);
	                    if (otherCallState !== fsmState.LOCAL_HOLD &&
	                        otherCallState !== fsmState.BOTH_HOLD) {
	                        return false;
	                    }
	                }
	            }
	        }
	        return true;
	    }

	    self.answer = function(data, onSuccess, onFailure) {
	        var internalCall = calls[data.callid],
	            videoNegotiationAvailable = self.isVideoNegotiationAvailable(data),
	            getUserMediaConstraints = {
	                options: {
	                    audio: prepareAudioConstraints(),
	                    video: prepareVideoConstraints({
	                        isVideoEnabled: data.isVideoEnabled,
	                        videoQuality: data.videoQuality,
	                        videoNegotiationOnAnswer: videoNegotiationAvailable
	                    })
	                }
	            };

	        if (internalCall) {
	            // check if term side tries to answer an audio only call with video
	            if (videoNegotiationAvailable === false && data.isVideoEnabled === true) {
	                logger.error("[callManager.answer] Video Session Not Available Error ");
	                _utils.callFunctionIfExist(onFailure, _fcs.Errors.VIDEO_SESSION_NOT_AVAILABLE);
	                return;
	            }

	            if (internalCall.sdp) {
	                //check with the state machine if the current state would accept an answer.
	                if (_callFSM.getCurrentState(internalCall) !== fsmState.RINGING) {
	                    _utils.callFunctionIfExist(onFailure, _fcs.Errors.STATE);
	                } else {
	                    self.getUserMedia(getUserMediaConstraints, function getUserMediaSuccessCallback(mediaInfo) {
	                        internalCall.isVideoSourceAllowed = mediaInfo.video;
	                        internalCall.isVideoEnabled = data.isVideoEnabled;
	                        _webRtcManager.storeLocalStreamToCall(internalCall, mediaInfo.id);

	                        _webRtcManager.createAnswer(internalCall, function createAnswerSuccessCallback(sdp) {
	                            logger.info("[callManager.answer : sdp ]" + sdp);

	                            //change call state
	                            self.delegateToCallFSM(internalCall, fsmNotificationEvent.answer_GUI);

	                            //send answer call
	                            _callControlService.answerCall(internalCall.id, sdp, function() {
	                                _utils.callFunctionIfExist(onSuccess);
	                                _webRtcManager.addLocalStream(internalCall);
	                            }, function(e) {
	                                _utils.callFunctionIfExist(onFailure, e);
	                            });
	                        }, function createAnswerFailureCallback(e) {
	                            logger.error("[callManager.answer] Error : " + e);
	                            //Change state when the call have failed
	                            //This will trigger send reject
	                            self.delegateToCallFSM(internalCall, fsmNotificationEvent.end_GUI);
	                        }, data.isVideoEnabled, getIceServerUsageStatus());
	                    }, function getUserMediaFailureCallback(e) {
	                        _utils.callFunctionIfExist(onFailure, e);
	                    });
	                }
	            } else {
	                if (_callFSM.getCurrentState(internalCall) !== fsmState.RINGING_SLOW) {
	                    _utils.callFunctionIfExist(onFailure, _fcs.Errors.STATE);
	                } else {
	                    self.getUserMedia(getUserMediaConstraints, function getUserMediaSuccessCallback(mediaInfo) {
	                        internalCall.isVideoSourceAllowed = mediaInfo.video;
	                        internalCall.isVideoEnabled = data.isVideoEnabled;
	                        _webRtcManager.storeLocalStreamToCall(internalCall, mediaInfo.id);

	                        _webRtcManager.createOffer(internalCall, function createOfferSuccessCallback(sdp) {
	                            internalCall.sdp = sdp;

	                            self.delegateToCallFSM(internalCall, fsmNotificationEvent.answer_GUI);

	                            _callControlService.answerCall(internalCall.id, sdp, function() {
	                                _utils.callFunctionIfExist(onSuccess);
	                            }, function(e) {
	                                _utils.callFunctionIfExist(onFailure, e);
	                            });
	                        }, function createOfferFailureCallback(e) {
	                            logger.error("[callManager.offer] Error : " + e);
	                            //Change state when the call have failed
	                            //This will trigger send reject
	                            self.delegateToCallFSM(internalCall, fsmNotificationEvent.end_GUI);
	                        }, data.isVideoEnabled, getIceServerUsageStatus());
	                    }, function getUserMediaFailureCallback(e) {
	                        _utils.callFunctionIfExist(onFailure, e);
	                    });

	                }
	            }
	        }
	    };

	    self.getIncomingCallById = function(data) {
	        var call = null,
	            cachedCall, internalCall;

	        cachedCall = JSON.parse(cache.getItem(data.callid));
	        if (cachedCall) {

	            call = new self.IncomingCall(data.callid, {
	                reject: cachedCall.optionReject,
	                forward: cachedCall.optionForward,
	                answer: cachedCall.optionAnswer
	            });

	            call.canOrigReceiveVideo = _sdpParser.isSdpHasVideo(cachedCall.sdp);

	            call.callerNumber = cachedCall.callerNumber;
	            call.callerName = cachedCall.callerName;
	            call.calleeNumber = cachedCall.calleeNumber;
	            call.primaryContact = cachedCall.primaryContact;

	            internalCall = {
	                "call": call,
	                "sdp": cachedCall.sdp,
	                "id": data.callid
	            };

	            calls[data.callid] = internalCall;

	            self.delegateToCallFSM(internalCall, fsmNotificationEvent.callNotify);
	        }

	        return call;
	    };

	    function cacheCall(internalCall) {
	        var callToCache = {
	            "sdp": internalCall.sdp,
	            "callerNumber": internalCall.call.callerNumber,
	            "callerName": internalCall.call.callerName,
	            "calleeNumber": internalCall.call.calleeNumber,
	            "primaryContact": internalCall.call.primaryContact,
	            "optionReject": internalCall.call.canReject(),
	            "optionForward": internalCall.call.canForward(),
	            "optionAnswer": internalCall.call.canAnswer()
	        };

	        cache.setItem(internalCall.id, JSON.stringify(callToCache));
	    }

	    self.start = function(data, onSuccess, onFailure) {
	        var internalCall = {},
	            getUserMediaConstraints = {
	                options: {
	                    audio: prepareAudioConstraints(),
	                    video: prepareVideoConstraints({
	                        isVideoEnabled: data.isVideoEnabled,
	                        videoQuality: data.videoQuality
	                    })
	                }
	            };

	        logger.info("start call... from: " + data.from +
	            " contact: " + JSON.stringify(data.contact) +
	            " to: " + data.to +
	            " isVideoEnabled: " + data.isVideoEnabled +
	            " sendInitialVideo: " + data.sendInitialVideo +
	            " videoQuality: " + data.videoQuality);

	        self.getUserMedia(getUserMediaConstraints, function getUserMediaSuccessCallback(mediaInfo) {
	            internalCall.isVideoSourceAllowed = mediaInfo.video;
	            internalCall.isVideoEnabled = data.sendInitialVideo;
	            _webRtcManager.storeLocalStreamToCall(internalCall, mediaInfo.id);
	            _webRtcManager.createOffer(internalCall, function createOfferSuccessCallback(sdp) {
	                logger.info("[callManager.start : sdp ]" + sdp);

	                internalCall.sdp = sdp;
	                _callControlService.startCall(
	                    _utils.parseAddress(data.from, data.contact),
	                    _utils.parseAddress(data.to),
	                    sdp,
	                    function(callid) {

	                        internalCall.call = new self.OutgoingCall(callid);
	                        internalCall.id = callid;
	                        internalCall.callerNumber = data.to;

	                        self.delegateToCallFSM(internalCall, fsmNotificationEvent.callStart_GUI);
	                        calls[callid] = internalCall;
	                        // we need to wait until call variable to be created
	                        setTimeout(function() {
	                            _webRtcManager.addLocalStream(internalCall);
	                        }, 10);
	                        _utils.callFunctionIfExist(onSuccess, internalCall.call);
	                    },
	                    function(e) {
	                        //TODO: update call state
	                        _utils.callFunctionIfExist(onFailure, e);
	                    });
	            }, function createOfferFailureCallback(e) {
	                logger.error("[callManager.start] Error : " + e);
	                _utils.callFunctionIfExist(onFailure, e);
	            }, data.sendInitialVideo, getIceServerUsageStatus());
	        }, function getUserMediaFailureCallback(e) {
	            _utils.callFunctionIfExist(onFailure, e);
	        });
	    };

	    self.reject = function(data, onSuccess, onFailure) {
	        var internalCall = calls[data.callid];
	        if (!internalCall) {
	            _utils.callFunctionIfExist(onFailure, _fcs.Errors.STATE);
	            return;
	        }

	        self.delegateToCallFSM(internalCall, fsmNotificationEvent.endReject_GUI);

	        _callControlService.reject(data.callid, function() {
	            _utils.callFunctionIfExist(onSuccess);
	        }, function(e) {
	            _utils.callFunctionIfExist(onFailure, e);
	        });

	    };

	    self.ignore = function(data, onSuccess, onFailure) {
	        var internalCall = calls[data.callid];
	        if (!internalCall) {
	            _utils.callFunctionIfExist(onFailure, _fcs.Errors.STATE);
	            return;
	        }

	        self.delegateToCallFSM(internalCall, fsmNotificationEvent.endIgnore_GUI);
	        _utils.callFunctionIfExist(onSuccess);
	    };
	    self.forward = function(data, onSuccess, onFailure) {
	        var internalCall = calls[data.callid];
	        if (!internalCall) {
	            _utils.callFunctionIfExist(onFailure, _fcs.Errors.STATE);
	            return;
	        }

	        _callControlService.forward(data.callid, data.address, function() {
	            self.delegateToCallFSM(internalCall, fsmNotificationEvent.forward_GUI);
	            _utils.callFunctionIfExist(onSuccess);
	        }, function(e) {
	            _utils.callFunctionIfExist(onFailure, e);
	        });
	    };

	    function handleFailure(internalCall, failureHandler, failureEvent, retry) {
	        setNotificationStateOfCallToBusy(internalCall);
	        _webRtcManager.revertRtcState(internalCall, triggerQueue, triggerQueue);

	        if (failureEvent) {
	            self.delegateToCallFSM(internalCall, failureEvent);
	        }

	        if (retry && retry.timeout) {
	            internalCall.pendingRequestTimer = setTimeout(function() {
	                internalCall.pendingRequestTimer = null;
	                retry.args.push(true);
	                retry.handler.apply(null, retry.args);
	            }, retry.timeout * 1000);
	        } else {
	            if (failureHandler) {
	                // TODO: need to add an error code
	                _utils.callFunctionIfExist(failureHandler);
	            }
	        }
	    }

	    function handleRequestFailure(internalCall, failureHandler, retry) {
	        handleFailure(internalCall, failureHandler,
	            fsmNotificationEvent.requestFailure_JSL, retry);
	    }

	    function handleWebrtcFailure(internalCall, failureHandler) {
	        handleFailure(internalCall, failureHandler,
	            fsmNotificationEvent.webrtcFailure_JSL);
	    }

	    function getIceServerUsageStatus() {
	        if (fcsConfig.ignoreIceParamsForServices && fcsConfig.ignoreIceParamsForServices.indexOf('call') !== -1) {
	            return false;
	        } else {
	            return true;
	        }
	    }

	    self.getMediaStream = function(callId) {
	        var internalCall = calls[callId];
	        return internalCall.localMedia.originalStream;
	    };

	    self.hold = function(data, onSuccess, onFailure) {
	        var internalCall = calls[data.callid],
	            currentCallState;
	        if (!internalCall) {
	            _utils.callFunctionIfExist(onFailure, _fcs.Errors.STATE);
	            return;
	        }

	        if (isNotificationStateOfCallBusy(internalCall)) {
	            _utils.callFunctionIfExist(onFailure, _fcs.Errors.STATE);
	            return;
	        }

	        currentCallState = _callFSM.getCurrentState(internalCall);

	        if (currentCallState !== fsmState.COMPLETED &&
	            currentCallState !== fsmState.REMOTE_HOLD) {
	            _utils.callFunctionIfExist(onFailure, _fcs.Errors.STATE);
	            return;
	        }

	        if (internalCall.pendingRequestTimer) {
	            _utils.callFunctionIfExist(onFailure, _fcs.Errors.PENDING_REQUEST);
	            return;
	        }

	        internalCall.lastUpdateRequest = {
	            handler: self.hold,
	            args: [data, onSuccess, onFailure]
	        };

	        setNotificationStateOfCallToBusy(internalCall);

	        self.delegateToCallFSM(internalCall, fsmNotificationEvent.hold_GUI);
	        _webRtcManager.createHoldUpdate(internalCall,
	            true,
	            (currentCallState === fsmState.REMOTE_HOLD),
	            function(sdp) {
	                logger.debug("[callManager.hold->createHoldUpdate : sdp ]" + sdp);
	                _callControlService.hold(internalCall.id, sdp,
	                    function() {
	                        setNotificationStateOfCallToIdle(internalCall);
	                        _utils.callFunctionIfExist(onSuccess);
	                    },
	                    function(err) {
	                        handleRequestFailure(internalCall, onFailure, {
	                            handler: self.hold,
	                            args: [data, onSuccess, onFailure],
	                            timeout: err.retryAfter
	                        });
	                    });
	            },
	            function() {
	                handleWebrtcFailure(internalCall, onFailure);
	            }, getIceServerUsageStatus());
	    };

	    self.unhold = function(data, onSuccess, onFailure) {
	        var internalCall = calls[data.callid],
	            currentCallState;

	        if (!internalCall) {
	            _utils.callFunctionIfExist(onFailure, _fcs.Errors.STATE);
	            return;
	        }

	        if (isNotificationStateOfCallBusy(internalCall)) {
	            _utils.callFunctionIfExist(onFailure, _fcs.Errors.STATE);
	            return;
	        }

	        currentCallState = _callFSM.getCurrentState(internalCall);

	        if (currentCallState !== fsmState.LOCAL_HOLD &&
	            currentCallState !== fsmState.BOTH_HOLD) {
	            _utils.callFunctionIfExist(onFailure, _fcs.Errors.STATE);
	            return;
	        }

	        if (internalCall.pendingRequestTimer) {
	            _utils.callFunctionIfExist(onFailure, _fcs.Errors.PENDING_REQUEST);
	            return;
	        }

	        if (!isOnlyCurrentCallActive(data.callid)) {
	            _utils.callFunctionIfExist(onFailure, _fcs.Errors.STATE);
	            return;
	        }

	        internalCall.lastUpdateRequest = {
	            handler: self.unhold,
	            args: [data, onSuccess, onFailure]
	        };

	        setNotificationStateOfCallToBusy(internalCall);

	        self.delegateToCallFSM(internalCall, fsmNotificationEvent.unhold_GUI);
	        _webRtcManager.createHoldUpdate(internalCall, false,
	            (currentCallState === fsmState.BOTH_HOLD),
	            function(sdp) {
	                logger.debug("[callManager.unhold->createHoldUpdate : sdp ]" + sdp);
	                _callControlService.unhold(internalCall.id, sdp,
	                    function() {
	                        setNotificationStateOfCallToIdle(internalCall);
	                        _webRtcManager.addLocalStream(internalCall);
	                        _utils.callFunctionIfExist(onSuccess);
	                    },
	                    function(err) {
	                        handleRequestFailure(internalCall, onFailure, {
	                            handler: self.unhold,
	                            args: [data, onSuccess, onFailure],
	                            timeout: err.retryAfter
	                        });
	                    });
	            },
	            function() {
	                handleWebrtcFailure(internalCall, onFailure);
	            }, getIceServerUsageStatus());
	    };

	    self.directTransfer = function(data, onSuccess, onFailure) {
	        var internalCall = calls[data.callid],
	            currentCallState;

	        if (!internalCall) {
	            _utils.callFunctionIfExist(onFailure, _fcs.Errors.STATE);
	            return;
	        }

	        currentCallState = _callFSM.getCurrentState(internalCall);

	        if (currentCallState === fsmState.LOCAL_HOLD || currentCallState === fsmState.BOTH_HOLD || currentCallState === fsmState.COMPLETED) {
	            //TODO: force localhold - if the user is not on hold
	            logger.info("[callManager.directTransfer->sendTransfer : transfer target ]" + data.address);
	            _callControlService.transfer(internalCall.id, _utils.parseAddress(data.address), undefined, function() {
	                self.delegateToCallFSM(internalCall, fsmNotificationEvent.transfering);
	                _utils.callFunctionIfExist(onSuccess);
	                logger.info("[callManager.directTransfer->sentTransfer : transfer target ]" + data.address);
	            }, function(e) {
	                _utils.callFunctionIfExist(onFailure, e);
	            });
	        } else if (currentCallState === fsmState.LOCAL_HOLDING) {
	            if (!internalCall.transferTrigger) {
	                internalCall.transferTrigger = function() {
	                    self.directTransfer(data, onSuccess, onFailure);
	                    delete this.transferTrigger;
	                };
	            }
	        } else {
	            logger.error("directTransfer call is not in correct state: " + currentCallState);
	            utils.callFunctionIfExist(onFailure, fcs.Errors.STATE);
	        }

	    };

	    self.videoUpdate = function(callid, onSuccess, onFailure, retryCallback) {
	        var internalCall = calls[callid],
	            isVideoStart;

	        isVideoStart = internalCall.isVideoEnabled || internalCall.isScreenShared;

	        self.delegateToCallFSM(internalCall, fsmNotificationEvent.videoStopStart_GUI);
	        _webRtcManager.createUpdate(
	            internalCall,
	            function(sdp) {
	                _callControlService.reinvite(internalCall.id, sdp,
	                    function() {
	                        setNotificationStateOfCallToIdle(internalCall);
	                        _webRtcManager.addLocalStream(internalCall);
	                        _utils.callFunctionIfExist(onSuccess);
	                    },
	                    function(err) {
	                        handleRequestFailure(internalCall, onFailure, {
	                            handler: retryCallback,
	                            args: [callid, onSuccess, onFailure],
	                            timeout: err.retryAfter
	                        });
	                    }
	                );
	            },
	            function() {
	                logger.error("reinvite->createUpdate ");
	                handleWebrtcFailure(internalCall, onFailure);
	            },
	            isVideoStart,
	            getIceServerUsageStatus()
	        );
	    };

	    self.videoStopStart = function(data, onSuccess, onFailure) {
	        var internalCall = calls[data.callid],
	            currentCallState,
	            getUserMediaConstraints = {
	                options: {
	                    audio: prepareAudioConstraints(),
	                    video: prepareVideoConstraints({
	                        isVideoEnabled: true,
	                        videoQuality: data.videoQuality
	                    })
	                }
	            };

	        if (!internalCall) {
	            _utils.callFunctionIfExist(onFailure, _fcs.Errors.STATE);
	            return;
	        }

	        if (isNotificationStateOfCallBusy(internalCall)) {
	            _utils.callFunctionIfExist(onFailure, _fcs.Errors.STATE);
	            return;
	        }

	        currentCallState = _callFSM.getCurrentState(internalCall);
	        if (currentCallState !== fsmState.COMPLETED) {
	            _utils.callFunctionIfExist(onFailure, _fcs.Errors.STATE);
	            return;
	        }

	        if (internalCall.pendingRequestTimer) {
	            _utils.callFunctionIfExist(onFailure, _fcs.Errors.PENDING_REQUEST);
	            return;
	        }

	        internalCall.lastUpdateRequest = {
	            handler: self.videoStopStart,
	            args: [data, onSuccess, onFailure]
	        };

	        setNotificationStateOfCallToBusy(internalCall);

	        if (!internalCall.isVideoSourceAllowed && data.isVideoStart) {
	            self.getUserMedia(getUserMediaConstraints, function getUserMediaSuccessCallback(mediaInfo) {
	                internalCall.isVideoSourceAllowed = true;
	                internalCall.isVideoEnabled = true;
	                _webRtcManager.storeLocalStreamToCall(internalCall, mediaInfo.id);

	                // If the screen is shared, we don't need to do an update since the
	                // video state won't have changed.
	                if (!internalCall.isScreenShared) {
	                    self.videoUpdate(data.callid, onSuccess, onFailure, self.videoStopStart);
	                }
	            }, function getUserMediaFailureCallback(e) {
	                _utils.callFunctionIfExist(onFailure, e);
	            });
	        } else {
	            internalCall.isVideoEnabled = data.isVideoStart;

	            // If the screen is shared, we don't need to do an update since the
	            // video state won't have changed.
	            if (!internalCall.isScreenShared) {
	                self.videoUpdate(data.callid, onSuccess, onFailure, self.videoStopStart);
	            }
	        }
	    };

	    self.screenStopStart = function(callid, onSuccess, onFailure, onScreenStop, isScreenStart, options) {
	        var internalCall = calls[callid],
	            currentCallState;

	        if (!internalCall) {
	            utils.callFunctionIfExist(onFailure, fcs.Errors.STATE);
	            return;
	        }

	        if (isNotificationStateOfCallBusy(internalCall)) {
	            utils.callFunctionIfExist(onFailure, fcs.Errors.STATE);
	            return;
	        }

	        currentCallState = _callFSM.getCurrentState(internalCall);
	        if (currentCallState !== fsmState.COMPLETED) {
	            utils.callFunctionIfExist(onFailure, fcs.Errors.STATE);
	            return;
	        }

	        if (internalCall.pendingRequestTimer) {
	            utils.callFunctionIfExist(onFailure, fcs.Errors.PENDING_REQUEST);
	            return;
	        }

	        if (isScreenStart) {

	            // If we are already in the process of starting screensharing, don't
	            // try again until it's done.
	            if (internalCall.isStartingScreenMedia) {
	                utils.callFunctionIfExist(onFailure);
	                return;
	            }

	            internalCall.isStartingScreenMedia = true;

	            _webRtcManager.startScreenMedia(function(mediaInfo) {
	                    internalCall.isScreenShared = true;
	                    internalCall.isStartingScreenMedia = false;
	                    _webRtcManager.updateLocalStreamToCall(internalCall, mediaInfo.id);
	                    self.videoUpdate(callid, onSuccess, onFailure, self.screenStopStart);
	                },
	                function() {
	                    internalCall.isScreenShared = false;
	                    internalCall.isStartingScreenMedia = false;
	                    utils.callFunctionIfExist(onFailure);
	                },
	                options,
	                function() {
	                    if (_callFSM.getCurrentState(internalCall) === fsmState.COMPLETED) {
	                        //Screen sharing video stream has been stopped, act as if someone called screenStopStart
	                        //but pass the result to onScreenStop instead.
	                        self.screenStopStart(callid, onScreenStop, function() {
	                            logger.error("Failed to stop screen properly after user stopped the stream via" +
	                                " the browser controls");
	                        }, false);
	                    } else if (internalCall.isScreenShared) {
	                        internalCall.isScreenShared = false;
	                        _webRtcManager.stopScreenMedia();
	                        utils.callFunctionIfExist(onScreenStop);
	                    }
	                });
	        } else if (internalCall.isScreenShared) {
	            internalCall.isScreenShared = false;
	            _webRtcManager.stopScreenMedia();

	            self.videoUpdate(callid, onSuccess, onFailure, self.screenStopStart);
	        }
	    };

	    self.mute = function(data) {
	        var call = calls[data.callid];
	        if (call) {
	            _utils.callFunctionIfExist(call.call.onMute, data.mute);
	            _webRtcManager.muteAudioTrack(call, data.mute);
	        }
	    };

	    self.sendDTMF = function(data) {
	        var internalCall = calls[data.callid];

	        if (internalCall) {
	            _webRtcManager.sendDTMF(internalCall, data.tone);
	        }
	    };

	    self.join = function(data, onSuccess, onFailure, isVideoEnabled, videoQuality) {
	        var internalCall1 = calls[data.callid1],
	            internalCall2 = calls[data.callid2],
	            newInternalCall = {},
	            currentCallState1,
	            currentCallState2,
	            getUserMediaConstraints = {
	                options: {
	                    audio: prepareAudioConstraints(),
	                    video: prepareVideoConstraints({
	                        isVideoEnabled: isVideoEnabled,
	                        videoQuality: videoQuality
	                    })
	                }
	            };

	        if ((internalCall1) && (internalCall2)) {
	            currentCallState1 = _callFSM.getCurrentState(internalCall1);
	            currentCallState2 = _callFSM.getCurrentState(internalCall2);
	            if (currentCallState1 === fsmState.LOCAL_HOLDING ||
	                currentCallState2 === fsmState.LOCAL_HOLDING) {
	                _utils.callFunctionIfExist(onFailure, _fcs.Errors.PENDING_REQUEST);
	                return;
	            }
	            if ((currentCallState1 === fsmState.LOCAL_HOLD ||
	                    currentCallState1 === fsmState.REMOTE_HOLD ||
	                    currentCallState1 === fsmState.BOTH_HOLD) &&
	                (currentCallState2 === fsmState.LOCAL_HOLD ||
	                    currentCallState2 === fsmState.REMOTE_HOLD ||
	                    currentCallState2 === fsmState.BOTH_HOLD)) {

	                self.getUserMedia(getUserMediaConstraints, function(mediaInfo) {
	                    newInternalCall.isVideoSourceAllowed = mediaInfo.video;
	                    _webRtcManager.storeLocalStreamToCall(newInternalCall, mediaInfo.id);
	                    _webRtcManager.createOffer(newInternalCall,
	                        function(sdp) {
	                            logger.info("join->doOffer : sdp " + sdp);
	                            newInternalCall.sdp = sdp;
	                            _callControlService.join(
	                                internalCall1.id,
	                                internalCall2.id,
	                                sdp,
	                                function(callid) {

	                                    newInternalCall.call = new self.OutgoingCall(callid);
	                                    newInternalCall.id = callid;
	                                    newInternalCall.firstInternalCallId = internalCall1.id;
	                                    newInternalCall.secondInternalCallId = internalCall2.id;

	                                    // refer will be handled by client. We are going to need callID of partyB and partyC
	                                    if (fcsConfig.clientControlled === "true") {
	                                        newInternalCall.isReferer = true;
	                                        newInternalCall.refer1ID = internalCall1.id;
	                                        newInternalCall.refer2ID = internalCall2.id;
	                                    }

	                                    self.delegateToCallFSM(internalCall1, fsmNotificationEvent.joining_Notify);
	                                    self.delegateToCallFSM(internalCall2, fsmNotificationEvent.joining_Notify);
	                                    self.delegateToCallFSM(newInternalCall, fsmNotificationEvent.joiningSuccess_Notify);
	                                    calls[callid] = newInternalCall;

	                                    _utils.callFunctionIfExist(onSuccess, newInternalCall.call);
	                                },
	                                function(e) {
	                                    logger.error("callControlService.join Failed!! sdp " + sdp);
	                                    _utils.callFunctionIfExist(onFailure, e);
	                                });
	                        },
	                        function(e) {
	                            logger.error("doOffer Failed!!");
	                            _utils.callFunctionIfExist(onFailure, e);
	                        }, isVideoEnabled, getIceServerUsageStatus());
	                }, function(e) {
	                    _utils.callFunctionIfExist(onFailure, e);
	                });
	            } else {
	                _utils.callFunctionIfExist(onFailure, _fcs.Errors.STATE);
	            }
	        }
	    };

	    self.transfer = function() {

	    };

	    self.end = function(data, onSuccess) {
	        var internalCall = calls[data.callid];
	        if (internalCall) {
	            //check with the state machine if the current state would accept an endCall.
	            if (_callFSM.getCurrentState(internalCall) === fsmState.INIT) {
	                logger.error("Cannot end call in INIT callstate :" + _fcs.Errors.STATE);
	            } else {
	                //send the end call to webrtc abstraction, change call state
	                //this will trigger the send endcall or reject call
	                self.delegateToCallFSM(internalCall, fsmNotificationEvent.end_GUI);

	                clearResources(internalCall, true);
	                _utils.callFunctionIfExist(onSuccess);
	            }
	        }

	    };

	    self.clickToCall = function(data, onSuccess, onFailure) {
	        _callControlService.clickToCall(data.callingParty, data.calledParty, function() {
	            _utils.callFunctionIfExist(onSuccess);
	        }, function(e) {
	            _utils.callFunctionIfExist(onFailure, e);
	        });
	    };

	    self.getIMRN = function(data, onSuccess, onFailure) {
	        _callControlService.getIMRN(data.realm, data.source, data.destination, function() {
	            _utils.callFunctionIfExist(onSuccess);
	        }, function(e) {
	            _utils.callFunctionIfExist(onFailure, e);
	        });
	    };

	    self.cerateIncomingCallInFSM = function(call, sdp) {

	        logger.info("incomingCall : sdp = " + sdp);
	        var internalCall = {
	            "call": call,
	            "sdp": sdp,
	            "id": call.getId()
	        };
	        logger.info("incomingCall: " + call.getId());

	        if (fcsConfig.continuity && call.canAnswer()) {
	            cacheCall(internalCall);
	        }

	        calls[call.getId()] = internalCall;
	        self.delegateToCallFSM(internalCall, fsmNotificationEvent.callNotify);
	    };


	    self.updateCall = function() {};

	    self.onNotificationEvent = function(type, sessionParams) {
	        var callid = sessionParams.sessionData,
	            statusCode = sessionParams.statusCode,
	            reasonText = sessionParams.reasonText,
	            sdp = sessionParams.sdp,
	            referTo = sessionParams.referTo,
	            referredBy = sessionParams.referredBy,
	            retryAfter = sessionParams.retryAfter,
	            internalCall = calls[callid];

	        logger.debug("Notification received " + type + " callid:" + callid);
	        logger.debug("onNotificationEvent : sdp " + sdp);
	        if (internalCall) {
	            if (isQueueEnabled && isNotificationStateOfCallBusy(internalCall) &&
	                (type !== fsmNotificationEvent.callEnd_Notify) && (type !== fsmNotificationEvent.callCancel_Notify)) {
	                logger.debug("NOTIFICATION_QUEUE: notification state is busy, adding process to the queue!");
	                internalCall.call.notificationQueue.enqueue({
	                    type: type,
	                    sessionParams: sessionParams
	                });
	                logger.debug("NOTIFICATION_QUEUE: queue size is now " + internalCall.call.notificationQueue.size());
	                return;
	            }

	            if (isQueueEnabled) {
	                setNotificationStateOfCallToBusy(internalCall);
	            }

	            if (sdp) {
	                internalCall.prevRemoteSdp = internalCall.sdp;
	                sdp = _sdpParser.deleteGoogleIceFromSdp(sdp);
	                internalCall.sdp = sdp;
	            }
	            if (referTo && referredBy) {
	                internalCall.referTo = referTo;
	                internalCall.referredBy = referredBy;
	            }

	            internalCall.retryAfter = retryAfter;
	            internalCall.statusCode = statusCode;
	            internalCall.reasonText = reasonText;
	        }
	        self.delegateToCallFSM(internalCall, type);
	    };

	    self.onStateChange = function(call, event) {
	        var callStates = CALL_STATES,
	            transferEvent = _callFSM.TransferEvent,
	            i, isJoin, isLocalHold, auditTimerDelay, startAuditTimer,
	            internalCall1, internalCall2;

	        calls[call.id] = call;


	        function triggerCallState(state, doNotTriggerQueue) {
	            logger.debug("triggerCallState:  state =   " + state + "    call.statusCode =  " + call.statusCode + "   call.reasonText =  " + call.reasonText);
	            call.call.callState = state;
	            _utils.callFunctionIfExist(call.call.onStateChange, state, call.statusCode, call.reasonText, {
	                localStatusCode: call.localStatusCode,
	                localReasonText: call.localReasonText
	            });
	            if (!doNotTriggerQueue) {
	                triggerQueue(call);
	            }
	        }

	        function triggerCallStateWithoutQueue(state) {
	            triggerCallState(state, true);
	        }

	        auditTimerDelay = function() {
	            setTimeout(function() {
	                if (_fcs.isConnected()) {
	                    _callControlService.audit(call.id, function() {
	                        logger.info("Audit kicked off: Success for: " + call.id);
	                    }, function() {
	                        logger.error("Audit: Fail for: " + call.id);
	                        // no need to end the call after audit fail
	                    });
	                }
	            }, AUDIT_KICKOFF_TIMEOUT);
	        };

	        startAuditTimer = function() {
	            call.call.setAuditTimer(function() {
	                if (_fcs.isConnected()) {
	                    _callControlService.audit(call.id, function() {
	                        logger.info("Audit: Success for: " + call.id);
	                    }, function() {
	                        logger.error("Audit: Fail for: " + call.id);
	                        // no need to end the call after audit fail
	                        triggerQueue(call);
	                    });
	                }
	            });
	        };

	        logger.info("Transfer Event: " + event + ". callId: " + call.id);
	        switch (event) {
	            case transferEvent.startCallReplace_fsm:
	                triggerCallState(callStates.REPLACING);
	                break;
	            case transferEvent.callStart_fsm:
	            case transferEvent.localHolding_fsm:
	            case transferEvent.localUnHolding_fsm:
	            case transferEvent.localVideoStopStart_fsm:
	            case transferEvent.slowStartOfferProcessed_fsm:
	            case transferEvent.joiningSuccess_fsm:
	            case transferEvent.rejectWithoutClearCallObject_GUI:
	            case transferEvent.deviceChange_fsm:
	                break;
	            case transferEvent.ignoredNotification_fsm:
	            case transferEvent.answeringRingingSlow_fsm:
	            case transferEvent.localHold_fsm:
	            case transferEvent.localUnHold_fsm:
	            case transferEvent.answerRingingSlow_fsm:
	                triggerQueue(call);
	                break;
	            case transferEvent.transfering_fsm:
	                triggerQueue(call);
	                break;
	            case transferEvent.ringing_fsm:
	                triggerCallState(callStates.RINGING);
	                break;
	            case transferEvent.callReceived_fsm:
	                if (!(call.sdp)) {
	                    self.delegateToCallFSM(call, fsmNotificationEvent.callNotify_noSDP);
	                }
	                triggerCallState(callStates.INCOMING);
	                break;
	            case transferEvent.answer_fsm:
	                auditTimerDelay();
	                startAuditTimer();
	                triggerCallState(callStates.IN_CALL);
	                break;
	            case transferEvent.ignore_GUI:
	                call.localStatusCode = LOCAL_STATUS_CODES.IGNORED_BY_LOCAL;
	                call.localReasonText = LOCAL_REASON_TEXTS.IGNORED_BY_LOCAL;
	                clearCallObject(call);
	                triggerCallState(callStates.ENDED);
	                break;
	            case transferEvent.respondedFromAnotherDevice_fsm:
	                call.localStatusCode = LOCAL_STATUS_CODES.RESPONDED_FROM_ANOTHER_DEVICE;
	                call.localReasonText = LOCAL_REASON_TEXTS.RESPONDED_FROM_ANOTHER_DEVICE;
	                clearCallObject(call);
	                triggerCallState(callStates.ENDED);
	                break;
	            case transferEvent.reject_GUI:
	            case transferEvent.forward_fsm:
	                clearResources(call);
	                break;
	            case transferEvent.sessionComplete_fsm:
	                _callControlService.endCall(call.id, function() {
	                    logger.info("callControlService.endCall successful. callId: " + call.id);
	                }, function() {
	                    logger.error("callControlService.endCall FAILED!!.callId: " + call.id);
	                });
	                clearResources(call);
	                triggerCallState(callStates.JOINED);
	                break;
	            case transferEvent.sessionFail_fsm:
	            case transferEvent.transferFail_fsm:
	                triggerCallState(callStates.TRANSFER_FAILURE);
	                break;
	            case transferEvent.replaceCallCompleted_fsm:
	            case transferEvent.callCompleted_fsm:
	                // Workaround for webrtc dtls and firefox pranswer support bug. Can be removed when fixed by browsers.
	                // dtls is enabled listened early media as answer. Now has to create a new peer for actual answer sdp.
	                if (_webRtcManager.isDtlsEnabled() && call.peer.signalingState === CONSTANTS.WEBRTC.RTC_SIGNALING_STATE.STABLE) {
	                    logger.info("Handle answer sdp after session progress when dtls is enabled. Create new peer workaround.");
	                    self.delegateToCallFSM(call, fsmNotificationEvent.performCreateNewPeerWorkaround_JSL);
	                    break;
	                }

	                auditTimerDelay();
	                _webRtcManager.processAnswer(call,
	                    function() {
	                        startAuditTimer();
	                        triggerCallState(callStates.IN_CALL);
	                    },
	                    function(err) {
	                        if (err === CONSTANTS.WEBRTC.ERROR.ICE_ICELITE) {
	                            logger.info("ice-lite - ice change. Create new peer workaround.");
	                            self.delegateToCallFSM(call, fsmNotificationEvent.performCreateNewPeerWorkaround_JSL);
	                        } else {
	                            clearResources(call);
	                            triggerCallState(callStates.ENDED);
	                        }
	                    });
	                //if client is handling the refers, we need to trigger the refers for partyB and partyC from referer
	                if (call.isReferer) {
	                    for (i in calls) {
	                        if (calls.hasOwnProperty(i)) {
	                            if (calls[i] && (calls[i].id === call.refer1ID || calls[i].id === call.refer2ID)) {
	                                calls[i].referCall(call.referTo, call.referredBy);
	                            }
	                        }
	                    }
	                }
	                break;
	            case transferEvent.startCallReplaceRejected_fsm:
	            case transferEvent.noAnswer_fsm:
	                clearResources(call);
	                triggerCallState(callStates.ENDED);
	                break;
	            case transferEvent.remoteEnd_fsm:
	                if ((call.firstInternalCallId) && (call.secondInternalCallId)) {
	                    internalCall1 = calls[call.firstInternalCallId];
	                    self.delegateToCallFSM(internalCall1, fsmNotificationEvent.revertState_JSL);
	                    internalCall2 = calls[call.secondInternalCallId];
	                    self.delegateToCallFSM(internalCall2, fsmNotificationEvent.revertState_JSL);
	                }
	                // if call's previous call state is RINGING check replacingCallId value
	                if (call.previousState === fsmState.RINGING && call.replacingCallId) {
	                    var replacingCall = calls[call.replacingCallId];
	                    // if there us replacingCallId and replacing call 's state is active then unmute it
	                    if (replacingCall) {
	                        logger.info("[onStateChange] replacing call's state: " + replacingCall.currentState);
	                        if (replacingCall.currentState === fsmState.COMPLETED) {
	                            logger.info("[onStateChange] replacing call has unmuted: " + replacingCall.currentState);
	                            replacingCall.call.unmute();
	                        }
	                    } else {
	                        logger.info("[onStateChange] replacing call has not found, replacingCallId: " + call.replacingCallId);
	                    }
	                }

	                if (!call.localStatusCode && !call.localReasonText) {
	                    call.localStatusCode = LOCAL_STATUS_CODES.STATUS_CODE_NOT_PROVIDED;
	  	                call.localReasonText = LOCAL_REASON_TEXTS.STATUS_CODE_NOT_PROVIDED;
	                }

	                clearResources(call);
	                triggerCallState(callStates.ENDED);
	                break;
	            case transferEvent.localEnding_fsm:
	                _callControlService.endCall(call.id, function() {
	                    logger.info("CallControlService endCall successful. callId: " + call.id);
	                }, function() {
	                    logger.error("Cannot callControlService endCall. callId: " + call.id);
	                });
	                call.localStatusCode = LOCAL_STATUS_CODES.ENDED_BY_LOCAL;
	                call.localReasonText = LOCAL_REASON_TEXTS.ENDED_BY_LOCAL;
	                clearCallObject(call);
	                triggerCallState(callStates.ENDED);
	                break;
	            case transferEvent.localEndingWithoutClearCallObject_fsm:
	                _callControlService.endCall(call.id, function() {
	                    logger.info("CallControlService endCall successful. callId: " + call.id);
	                }, function() {
	                    logger.error("Cannot callControlService endCall. callId: " + call.id);
	                });
	                break;
	            case transferEvent.localEnd_fsm:
	                call.localStatusCode = LOCAL_STATUS_CODES.ENDED_BY_LOCAL;
	                call.localReasonText = LOCAL_REASON_TEXTS.ENDED_BY_LOCAL;
	                clearCallObject(call);
	                triggerCallState(callStates.ENDED);
	                break;
	            case transferEvent.localReject_fsm:
	                call.localStatusCode = LOCAL_STATUS_CODES.REJECTED_BY_LOCAL;
	                call.localReasonText = LOCAL_REASON_TEXTS.REJECTED_BY_LOCAL;
	                clearCallObject(call);
	                triggerCallState(callStates.ENDED);
	                break;
	            case transferEvent.callCompletedAnswering_fsm:
	                logger.info("callManager: Call Completed Answering Event. callId: " + call.id);
	                var isRemoteHold;
	                if (call.sdp) {
	                    _sdpParser.init(call.sdp);
	                    isRemoteHold = _sdpParser.isRemoteHold();
	                }
	                _webRtcManager.processAnswer(call, function () {
	                    if (isRemoteHold) {
	                        call.currentState =  fsmState.REMOTE_HOLD;
	                        triggerCallState(callStates.ON_REMOTE_HOLD);
	                    } else {
	                        triggerCallState(callStates.IN_CALL);
	                    }
	                    auditTimerDelay();
	                    startAuditTimer();
	                }, function () {
	                    clearResources(call);
	                    triggerCallState(callStates.ENDED);
	                });
	                break;
	            case transferEvent.remoteHold_fsm:
	                switch (_callFSM.getCurrentState(call)) {
	                    case fsmState.REMOTE_HOLD:
	                        triggerCallState(callStates.ON_REMOTE_HOLD);
	                        break;
	                    case fsmState.BOTH_HOLD:
	                        triggerCallState(callStates.ON_HOLD);
	                        break;
	                    default:
	                        triggerQueue(call);
	                        break;
	                }
	                break;
	            case transferEvent.remoteUnHold_fsm:
	                switch (_callFSM.getCurrentState(call)) {
	                    case fsmState.LOCAL_HOLD:
	                        triggerCallState(callStates.ON_HOLD);
	                        break;
	                    case fsmState.COMPLETED:
	                        triggerCallState(callStates.IN_CALL);
	                        break;
	                    default:
	                        triggerQueue(call);
	                        break;
	                }
	                break;
	            case transferEvent.remoteHolding_fsm:
	                isLocalHold = (_callFSM.getCurrentState(call) === fsmState.LOCAL_HOLD) || (_callFSM.getCurrentState(call) === fsmState.BOTH_HOLD);
	                _webRtcManager.processHold(call, true, isLocalHold, function(sdp) {
	                    logger.info("[callManager.onStateChange.transferEvent.remoteHold_fsm->processHold : sdp ]" + sdp);
	                    _callControlService.respondCallUpdate(call.id, sdp, function() {
	                        logger.info("Remote Hold Transfer Event Successful. callId: " + call.id);
	                        self.delegateToCallFSM(call, fsmNotificationEvent.remoteHoldProcessed_JSL);
	                    }, function(errorStr) {
	                        logger.error("Remote Hold Transfer Event FAILED!! - " + errorStr);
	                        handleRequestFailure(call);
	                    });
	                }, function(errorStr) {
	                    logger.error("Remote Hold FAILED!! - " + errorStr);
	                    handleWebrtcFailure(call);
	                }, getIceServerUsageStatus());
	                break;
	            case transferEvent.remoteOfferDuringLocalHold_fsm:
	                _webRtcManager.processRemoteOfferOnLocalHold(call, function(sdp) {
	                    logger.info("onStateChange.transferEvent.remoteOfferDuringLocalHold_fsm : sdp " + sdp);
	                    _callControlService.respondCallUpdate(call.id, sdp, function() {
	                        logger.info("Remote Offer During Local Hold Transfer Event successful. callId: " + call.id);
	                        triggerQueue(call);
	                    }, function(errorStr) {
	                        handleRequestFailure(call);
	                        logger.error("Remote Offer During Local Hold  Transfer Event FAILED!! - " + errorStr);
	                    });
	                }, function(errorStr) {
	                    logger.error("Remote Offer During Local Hold FAILED!! - " + errorStr);
	                    handleWebrtcFailure(call);
	                });
	                break;
	            case transferEvent.slowStartOfferDuringOnCall_fsm:
	            case transferEvent.slowStartOfferDuringRemoteHold_fsm:
	                _webRtcManager.createReOffer(call, function(sdp) {
	                    logger.info("onStateChange.transferEvent.createReOffer: sdp " + sdp);
	                    _callControlService.respondCallUpdate(call.id, sdp, function() {
	                        logger.info("Slow Start Offer respondCallUpdate successful. callId: " + call.id);
	                        self.delegateToCallFSM(call, fsmNotificationEvent.slowStartOfferProcessed_JSL);
	                        triggerQueue(call);
	                    }, function(errorStr) {
	                        logger.error("Slow Start Offer respondCallUpdate FAILED!! - " + errorStr);
	                        handleRequestFailure(call);
	                    });
	                }, function(errorStr) {
	                    logger.error("Slow Start Offer createReOffer FAILED!! - " + errorStr);
	                    handleWebrtcFailure(call);
	                }, undefined, getIceServerUsageStatus());
	                break;
	            case transferEvent.performReconnectWorkaround_fsm:
	                _webRtcManager.createReOffer(call, function createReOfferSuccessCallback(sdp) {
	                    logger.info("onStateChange.transferEvent.createReOffer : sdp " + sdp);
	                    _callControlService.reinvite(call.id, sdp, function reInviteSuccessCallback() {
	                        setNotificationStateOfCallToIdle(call);
	                        _webRtcManager.addLocalStream(call);
	                        logger.info("callControlService.reinvite successful. callId: " + call.id);
	                    }, function() {
	                        self.delegateToCallFSM(call, fsmNotificationEvent.requestFailure_JSL);
	                    });
	                }, function() {
	                    handleWebrtcFailure(call);
	                }, true, getIceServerUsageStatus());
	                break;
	            case transferEvent.performCreateNewPeerWorkaround_fsm:
	                logger.info("performCreateNewPeerWorkaround_fsm");
	                _webRtcManager.createReOffer(call,
	                    function createReOfferSuccessCallback(sdp) {
	                        logger.info("createReOfferSuccessCallback: sdp " + sdp);
	                        _callControlService.reinvite(call.id, sdp,
	                            function reInviteSuccessCallback() {
	                                logger.info("reInviteSuccessCallback.");
	                                _webRtcManager.addLocalStream(call);
	                                startAuditTimer();
	                                triggerQueue(call);
	                            },
	                            function reInviteFailureCallback() {
	                                logger.info("reInviteFailureCallback.");
	                                self.end({
	                                    callid: call.id
	                                }, function() {
	                                    logger.info("end success.");
	                                    clearResources(call);
	                                    triggerCallState(callStates.ENDED);
	                                });
	                            });
	                    },
	                    function createReOfferFailureCallback() {
	                        self.end({
	                            callid: call.id
	                        }, function() {
	                            logger.info("end success.");
	                            clearResources(call);
	                            triggerCallState(callStates.ENDED);
	                        });
	                    }, true, getIceServerUsageStatus());
	                break;
	            case transferEvent.remoteUnHolding_fsm:
	                isLocalHold = (call.previousState === fsmState.LOCAL_HOLD) || (call.previousState === fsmState.BOTH_HOLD);
	                _webRtcManager.processHold(call, false, isLocalHold, function(sdp) {
	                    logger.info("onStateChange.transferEvent.remoteUnHold_fsm->processHold : sdp " + sdp);
	                    _callControlService.respondCallUpdate(call.id, sdp, function() {
	                        logger.info("Remote UnHold Transfer Event successful. callId: " + call.id);
	                        self.delegateToCallFSM(call, fsmNotificationEvent.remoteUnHoldProcessed_JSL);
	                    }, function(errorStr) {
	                        logger.error("Remote UnHold Transfer Event FAILED!! - " + errorStr);
	                        handleRequestFailure(call);
	                    });
	                }, function(errorStr) {
	                    logger.error("Remote UnHold FAILED!! - " + errorStr);
	                    handleWebrtcFailure(call);
	                }, getIceServerUsageStatus());
	                break;
	            case transferEvent.renegotiationCompleted_fsm:
	                triggerCallState(callStates.RENEGOTIATION);
	                break;
	            case transferEvent.remoteOffer_fsm:
	            case transferEvent.remoteCallUpdate_fsm:
	                _webRtcManager.processUpdate(call, function(sdp) {
	                    logger.info("onStateChange.transferEvent.remoteCallUpdate_fsm->processUpdate : sdp " + sdp);
	                    _callControlService.respondCallUpdate(call.id, sdp, function() {
	                        logger.info("Remote Call Update Transfer Event Successful. callId: " + call.id);
	                        self.delegateToCallFSM(call, fsmNotificationEvent.remoteOfferProcessed_JSL);
	                    }, function(errorStr) {
	                        logger.error("Remote Call Update Transfer Event FAILED!! - " + errorStr);
	                        handleRequestFailure(call);
	                    });
	                }, function(errorStr) {
	                    logger.error("Remote Call Update FAILED!! - " + errorStr);
	                    handleWebrtcFailure(call);
	                }, call.currentState === fsmState.LOCAL_HOLD ? true : false, getIceServerUsageStatus());
	                break;
	            case transferEvent.respondCallHoldUpdate_fsm:
	                isJoin = call.call.getJoin();
	                _webRtcManager.processHoldRespond(call, function() {
	                    logger.info("Respond Call Hold Update Event Successful. callId: " + call.id);
	                    switch (_callFSM.getCurrentState(call)) {
	                        case fsmState.REMOTE_HOLD:
	                            triggerCallState(callStates.ON_REMOTE_HOLD);
	                            break;
	                        case fsmState.LOCAL_HOLD:
	                        case fsmState.BOTH_HOLD:
	                            triggerCallState(callStates.ON_HOLD);
	                            if (typeof call.transferTrigger === 'function') {
	                                call.transferTrigger();
	                            }
	                            break;
	                        case fsmState.COMPLETED:
	                            triggerCallState(callStates.IN_CALL);
	                            break;
	                    }
	                }, function(e) {
	                    logger.error("Respond Call Hold Update Event FAILED: " + e);
	                    triggerQueue(call);
	                }, isJoin);

	                //enable clicking
	                call.call.setButtonDisabler(false);
	                call.call.clearBtnTimeout();

	                if (isJoin === true) {
	                    call.call.onJoin();
	                }

	                break;
	            case transferEvent.respondCallUpdate_fsm:
	                isJoin = call.call.getJoin();

	                //enable clicking
	                call.call.setButtonDisabler(false);
	                call.call.clearBtnTimeout();

	                //If this is a join call we need to send join request
	                //onJoin() function is created at callController.js
	                if (isJoin === true) {
	                    _webRtcManager.processRespond(call, function() {
	                        logger.info("Respond Call Update Event Successful. callId: " + call.id);
	                        triggerCallState(callStates.RENEGOTIATION);
	                    }, function(e) {
	                        logger.error("Respond Call Update Event FAILED: " + e);
	                        triggerQueue(call);
	                    }, isJoin);

	                    call.call.onJoin();
	                } else {
	                    _webRtcManager.processRespond(call, function() {
	                        logger.info("Respond Call Update Event Successful. callId: " + call.id);
	                        switch (_callFSM.getCurrentState(call)) {
	                            case fsmState.REMOTE_HOLD:
	                                triggerCallState(callStates.ON_REMOTE_HOLD);
	                                break;
	                            case fsmState.BOTH_HOLD:
	                                triggerCallState(callStates.ON_HOLD);
	                                break;
	                            case fsmState.LOCAL_HOLD:
	                                triggerCallState(callStates.ON_HOLD);
	                                break;
	                            case fsmState.COMPLETED:
	                                triggerCallState(callStates.IN_CALL);
	                                break;
	                        }
	                    }, function(e) {
	                        logger.error("Respond Call Update Event FAILED: " + e);
	                        triggerQueue(call);
	                    }, isJoin);
	                }
	                break;
	            case transferEvent.remotePranswer_fsm:
	                // Workaround for webrtc dtls and firefox pranswer support bug. Can be removed when fixed by browsers.
	                // https://code.google.com/p/webrtc/issues/detail?id=3349
	                // https://bugzilla.mozilla.org/show_bug.cgi?id=1004510
	                if (_webRtcManager.isDtlsEnabled()) {
	                    if (call.peer.signalingState === CONSTANTS.WEBRTC.RTC_SIGNALING_STATE.STABLE) {
	                        logger.info("Only first sessionProgress notification is processed, so ignoring this one.");
	                        triggerQueue(call);
	                    } else {
	                        _webRtcManager.processAnswer(call,
	                            function() {
	                                triggerCallState(callStates.EARLY_MEDIA);
	                            },
	                            function(e) {
	                                logger.error("Process answer for session progress FAILED: " + e);
	                                triggerQueue(call);
	                            });
	                    }
	                } else {
	                    _webRtcManager.processPreAnswer(
	                        call,
	                        function() {
	                            triggerCallState(callStates.EARLY_MEDIA);
	                        },
	                        function(e) {
	                            logger.error("Process pranswer FAILED: " + e);
	                            triggerQueue(call);
	                        }
	                    );
	                }
	                break;
	            case transferEvent.joining_fsm:
	                //if client is handling the refers from referer we need to trigger the refers for partyB and partyC
	                if (fcsConfig.clientControlled === "true") {
	                    call.referCall = function(referTo, referredBy) {
	                        _callControlService.refer(call.id, referTo, referredBy, function() {
	                            logger.info("Joining Event Successful. callId: " + call.id);
	                            self.delegateToCallFSM(call, fsmNotificationEvent.refer_JSL);
	                        }, function(errorStr) {
	                            logger.error("Joining Event FAILED!!" + errorStr);
	                        });
	                    };
	                }
	                triggerQueue(call);
	                break;
	            case transferEvent.transferSuccess_fsm:
	                _callControlService.endCall(call.id, function() {
	                    logger.info("callControlService.endCall successful. callId: " + call.id);
	                }, function() {
	                    logger.error("callControlService.endCall FAILED!! callId: " + call.id);
	                });
	                clearResources(call);
	                triggerCallState(callStates.TRANSFERRED);
	                call.localStatusCode = LOCAL_STATUS_CODES.SESSION_COMPLETED;
	                call.localReasonText = LOCAL_REASON_TEXTS.SESSION_COMPLETED;
	                triggerCallState(callStates.ENDED);
	                logger.info("endCall successful. callId: " + call.id);
	                break;
	            case transferEvent.stateReverted_fsm:
	                //enable clicking
	                call.call.setButtonDisabler(false);
	                call.call.clearBtnTimeout();

	                switch (_callFSM.getCurrentState(call)) {
	                    case fsmState.REMOTE_HOLD:
	                        triggerCallStateWithoutQueue(callStates.ON_REMOTE_HOLD);
	                        break;
	                    case fsmState.BOTH_HOLD:
	                        triggerCallStateWithoutQueue(callStates.ON_HOLD);
	                        break;
	                    case fsmState.LOCAL_HOLD:
	                        triggerCallStateWithoutQueue(callStates.ON_HOLD);
	                        break;
	                    case fsmState.COMPLETED:
	                        triggerCallStateWithoutQueue(callStates.IN_CALL);
	                        break;
	                    default:
	                        logger.error("CANNOT REVERT THE STATE: " + _callFSM.getCurrentState(call) + ". callId: " + call.id);
	                        break;
	                }
	                break;
	            case transferEvent.glareCondition_fsm:
	                handleFailure(call, null, null, {
	                    handler: call.lastUpdateRequest.handler,
	                    args: call.lastUpdateRequest.args,
	                    timeout: call.retryAfter
	                });
	                break;
	            default:
	                logger.error("Undefined transition event: " + event + " for " + call.id);
	                triggerQueue(call);
	                break;

	        }

	    };

	    self.refreshVideoRenderer = function(data) {
	        var internalCall = calls[data.callid];
	        if (internalCall) {
	            _webRtcManager.refreshVideoRenderer(internalCall);
	        }
	    };

	    self.hasVideoDevice = function() {
	        return _webRtcManager.isVideoSourceAvailable();
	    };

	    self.hasAudioDevice = function() {
	        return _webRtcManager.isAudioSourceAvailable();
	    };

	    self.hasScreenSharing = function() {
	        return _webRtcManager.isScreenSourceAvailable();
	    };

	    self.getLocalVideoResolutions = function() {
	        return _webRtcManager.getLocalVideoResolutions();
	    };

	    self.getRemoteVideoResolutions = function() {
	        return _webRtcManager.getRemoteVideoResolutions();
	    };

	    self.isCallMuted = function(data) {
	        return _webRtcManager.isAudioMuted(calls[data.callid]);
	    };

	    /* DEPRECIATED */
	    self.isVideoNegotationAvailable = function(data) {
	        var call = calls[data.callid];
	        if (call.sdp) {
	            return _sdpParser.isSdpHasVideo(call.sdp);
	        } else {
	            return false;
	        }
	    };

	    self.isVideoNegotiationAvailable = function(data) {
	        var call = calls[data.callid];
	        if (call.sdp) {
	            return _sdpParser.isSdpHasVideo(call.sdp);
	        } else {
	            return false;
	        }
	    };

	    self.getRemoteVideoState = function(callid) {
	        var call = calls[callid];
	        if (call.sdp) {
	            return call.remoteVideoState;
	        } else {
	            return false;
	        }
	    };

	    self.isSendInitialVideoEnabled = function(data) {
	        var call = calls[data.callid];
	        if (call.sdp) {
	            return _sdpParser.isSdpVideoSendEnabled(call.sdp);
	        } else {
	            return false;
	        }
	    };

	    self.getHoldStateOfCall = function(data) {
	        var internalCall = calls[data.callid];
	        if (internalCall) {
	            return CALL_HOLD_STATES[_callFSM.getCurrentState(internalCall)];
	        }
	        return undefined;
	    };

	    self.canOriginatorSendLocalVideo = function(data) {
	        var call = calls[data.callid];
	        if (call) {
	            return _webRtcManager.canOriginatorSendLocalVideo(call);
	        }
	        return false;
	    };

	    self.canOriginatorReceiveRemoteVideo = function(data) {
	        var call = calls[data.callid];
	        if (call) {
	            return _webRtcManager.canOriginatorReceiveRemoteVideo(call);
	        }
	        return false;
	    };

	    self.getStreamById = function(data) {
	        return _webRtcManager.getStreamById(data.streamId);
	    };

	    self.removeStreamById = function(data) {
	        _webRtcManager.removeStreamById(data.streamId);
	    };

	    self.setSelectedMicrophoneId = function(data) {
	        _webRtcManager.setSelectedMicrophoneId(data.microphoneId);
	    };

	    self.setSelectedSpeakerId = function(data) {
	        _webRtcManager.setSelectedSpeakerId(data.speakerId);
	    };

	    self.setSelectedCameraId = function(data) {
	        _webRtcManager.setSelectedCameraId(data.cameraId);
	    };

	    self.getSelectedMicrophoneId = function() {
	        return _webRtcManager.getSelectedMicrophoneId();
	    };

	    self.getSelectedSpeakerId = function() {
	        return _webRtcManager.getSelectedSpeakerId();
	    };

	    self.getSelectedCameraId = function() {
	        return _webRtcManager.getSelectedCameraId();
	    };

	    self.getCameraList = function(params) {
	        _webRtcManager.getCameraList(function(cameraList) {
	            _utils.callFunctionIfExist(params.onSuccess, cameraList);
	        });
	    };

	    self.getMicrophoneList = function(params) {
	        _webRtcManager.getMicrophoneList(function(microphoneList) {
	            _utils.callFunctionIfExist(params.onSuccess, microphoneList);
	        });
	    };

	    self.getSpeakerList = function(params) {
	        _webRtcManager.getSpeakerList(function(speakerList) {
	            _utils.callFunctionIfExist(params.onSuccess, speakerList);
	        });
	    };

	    self.changeDevices = function(data, onSuccess, onFailure) {

	        function reInviteFailureCallback() {
	            logger.info("reInviteFailureCallback.");
	            self.end({
	                callid: internalCall.id
	            }, function() {
	                logger.info("end success.");

	            });
	        }

	        function reInviteSuccessCallback() {
	            logger.info("reInviteSuccessCallback.");
	            self.delegateToCallFSM(internalCall, fsmNotificationEvent.deviceChange_GUI);
	            setNotificationStateOfCallToIdle(internalCall);
	            _webRtcManager.addLocalStream(internalCall);
	        }

	        function createReOfferSuccessCallback(sdp) {
	            internalCall.sdp = sdp;
	            logger.info("createReOfferSuccessCallback: sdp " + sdp);
	            _callControlService.reinvite(internalCall.id, sdp,
	                reInviteSuccessCallback, reInviteFailureCallback
	            );

	        }

	        function createReOfferFailureCallback(e) {
	            logger.error("[callManager.offer] Error : " + e);

	        }

	        function getUserMediaFailureCallback(e) {
	            logger.error("[getUserMedia] Error : " + e);
	            _utils.callFunctionIfExist(onFailure, e);
	        }

	        function getUserMediaSuccessCallback(mediaInfo) {
	            internalCall.isVideoSourceAllowed = mediaInfo.video;
	            _webRtcManager.storeLocalStreamToCall(internalCall, mediaInfo.id);

	            _webRtcManager.createReOffer(internalCall, createReOfferSuccessCallback, createReOfferFailureCallback, data.isVideoEnabled, getIceServerUsageStatus());
	        }

	        var internalCall;
	        var internalCallId;

	        for (internalCallId in calls) {

	            if (internalCallId) {
	                internalCall = calls[internalCallId];
	                var getUserMediaConstraints = {
	                    options: {
	                        audio: prepareAudioConstraints(),
	                        video: prepareVideoConstraints({
	                            isVideoEnabled: internalCall.isVideoSourceAllowed
	                        })
	                    }
	                };
	                self.getUserMedia(getUserMediaConstraints, getUserMediaSuccessCallback, getUserMediaFailureCallback);
	            }
	        }

	    };


	    NotificationCallBacks.call = function handleIncomingCall(data) {
	        // disabling the notifications for verizon demo
	        if (!_fcs.notification.isAnonymous()) {
	            var sdp, actions, params, calls,
	                call = null,
	                callid = null,
	                options = {},
	                callParams = data.callNotificationParams,
	                dispositionParams = data.callDispositionParams,
	                sessionParams = data.sessionParams;

	            //Since session also include disposition use it as default
	            params = sessionParams ? sessionParams : (dispositionParams ? dispositionParams : null);
	            logger.info("params: " + params);

	            if (params) {
	                actions = params.actions;
	                logger.info("actions: " + actions);
	                if (params.sessionData) {
	                    callid = params.sessionData;
	                    calls = self.getCalls();
	                    if (calls[callid] !== undefined) {
	                        logger.info("call already exists: " + callid);
	                        return;
	                    }
	                    logger.info("sessionData: " + callid);
	                }
	                if (actions) {
	                    options.reject = (actions.indexOf("reject", 0) > -1);
	                    options.forward = (actions.indexOf("forward", 0) > -1);
	                    options.answer = (actions.indexOf("answer", 0) > -1);
	                }
	                if (params.sdp) {
	                    sdp = params.sdp;
	                }
	            }

	            call = new self.IncomingCall(callid, options);
	            call.callerNumber = _utils.getProperty(callParams, 'callerDisplayNumber');
	            call.callerName = _utils.getProperty(callParams, 'callerName');
	            call.calleeNumber = _utils.getProperty(callParams, 'calleeDisplayNumber');
	            call.primaryContact = _utils.getProperty(callParams, 'primaryContact');
	            if (call.primaryContact) {
	                call.primaryContact = call.primaryContact.split(";")[0];
	            }

	            self.cerateIncomingCallInFSM(call, sdp);

	            //notify the callback
	            _utils.callFunctionIfExist(_fcs.call.onReceived, call);
	        }
	    };

	    function handleCallControlNotification(type, data) {
	        var sessionParams = data.sessionParams;
	        logger.info("CallControl notification received " + type + " sessionData:" + sessionParams.sessionData);
	        if (sessionParams.referTo) {
	            logger.info("CallControl notification received: " + "referTo:" + sessionParams.referTo + " referredBy: " + sessionParams.referredBy);
	        }
	        if (sessionParams) {
	            self.onNotificationEvent(type, sessionParams);
	        }
	    }

	    NotificationCallBacks.ringing = function(data) {
	        handleCallControlNotification(fsmNotificationEvent.ringing_Notify, data);
	    };

	    NotificationCallBacks.sessionProgress = function(data) {
	        //We are discarding the sessionProgress if the SDP is empty
	        if (data.sessionParams.sdp !== "") {
	            handleCallControlNotification(fsmNotificationEvent.sessionProgress, data);
	        } else {
	            logger.info("Warning: SDP of sessionProgress is empty.");
	        }
	    };

	    NotificationCallBacks.startCallUpdate = function handleStartCallUpdateNotification(data) {
	        var sdp = data.sessionParams.sdp,
	            notificationEvent = fsmNotificationEvent.startCallUpdate_slowStart_Notify,

	            callid = data.sessionParams.sessionData,
	            callParams = data.callNotificationParams,
	            internalCall = calls[callid],
	            remoteCallParams = {
	                RemoteDisplayName: "",
	                RemoteDisplayNumber: ""
	            };

	        if (sdp) {
	            _sdpParser.init(sdp);
	            if (_sdpParser.isRemoteHold()) {
	                notificationEvent = fsmNotificationEvent.startCallUpdate_remoteHold_Notify;
	            } else {
	                notificationEvent = fsmNotificationEvent.startCallUpdate_remoteOffer_Notify;
	            }
	        }

	        if (internalCall) {
	            if (!internalCall.remoteDisplayNumber) {
	                internalCall.remoteDisplayNumber = utils.getProperty(callParams, 'callerDisplayNumber');
	            }

	            if (internalCall.remoteDisplayNumber !== utils.getProperty(callParams, 'callerDisplayNumber')) {
	                internalCall.remoteDisplayNumber = utils.getProperty(callParams, 'callerDisplayNumber');

	                remoteCallParams.RemoteDisplayName = utils.getProperty(callParams, 'callerName');
	                remoteCallParams.RemoteDisplayNumber = utils.getProperty(callParams, 'callerDisplayNumber');

	                utils.callFunctionIfExist(fcs.call.onRemoteEndPointChange, remoteCallParams);
	            }
	        }

	        handleCallControlNotification(notificationEvent, data);
	    };

	    NotificationCallBacks.respondCallUpdate = function handleRespondCallUpdateNotification(data) {
	        if (data.sessionParams && data.sessionParams.retryAfter) {
	            handleCallControlNotification(fsmNotificationEvent.respondCallUpdate_glareCondition_Notify, data);
	        } else {
	            handleCallControlNotification(fsmNotificationEvent.respondCallUpdate_Notify, data);
	        }
	    };

	    NotificationCallBacks.sessionComplete = function handleSssionCompleteNotification(data) {
	        handleCallControlNotification(fsmNotificationEvent.sessionComplete_Notify, data);
	    };

	    NotificationCallBacks.sessionFail = function handleSessionFailNotification(data) {
	        handleCallControlNotification(fsmNotificationEvent.sessionFail_Notify, data);
	    };

	    NotificationCallBacks.callEnd = function handleCallEndNotification(data) {
	        handleCallControlNotification(fsmNotificationEvent.callEnd_Notify, data);
	    };

	    NotificationCallBacks.trying = function handleTryingNotification(data) {
	        handleCallControlNotification(fsmNotificationEvent.trying_Notify, data);
	    };

	    NotificationCallBacks.callCancel = function handleCallCancelNotification(data) {
	        handleCallControlNotification(fsmNotificationEvent.callCancel_Notify, data);
	    };

	    NotificationCallBacks.accepted = function handleAcceptedNotification(data) {
	        handleCallControlNotification(fsmNotificationEvent.accepted_Notify, data);
	    };

	    // here make parsing operations and then send sessionParams to the callManeger
	    NotificationCallBacks.startCallReplace = function(data) {
	        self.handleStartCallReplaceNotification(data);
	    };

	    _globalBroadcaster.subscribe(CONSTANTS.EVENT.DEVICE_SUBSCRIPTION_STARTED, onSubscriptionReEstablished);
	    _globalBroadcaster.subscribe(CONSTANTS.EVENT.CONNECTION_REESTABLISHED, onConnectionLost);
	    _globalBroadcaster.subscribe(CONSTANTS.EVENT.NOTIFICATION_CHANNEL_LOST, onConnectionLost);

	    self.handleStartCallReplaceNotification = function(data) {
	        var newlyCreatedSessionParams = data.sessionParams, // newly created session params
	            transferredCallId = data.replaces, // old session params that is being replaced by sessionParams
	            newlyCreatedCall = {},
	            remoteParty = data.remoteParty,
	            newlyCreatedCallId = newlyCreatedSessionParams.sessionData; // getting transfer target address

	        newlyCreatedCall.call = new self.OutgoingCall(newlyCreatedCallId);
	        if (newlyCreatedSessionParams !== null && transferredCallId !== null && remoteParty !== null) {
	            logger.info("[NotificationCallBacks.handleStartCallReplaceNotification] notification received sessionData:" + newlyCreatedSessionParams.sessionData);
	            var calls = self.getCalls(); // getting callid that is newly created
	            if (calls[newlyCreatedCallId] === undefined && calls[transferredCallId] !== undefined) {
	                // can be getting call object that is about to transferring
	                var transferredCall = calls[transferredCallId],
	                    transferredCallState = _callFSM.getCurrentState(transferredCall),
	                    isSendInitialVideo = self.isSendInitialVideoEnabled({
	                        "callid": transferredCallId
	                    });
	                newlyCreatedCall.id = newlyCreatedCallId;
	                newlyCreatedCall.currentState = fsmState.REPLACING;
	                _utils.callFunctionIfExist(_fcs.call.onCallReplaceReceived, newlyCreatedCall, transferredCall);
	                self.delegateToCallFSM(newlyCreatedCall, fsmNotificationEvent.startCallReplace_Notify);

	                if ((transferredCallState === fsmState.COMPLETED || transferredCallState === fsmState.REMOTE_HOLD)) {
	                    var getUserMediaConstraints = {
	                        options: {
	                            audio: prepareAudioConstraints(),
	                            video: prepareVideoConstraints({
	                                isVideoEnabled: isSendInitialVideo
	                            })
	                        }
	                    };
	                    self.getUserMedia(getUserMediaConstraints, function getUserMediaSuccessCallback(mediaInfo) {
	                        newlyCreatedCall.isVideoSourceAllowed = mediaInfo.video;
	                        _webRtcManager.storeLocalStreamToCall(newlyCreatedCall, mediaInfo.id);
	                        _webRtcManager.createOffer(newlyCreatedCall, function createOfferSuccessCallback(sdp) {
	                            newlyCreatedCall.sdp = sdp;
	                            // if previous call is an active call, mute it
	                            if (transferredCallState === fsmState.COMPLETED) {
	                                transferredCall.call.mute();
	                            }
	                            _callControlService.acceptCallReplace(newlyCreatedCall, function() {
	                                logger.info("[NotificationCallBacks.startCallReplace] onSuccess");
	                                newlyCreatedCall.callerNumber = remoteParty;
	                                newlyCreatedCall.replacingCallId = transferredCallId; // this will be used for unmuting previous call, when there occurs error while replacing call
	                                calls[newlyCreatedCallId] = newlyCreatedCall;
	                                setTimeout(function() {
	                                    _webRtcManager.addLocalStream(newlyCreatedCall);
	                                }, 10);
	                            }, function() {
	                                logger.info("[NotificationCallBacks.startCallReplace] onFailure");
	                                self.delegateToCallFSM(newlyCreatedCall, fsmNotificationEvent.callEnd_Notify);
	                                // unmute previousCall if previous call is active call, unmute it
	                                if (transferredCallState === fsmState.COMPLETED) {
	                                    transferredCall.call.unmute();
	                                }
	                                _callControlService.rejectCallReplace(newlyCreatedCall, function() {
	                                    logger.info("[NotificationCallBacks.startCallReplace] rejectCallReplace has sent");
	                                }, function() {
	                                    logger.info("[NotificationCallBacks.startCallReplace] rejectCallReplace could not sent");
	                                });
	                            });
	                        }, function createOfferFailureCallback(e) {
	                            logger.error("[NotificationCallBacks.handleStartCallReplaceNotification] createOfferFailureCallback Error: " + e);
	                            handleWebrtcFailure(newlyCreatedCall);
	                            _callControlService.rejectCallReplace(newlyCreatedCall, function() {
	                                logger.info("[NotificationCallBacks.handleStartCallReplaceNotification] rejectCallReplace has sent");
	                            }, function() {
	                                logger.info("[NotificationCallBacks.handleStartCallReplaceNotification] rejectCallReplace could not sent");
	                            });
	                        }, isSendInitialVideo, getIceServerUsageStatus());
	                    }, function getUserMediaFailureCallback() {
	                        logger.error("[NotificationCallBacks.handleStartCallReplaceNotification] getUserMediaFailureCallback Error");
	                        self.delegateToCallFSM(newlyCreatedCall, fsmNotificationEvent.callEnd_Notify);
	                        _callControlService.rejectCallReplace(newlyCreatedCall, function() {
	                            logger.info("[NotificationCallBacks.handleStartCallReplaceNotification] rejectCallReplace has sent");
	                        }, function() {
	                            logger.info("[NotificationCallBacks.handleStartCallReplaceNotification] rejectCallReplace could not sent");
	                        });
	                    });
	                } else {
	                    logger.info("[NotificationCallBacks.handleStartCallReplaceNotification] transferredCall is not in appropriate state: " + transferredCallState);
	                    self.delegateToCallFSM(newlyCreatedCall, fsmNotificationEvent.callEnd_Notify);
	                    _callControlService.rejectCallReplace(newlyCreatedCall, function() {
	                        logger.info("[NotificationCallBacks.handleStartCallReplaceNotification] rejectCallReplace has sent");
	                    }, function() {
	                        logger.info("[NotificationCallBacks.handleStartCallReplaceNotification] rejectCallReplace could not sent");
	                    });
	                }
	            } else {
	                logger.info("[NotificationCallBacks.handleStartCallReplaceNotification] newlyCreatedCallId already exists: " + newlyCreatedCallId + " or transferredCallId does not exists: " + transferredCallId);
	                self.delegateToCallFSM(newlyCreatedCall, fsmNotificationEvent.callEnd_Notify);
	                _callControlService.rejectCallReplace(newlyCreatedCall, function() {
	                    logger.info("[NotificationCallBacks.handleStartCallReplaceNotification] rejectCallReplace has sent");
	                }, function() {
	                    logger.info("[NotificationCallBacks.handleStartCallReplaceNotification] rejectCallReplace could not sent");
	                });
	            }
	        } else {
	            logger.info("[NotificationCallBacks.handleStartCallReplaceNotification} one of sessionParams, replaces or remoteParty values is null");
	            self.delegateToCallFSM(newlyCreatedCall, fsmNotificationEvent.callEnd_Notify);
	            _callControlService.rejectCallReplace(newlyCreatedCall, function() {
	                logger.info("[NotificationCallBacks.handleStartCallReplaceNotification] rejectCallReplace has sent");
	            }, function() {
	                logger.info("[NotificationCallBacks.handleStartCallReplaceNotification] rejectCallReplace could not sent");
	            });
	        }
	    };

	    
	};

	//@{fcs-jsl-prod}
	var CallManager = function(_webRtcManager, _callFSM, _callControlService, _sdpParser, _logManager, _globalBroadcaster, _utils, _fcs) {
	    return new CallManagerImpl(_webRtcManager || webRtcManager,
	        _callFSM || callFSM,
	        _callControlService || callControlService,
	        _sdpParser || sdpParser,
	        _logManager || logManager,
	        _globalBroadcaster || globalBroadcaster,
	        _utils || utils,
	        _fcs || fcs);
	};

	var callManager = new CallManager();

	addToServiceList("call", "spidr", callManager);
	//@{fcs-jsl-prod}



	var CollaborationServiceImpl = function(_server, _getWAMUrl) {

	    var urlStr = "/collaboration/";

	    this.retrieve = function(query, parseData, onSuccess, onFailure) {
	        _server.sendGetRequest({
	                url: _getWAMUrl(1, urlStr + query)
	            },
	            onSuccess,
	            onFailure,
	            parseData,
	            undefined,
	            "collaborationResponse");
	    };

	};

	//@{fcs-jsl-prod}
	var CollaborationService = function(_server, _getWAMUrl) {
	    return new CollaborationServiceImpl(_server || server,
	        _getWAMUrl || getWAMUrl);
	};

	var collaborationService = new CollaborationService();
	//@{fcs-jsl-prod}


	var CollaborationManagerImpl = function(_service, _utils) {

	    this.retrieveWebCollaborationHostUrl = function(onSuccess, onFailure) {
	        _service.retrieve("webcollaborationhosturl", function(result) {
	            return _utils.getProperty(result.collaborationResponse, 'webCollaborationHostURL');
	        }, onSuccess, onFailure);
	    };

	    this.retrieveVideoCollaborationHostUrl = function(onSuccess, onFailure) {
	        _service.retrieve("videocollaborationhosturl", function(result) {
	            return _utils.getProperty(result.collaborationResponse, 'videoCollaborationHostURL');
	        }, onSuccess, onFailure);
	    };

	};

	//@{fcs-jsl-prod}
	var CollaborationManager = function(service, _utils) {
	    return new CollaborationManagerImpl(service || collaborationService, _utils || utils);
	};
	var collaborationManager = new CollaborationManager();
	//@{fcs-jsl-prod}



	/**
	 * Collaboration
	 *
	 * @name collaboration
	 * @namespace
	 * @memberOf fcs
	 * @version 4.2.0
	 * @since 3.1.0
	 */
	var CollaborationImpl = function(_manager) {

	    /**
	     * Success callback for collaboration retrieveWebCollaborationHostUrl and retrieveVideoCollaborationHostUrl request.
	     *
	     * @callback collaborationRequestSuccess
	     * @param {String} url
	     */

	    /**
	     * Failure callback for collaboration retrieveWebCollaborationHostUrl and retrieveVideoCollaborationHostUrl request.
	     *
	     * @callback collaborationRequestFailure
	     * @param {fcs#Errors} responseCode
	     */

	    /**
	     * Retrieves the webCollaborationHostUrl, which is included by collaboration response, from the server
	     * and executes the success callback on completion or failure
	     * callback on error.
	     *
	     * @name fcs.collaboration#retrieveWebCollaborationHostUrl
	     * @function
	     * @since 3.1.0
	     *
	     * @param {collaborationRequestSuccess} success callback function
	     * @param {collaborationRequestFailure} failure callback function
	     *
	     * @example
	     * var onSuccess = function(webcollaborationhosturl){
	     *    console.log(webcollaborationhosturl);
	     * };
	     *
	     * var onError = function (err) {
	     *   console.log(err);
	     * };
	     *
	     * fcs.collaboration.retrieveWebCollaborationHostUrl(onSuccess, onError);
	     *
	     */
	    this.retrieveWebCollaborationHostUrl = _manager.retrieveWebCollaborationHostUrl;

	    /**
	     * Retrieves the videoCollaborationHostUrl, which is included by collaboration response, from the server
	     * and executes the success callback on completion or failure
	     * callback on error.
	     *
	     * @name fcs.collaboration#retrieveVideoCollaborationHostUrl
	     * @function
	     * @since 3.1.0
	     *
	     * @param {collaborationRequestSuccess} success callback function
	     * @param {collaborationRequestFailure} failure callback function
	     *
	     * @example
	     * var onSuccess = function(videoCollaborationHostUrl){
	     *    console.log(videoCollaborationHostUrl);
	     * };
	     *
	     * var onError = function (err) {
	     *   console.log(err);
	     * };
	     *
	     * fcs.collaboration.retrieveVideoCollaborationHostUrl(onSuccess, onError);
	     *
	     */
	    this.retrieveVideoCollaborationHostUrl = _manager.retrieveVideoCollaborationHostUrl;
	};

	//@{fcs-jsl-prod}
	var Collaboration = function(manager) {
	    return new CollaborationImpl(manager || collaborationManager);
	};

	fcs.collaboration = new Collaboration();
	//@{fcs-jsl-prod}



	/**
	 * Call and Remote Call Control (RCC) related resources (IMRN, Click To Call, Call Disposition).
	 *
	 * Available for SPiDR since 3.0.0, and for RCC since 3.1.1.
	 *
	 * @name call
	 * @namespace
	 *
	 * @memberOf fcs
	 *
	 * @version 4.2.0
	 */

	var CallImpl = function(_manager) {

	    /**
	     * This field provides the state of local video status like "recvonly", "sendrecv", "sendrecv" etc.
	     *
	     * This is a SPiDR service only member.
	     *
	     * @name fcs.call#localVideoState
	     * @field
	     * @type {number}
	     * @since 3.0.0
	     */
	    this.localVideoState = 0;

	    /**
	     * This field provides the state of remote video status like "recvonly", "sendrecv", "sendrecv" etc.
	     *
	     * This is a SPiDR service only member.
	     *
	     * @name fcs.call#remoteVideoState
	     * @field
	     * @since 3.0.0
	     * @type {number}
	     */
	    this.remoteVideoState = 0;

	    /**
	     * Sets the handler for received call notifications.
	     *
	     * This is a SPiDR and RCC service event.
	     *
	     * @name fcs.call#onReceived
	     * @event
	     * @param {fcs.call#Call} call The call object
	     * @example
	     * // SPiDR service example is as follows:
	     * // @since 3.0.0
	     * // This function listens received calls
	     * function callReceived(call) {
	     *    console.log("There is an incomming call...");
	     *
	     *    //This function listens call state changes in JSL API level
	     *    call.onStateChange = function(state) {
	     *        onStateChange(call, state);
	     *    };
	     *
	     *    //This function listens media streams in JSL API level
	     *    call.onStreamAdded = function(streamURL) {
	     *        // Remote Video is turned on by the other end of the call
	     *        // Stream URL of Remote Video stream is passed into this function
	     *        onStreamAdded(streamURL);
	     *    };
	     *
	     *    // Answering the incomming call
	     *    call.answer(onAnswer, onFailure, isVideoAnswer);
	     * }
	     *
	     * fcs.call.onReceived = callReceived;
	     *
	     * // RCC service example is as follows:
	     * // @since 3.1.1
	     * function onCallReceived(call) {
	     *   console.log('There is an incomming call...');
	     *
	     *   call.onStateChange = function (state, statusCode, reasonText, data) {
	     *       onStateChange(call, state, data);
	     *   };
	     * }
	     *
	     * fcs.call.onReceived = onCallReceived;
	     *
	     */
	    this.onReceived = null;

	    /**
	     * Sets the handler for received CallReplace nofitication
	     *
	     * This is a SPIDR service event
	     *
	     * @name fcs.call#onCallReplaceReceived
	     * @event
	     * @param {fcs.call#Call} call the new call object
	     * @param {fcs.call#Call} call the call object to transferred
	     * @since 4.0.0
	     * @example
	     *
	     *
	     *  function onCallReplaceReceived(newlyCreatedCall, transferredCall) {
	     *       showInfoMessage("A Replacing call has received with id: " + newlyCreatedCall.id);
	     *
	     *       // Assigning call object to currentCall variable to use in the application
	     *       currentCall = newlyCreatedCall;
	     *
	     *       //This function listens call state changes in JSL API level
	     *       newlyCreatedCall.call.onStateChange = function(state) {
	     *          onStateChange(newlyCreatedCall, state);
	     *       };
	     *
	     *       //This function listens call state changes in JSL API level
	     *       transferredCall.onMute = function(status) {
	     *           showInfoMessage("Call mute status: " + status);
	     *       };
	     * }
	     *
	     * fcs.call.onCallReplaceReceived = onCallReplaceReceived;
	     */
	    this.onCallReplaceReceived = null;

	    /**
	     * Sets the handler for monitored device initiated outgoing call notifications.
	     *
	     * This is an RCC service only event.
	     *
	     * @name fcs.call#onOutgoingCall
	     * @event
	     * @since 3.1.1
	     * @param {fcs.call#Call} Call The call object
	     *
	     * @example
	     * //This function listens monitored device initiated outgoing calls
	     * function outgoingCall(call) {
	     *    console.log("A new call is successful!");
	     *
	     *    //This function listens call state changes in JSL API level
	     *    outgoingCall.onStateChange = function(state, statusCode, reasonText, data) {
	     *      onStateChange(call, state, data);
	     *    };
	     *
	     * }
	     * fcs.call.onOutgoingCall = outgoingCall;
	     */
	    this.onOutgoingCall = null;

	    /**
	     * Monitor session is automatically and periodically extended after it is
	     * started (see {@link fcs.call#startMonitorDevice}). In case of extend
	     * monitor failure, given onMonitorSessionLost callback
	     * function is called.
	     *
	     * This is an RCC service only method.
	     *
	     * @name fcs.call#setOnMonitorSessionLost
	     * @function
	     * @since 3.1.1
	     * @param {function} callback callback function for on monitor session lost
	     *
	     * @example
	     * onSuccess = function () {
	     *   console.log('Start monitor success');
	     *
	     *   fcs.call.setOnMonitorSessionLost(
	     *       function () {
	     *           console.log('Extend monitor session lost! Please again start new monitor session.');
	     *       });
	     * }
	     *
	     * onFailure = function () {
	     *   console.log('Start monitor failure');
	     * }
	     *
	     * fcs.call.startMonitorDevice(deviceID, onSuccess, onFailure);
	     *
	     */
	    this.setOnMonitorSessionLost = function(callback) {
	        var param = {
	            callback: callback
	        };

	        param = extend(param, {
	            serviceName: 'rcc'
	        });

	        return _manager.invoke('call', 'setOnMonitorSessionLost', param);
	    };

	    /**
	     * @deprecated DO NOT USE, fcs.setup will do initMedia immediatly, please see {@link fcs#setup} for more information
	     * @name fcs.call#initMedia
	     * @function
	     */

	    this.initMedia = function(onSuccess, onFailure, options) {
	        var param = {
	            options: options
	        };
	        param = extend(param, {
	            serviceName: 'spidr'
	        });

	        return _manager.invoke('call', 'initMedia', param, onSuccess, onFailure);
	    };

	    /**
	     * Starts a call.
	     *
	     * This is a SPiDR and RCC service method.
	     *
	     * @name fcs.call#startCall
	     * @function
	     * @param {string} from The caller's address (e.g. SIP URI) used to establish the call. This is a SPiDR service only parameter.
	     * @param {object} [contact] Contains users firstName and lastName. This is a SPiDR service only parameter.
	     * @param {string} [contact.firstName="John"] First Name of the user
	     * @param {string} [contact.lastName="Doe"] Last Name of the user
	     * @param {string} to The callee's address (e.g. SIP URI) used to establish the call
	     * @param {function} onSuccess The onSuccess({@link fcs.call#OutgoingCall}) callback function to be called
	     * @param {function} onFailure The onFailure({@link fcs#Errors}) callback function to be called
	     * @param {boolean} [isVideoEnabled] This will add m=video to SDP. This is a SPiDR service only parameter.
	     * @param {boolean} [sendInitialVideo] In order to make video call set this to true. This is a SPiDR service only parameter.
	     * @param {string} [videoQuality] Sets the quality of video. This is a SPiDR service only parameter.
	     * @param {object} params Contains the service name ({serviceName:'spidr'} or ({serviceName:'rcc'}). SPiDR service parameter is default. If it is a RCC service, the service parameter should be given.
	     *
	     * @example
	     * // SPiDR service example is as follows:
	     * // @since 3.0.0
	     * // Make Voice Call
	     * // Start a voice call to the uri indicated with "to" argument
	     * // Login is a prerequisite for making calls
	     * // contact is an object with two fields contact.firstName and contact.lastName that specifies caller info
	     * fcs.call.startCall(fcs.getUser(), contact, to,
	     *      function(outgoingCall){
	     *                //get callid for your web app to be used later for handling popup windows
	     *                var callId = outgoingCall.getId();
	     *
	     *                outgoingCall.onStateChange = function(state,statusCode){
	     *                //Add statusCode that returned from the server property to the call
	     *                outgoingCall.statusCode = statusCode;
	     *                //Put your web app code to handle call state change like ringing, onCall ...etc.
	     *	    };
	     *
	     *       outgoingCall.onStreamAdded = function(streamURL){
	     *           // Setting up source (src tag) of remote video container
	     *           $("#remoteVideo").attr("src", streamURL);
	     *       };
	     *    },
	     *    function(){
	     *       //put your web app failure handling code
	     *       window.alert("CALL_FAILED");
	     *    },
	     *    false, false);
	     *
	     * // RCC service example is as follows:
	     * // @since 3.1.1
	     * // Start a call from a monitored device.
	     * fcs.call.startCall(undefined, undefined,
	     *    // destination
	     *    destination,
	     *    // onSuccess callback
	     *    function (outgoingCall)
	     *    {
	     *        outgoingCall.onStateChange = function (state, statusCode, reasonText, data) {
	     *                onStateChange(outgoingCall, state, data);
	     *        };
	     *        console.log('make call request success');
	     *    },
	     *    // onFailure callback
	     *    function (e) {
	     *        console.log('make call request failure!');
	     *    },
	     *    undefined, undefined, undefined, {serviceName: 'rcc'});
	     *
	     */

	    this.startCall = function(from, contact, to, onSuccess, onFailure, isVideoEnabled, sendInitialVideo, videoQuality, params) {
	        var param = {
	            from: from,
	            contact: contact,
	            to: to,
	            isVideoEnabled: isVideoEnabled,
	            sendInitialVideo: sendInitialVideo,
	            videoQuality: videoQuality
	        };
	        param = extend(param, params);

	        return _manager.invoke('call', 'start', param, onSuccess, onFailure);
	    };

	    /**
	     * Starts monitoring a device.
	     *
	     * This is an RCC service only method.
	     *
	     * @name fcs.call#startMonitorDevice
	     * @function
	     * @since 3.1.1
	     * @param {string} deviceID If string with length greater than 0; device monitor will be started, otherwise user monitor will be started.
	     * @param {function} onSuccess The onSuccess callback function to be called
	     * @param {function} onFailure The onFailure({@link fcs#Errors}) callback function to be called
	     *
	     * @example
	     * // User is subscribed...
	     * // If deviceID is a string with length greater than 0; device monitor will be started,
	     * // otherwise user monitor will be started.
	     * var deviceID = null;
	     * fcs.call.startMonitorDevice(
	     *     deviceID,
	     *     // onSuccess callback
	     *     function () {
	     *         console.log('Start monitor success');
	     *     },
	     *     // onFailure callback
	     *     function () {
	     *         console.log('Start monitor failure');
	     *     });
	     */

	    this.startMonitorDevice = function(deviceID, onSuccess, onFailure) {
	        var param = {
	            deviceID: deviceID
	        };
	        param = extend(param, {
	            serviceName: 'rcc'
	        });

	        return _manager.invoke('call', 'startMonitorDevice', param, onSuccess, onFailure);
	    };

	    /**
	     * Stops monitoring a device.
	     *
	     * This is an RCC service only method.
	     *
	     * @name fcs.call#stopMonitorDevice
	     * @function
	     * @since 3.1.1
	     * @param {function} onSuccess The onSuccess callback function to be called
	     * @param {function} onFailure The onFailure({@link fcs#Errors}) callback function to be called
	     *
	     * @example
	     * fcs.call.stopMonitorDevice(
	     *  // onSuccess callback
	     *  function () {
	     *      console.log('stop monitor success');
	     *  },
	     *  // onFailure callback
	     *  function () {
	     *      console.log('stop monitor failure');
	     *  });
	     *
	     */

	    this.stopMonitorDevice = function(onSuccess, onFailure) {
	        var param = {};
	        param = extend(param, {
	            serviceName: 'rcc'
	        });

	        return _manager.invoke('call', 'stopMonitorDevice', param, onSuccess, onFailure);
	    };


	    /**
	     * Lists the registered devices of the RCC subscriber.
	     *
	     * This is an RCC service only method.
	     *
	     * @name fcs.call#getRCCDeviceList
	     * @function
	     * @since 3.1.1
	     * @param {function} onSuccess The onSuccess callback function to be called with an array of device info objects. Each object contains deviceURI, deviceId and uuid fields.
	     * @param {function} onFailure The onFailure({@link fcs#Errors}) callback function to be called
	     *
	     * @example
	     * // User is subscribed...
	     * fcs.call.getRCCDeviceList(
	     *  // onsuccess callback
	     *  function(deviceList) {
	     *      console.log('get device list success');
	     *      for (i = 0; i < deviceList.length; i++) {
	     *          // use device list array elements: Sample element:
	     *          // "deviceURI":"user1@1.1.1.1:5061",
	     *          // "uuid":"00000000-0000-1000-8000-001ECAF35125",
	     *          // "deviceId":"c2lwOmVyZGVtMUA0Ny4xNjguMjQ2LjMzOjUwNjE7dHJhbnNwb3J0PXRjcCQ8dXJuOnV1aWQ6IDAw%0AMDAwMDAwLTAwMDAtMTAwMC04MDAwLTAwMUVDQUYzNTEyNT4%3D%0A"
	     *      }
	     *  },
	     *  // onFailure callback
	     *  function(e) {
	     *      console.log('get device list failure');
	     *  });
	     */
	    this.getRCCDeviceList = function(onSuccess, onFailure) {
	        var param = {};
	        param = extend(param, {
	            serviceName: 'rcc'
	        });

	        return _manager.invoke('call', 'getDeviceList', param, onSuccess, onFailure);
	    };




	    /**
	     * Sets log severity level for Webrtc Plugin (not used for native webrtc)
	     * 5 levels(sensitive:0, verbose:1, info:2, warning:3, error:4).
	     *
	     * This is a SPiDR service only method.
	     *
	     * @name fcs.call#set_logSeverityLevel
	     * @function
	     * @since 3.0.0
	     *
	     */

	    this.set_logSeverityLevel = function(level) {
	        var param = {
	            level: level
	        };
	        param = extend(param, {
	            serviceName: 'spidr'
	        });

	        return _manager.invoke('call', 'set_logSeverityLevel', param);
	    };

	    /**
	     * Enables log callback for Webrtc Plugin (not used for native webrtc).
	     *
	     * This is a SPiDR service only method.
	     *
	     * @name fcs.call#enable_logCallback
	     * @function
	     * @since 3.0.0
	     */

	    this.enable_logCallback = function() {
	        var param = {};
	        param = extend(param, {
	            serviceName: 'spidr'
	        });

	        return _manager.invoke('call', 'enable_logCallback', param);
	    };

	    /**
	     * Disables log callback for Webrtc Plugin (not used for native webrtc).
	     *
	     * This is a SPiDR service only method.
	     *
	     * @name fcs.call#disable_logCallback
	     * @function
	     * @since 3.0.0
	     */

	    this.disable_logCallback = function() {
	        var param = {};
	        param = extend(param, {
	            serviceName: 'spidr'
	        });

	        return _manager.invoke('call', 'disable_logCallback', param);
	    };

	    /**
	     * Gets audioInDeviceCount.
	     *
	     * This is a SPiDR service only method.
	     *
	     * @name fcs.call#get_audioInDeviceCount
	     * @function
	     * @since 3.0.0
	     */

	    this.get_audioInDeviceCount = function() {
	        var param = {};
	        param = extend(param, {
	            serviceName: 'spidr'
	        });

	        return _manager.invoke('call', 'get_audioInDeviceCount', param);
	    };

	    /**
	     * Gets audioOutDeviceCount.
	     *
	     * This is a SPiDR service only method.
	     *
	     * @name fcs.call#get_autioOutDeviceCount
	     * @function
	     * @since 3.0.0
	     */

	    this.get_audioOutDeviceCount = function() {
	        var param = {};
	        param = extend(param, {
	            serviceName: 'spidr'
	        });

	        return _manager.invoke('call', 'get_audioOutDeviceCount', param);
	    };

	    /**
	     * Gets videoDeviceCount.
	     *
	     * This is a SPiDR service only method.
	     *
	     * @name fcs.call#get_videoDeviceCount
	     * @function
	     * @since 3.0.0
	     */

	    this.get_videoDeviceCount = function() {
	        var param = {};
	        param = extend(param, {
	            serviceName: 'spidr'
	        });

	        return _manager.invoke('call', 'get_videoDeviceCount', param);
	    };

	    /**
	     * Returns Video Device(Camera) availability.
	     *
	     * This is a SPiDR service only method.
	     *
	     * @name fcs.call#hasVideoDevice
	     * @function
	     * @since 3.0.0
	     *
	     * @example
	     * if(fcs.call.hasVideoDevice()){
	     *     // If there is a video device available, show local video container
	     *     callView.toggleLocalVideo(true);
	     * }
	     */
	    this.hasVideoDevice = function() {
	        var param = {};
	        param = extend(param, {
	            serviceName: 'spidr'
	        });

	        return _manager.invoke('call', 'get_videoDeviceCount', param);
	    };

	    /**
	     * Returns Audio Device(Microphone) availability.
	     *
	     * This is a SPiDR service only method.
	     *
	     * @name fcs.call#hasAudioDevice
	     * @function
	     * @since 3.0.0
	     *
	     * @example
	     * if(!fcs.call.hasAudioDevice()){
	     *     window.alert("There is no available audio source!");
	     * }
	     */
	    this.hasAudioDevice = function() {
	        var param = {};
	        param = extend(param, {
	            serviceName: 'spidr'
	        });

	        return _manager.invoke('call', 'hasAudioDevice', param);
	    };


	    /**
	     *
	     * This is a SPiDR service only method.
	     *
	     * @name fcs.call#getUserMedia
	     * @function
	     * @since 3.0.0
	     * @param onSuccess success callback of getUserMedia
	     * @param onFailure failure callback of getUserMedia
	     * @param options contains audio and video constraints
	     *
	     * @example
	     * fcs.call.getUserMedia(
	     *    function(mediaInfo){
	     *        window.console.log("media initialized. mediaInfo: " + JSON.stringify(mediaInfo));
	     *    },
	     *    function(err){
	     *        window.console.log("media initialization error " + err);
	     *    },
	     *    {
	     *        "audio": true,
	     *        "video": true
	     *    }
	     * );
	     */

	    this.getUserMedia = function(onSuccess, onFailure, options) {
	        var param = {
	            options: options,
	            privateStream: true
	        };
	        param = extend(param, {
	            serviceName: 'spidr',
	            privateStream: true
	        });

	        return _manager.invoke('call', 'getUserMedia', param, onSuccess, onFailure);
	    };

	    /**
	     * Shows device settings Window
	     * Only works with PLUGIN.
	     *
	     * This is a SPiDR service only method.
	     *
	     * @name fcs.call#showSettingsWindow
	     * @function
	     * @since 3.0.0
	     *
	     * @example
	     * $("#device_settings_button").click(function() {
	     *    fcs.call.showSettingsWindow();
	     * });
	     */

	    this.showSettingsWindow = function(onSuccess, onFailure, options) {
	        var param = {
	            options: options
	        };
	        param = extend(param, {
	            serviceName: 'spidr'
	        });

	        return _manager.invoke('call', 'showSettingsWindow', param, onSuccess, onFailure);
	    };

	    /**
	     * Gets local video resolutions with the order below
	     * localVideoHeight-localVideoWidth
	     * Only works with PLUGIN.
	     * This is a SPiDR service only method.
	     *
	     * @name fcs.call#getLocalVideoResolutions
	     * @function
	     * @since 3.0.0
	     *
	     * @example
	     * var pluginLocalVideoResolution = fcs.call.getLocalVideoResolutions();
	     * var localVideoHeight = pluginLocalVideoResolution[0];
	     * var localVideoWidth = pluginLocalVideoResolution[1];
	     * console.log("Local Video Dimensions: " + localVideoWidth + "," + localVideoHeight);
	     */

	    this.getLocalVideoResolutions = function() {
	        var param = {};
	        param = extend(param, {
	            serviceName: 'spidr'
	        });

	        return _manager.invoke('call', 'getLocalVideoResolutions', param);
	    };

	    /**
	     * Gets remote video resolutions with the order below
	     * remoteVideoHeight-remoteVideoWidth
	     * Only works with PLUGIN.
	     * This is a SPiDR service only method.
	     *
	     * @name fcs.call#getRemoteVideoResolutions
	     * @function
	     * @since 3.0.0
	     *
	     * @example
	     * var pluginRemoteVideoResolution = fcs.call.getRemoteVideoResolutions();
	     * var remoteVideoHeight = pluginRemoteVideoResolution[0];
	     * var remoteVideoWidth = pluginRemoteVideoResolution[1];
	     * console.log("Remote Video Dimensions: " + remoteVideoWidth + "," + remoteVideoHeight);
	     */

	    this.getRemoteVideoResolutions = function() {
	        var param = {};
	        param = extend(param, {
	            serviceName: 'spidr'
	        });

	        return _manager.invoke('call', 'getRemoteVideoResolutions', param);
	    };

	    /**
	     * Shows if plugin is enabled.
	     * Only works with PLUGIN.
	     * This is a SPiDR service only method.
	     *
	     * @name fcs.call#isPluginEnabled
	     * @function
	     * @since 3.0.0
	     *
	     * @example
	     * if(fcs.call.isPluginEnabled()) {
	     *     $("#device_settings_details").show();
	     * }
	     */

	    this.isPluginEnabled = function() {
	        var param = {};
	        param = extend(param, {
	            serviceName: 'spidr'
	        });

	        return _manager.invoke('call', 'isPluginEnabled', param);
	    };

	    /**
	     * Checks if any call exists.
	     *
	     * This is a SPiDR and RCC service method.
	     *
	     * @name fcs.call#hasGotCalls
	     * @function
	     * @param {object} params Contains the service name ({serviceName:'spidr'} or ({serviceName:'rcc'}). SPiDR service parameter is default. If it is a RCC service, the service parameter should be given.
	     * @returns {Boolean} true if any call exists, false otherwise.
	     *
	     * @example
	     * // SPiDR service example is as follows:
	     * // @since 3.0.0
	     * if(fcs.call.hasGotCalls()) {
	     *  console.log('At least one call is available.');
	     * }
	     *
	     * // RCC service example is as follows:
	     * // @since 3.1.1
	     * if(fcs.call.hasGotCalls({serviceName:'rcc'})) {
	     *  console.log('At least one call is available.');
	     * }
	     */
	    this.hasGotCalls = function(params) {
	        var param = {};
	        param = extend(param, params);

	        return _manager.invoke('call', 'hasGotCalls', param);
	    };

	    /**
	     * Retrived a call by Id.
	     *
	     * This function allow to retrive a call which was cached by the call continuation feature.
	     * This is a SPiDR service only method.
	     *
	     * @name fcs.call#getIncomingCallById
	     * @function
	     * @since 3.0.0
	     * @param {string} id from The id of the incoming call
	     * @returns {fcs.call.IncomingCall}
	     *
	     */
	    this.getIncomingCallById = function(id) {
	        var param = {
	            callid: id
	        };
	        param = extend(param, {
	            serviceName: 'spidr'
	        });

	        return _manager.invoke('call', 'getIncomingCallById', param);
	    };

	    /**
	     * Create a renderer for an audio/video stream.
	     * This is a SPiDR service only method.
	     *
	     * @name fcs.call#createStreamRenderer
	     * @function
	     * @since 3.0.0
	     * @param {string} streamUrl The url of the stream
	     * @param {object} container The DOM node into which to create the renderer (the content of the node will be cleared)
	     * @param {object} options The options to be used for the renderer
	     * @returns {Object} renderer Renderer object
	     *
	     */
	    this.createStreamRenderer = function(streamId, container, options) {
	        var param = {
	            streamId: streamId,
	            container: container,
	            options: options
	        };
	        param = extend(param, {
	            serviceName: 'spidr'
	        });

	        return _manager.invoke('call', 'createStreamRenderer', param);
	    };

	    /**
	     * Discpose of a previously created renderer.
	     * This is a SPiDR service only method.
	     *
	     * @name fcs.call#disposeStreamRenderer
	     * @function
	     * @since 3.0.0
	     * @param {object} container The DOM node into which the renderer was previously created
	     */
	    this.disposeStreamRenderer = function(container) {
	        var param = {
	            container: container
	        };
	        param = extend(param, {
	            serviceName: 'spidr'
	        });

	        return _manager.invoke('call', 'disposeStreamRenderer', param);
	    };

	    /**
	     * States of the Call.
	     *
	     * This is a SPiDR and RCC service member.
	     * Available for SPiDR since 3.0.0, and for RCC since 3.1.1.
	     *
	     * @name fcs.call#States
	     * @enum {number}
	     * @readonly
	     * @property {number} [IN_CALL=0] The call has been established. In rcc mode, called and calling party information is also passed to the client in on state change callback.
	     * @property {number} [ON_HOLD=1] The call has been put on hold.
	     * @property {number} [RINGING=2] The outgoing call is ringing. In rcc mode, called and calling party information is also passed to the client in on state change callback.
	     * @property {number} [ENDED=3] The call has been terminated.
	     * @property {number} [REJECTED=4] The outgoing call request has been rejected by the other party.
	     * @property {number} [OUTGOING=5] The outgoing call request has been sent but no response have been received yet.
	     * @property {number} [INCOMING=6] The incoming call has been received but has not been answered yet. In rcc mode, called and calling party information is also passed to the client in on state change callback.
	     * @property {number} [ANSWERING=7] The incoming call has been answered but the call as not been establish yet.
	     * @property {number} [JOINED=8] The call is joined.
	     * @property {number} [RENEGOTIATION=9] The call is re-established.
	     * @property {number} [TRANSFERRED=10] The call is transferred to a third party.
	     * @property {number} [ON_REMOTE_HOLD=11] The call has been put on hold remotely.
	     * @property {number} [CALL_IN_PROGRESS=12] The call is in progress. In rcc mode, called and calling party information is also passed to the client in on state change callback.
	     * @property {number} [EARLY_MEDIA=13] Early media process successful.
	     * EARLY_MEDIA and RINGING states can be triggered multiple times in different orders.
	     * In each of these states, if the respondCallUpdate notification comes
	     * and processed successfully, the state is IN_CALL.
	     * @property {number} [TRANSFER_FAILURE=14] The call couldn't be transferred to a third party.
	     * @property {number} [REPLACING=15] Blind Transfer is in progress for transferee. Call replacing notification has come.
	     */

	    this.States = {
	        IN_CALL: 0,
	        ON_HOLD: 1,
	        RINGING: 2,
	        ENDED: 3,
	        REJECTED: 4,
	        OUTGOING: 5,
	        INCOMING: 6,
	        ANSWERING: 7,
	        JOINED: 8,
	        RENEGOTIATION: 9,
	        TRANSFERRED: 10,
	        ON_REMOTE_HOLD: 11,
	        CALL_IN_PROGRESS: 12,
	        EARLY_MEDIA: 13,
	        TRANSFER_FAILURE: 14,
	        REPLACING: 15
	    };

	    /**
	     * Hold states of the Call.
	     *
	     * This is a SPiDR and RCC service member.
	     * Available for SPiDR since 3.0.0, and for RCC since 3.1.1.
	     *
	     * @name fcs.call#HoldStates
	     * @enum {number}
	     * @readonly
	     * @property {number} [LOCAL_HOLD=0] The call has been put on hold locally.
	     * @property {number} [REMOTE_HOLD=1] The call has been put on hold remotely.
	     * @property {number} [BOTH_HOLD=2] he call has been put on both locally and remotely.
	     */

	    this.HoldStates = {
	        LOCAL_HOLD: 0,
	        REMOTE_HOLD: 1,
	        BOTH_HOLD: 2
	    };

	    /**
	     * Local status codes of the Call.
	     *
	     * This is a SPiDR service only member.
	     * Available for SPiDR since 4.0.0
	     *
	     * @name fcs.call#LocalStatusCodes
	     * @enum {string}
	     * @readonly
	     * @property {string} [STATUS_CODE_NOT_PROVIDED="9900"] The call's status code hasn't been provided.
	     * @property {string} [ENDED_BY_LOCAL="9901"] The call has been ended locally.
	     * @property {string} [REJECTED_BY_LOCAL="9902"] The call has been rejected by remote end.
	     * @property {string} [IGNORED_BY_LOCAL="9903"] The call has been ignored by remote end.
	     * @property {string} [RESPONDED_FROM_ANOTHER_DEVICE="9904"] The call has been responded from another device.
	     * @property {string} [SESSION_COMPLETED="9905"] The call session has been completed.
	     */
	    this.LOCAL_STATUS_CODES = {
	        STATUS_CODE_NOT_PROVIDED: "9900",
	        ENDED_BY_LOCAL: "9901",
	        REJECTED_BY_LOCAL: "9902",
	        IGNORED_BY_LOCAL: "9903",
	        RESPONDED_FROM_ANOTHER_DEVICE: "9904",
	        SESSION_COMPLETED: "9905"
	    };

	    /**
	     * Local reason texts of the Call.
	     *
	     * This is a SPiDR service only member.
	     * Available for SPiDR since 4.0.0
	     *
	     * @name fcs.call#LocalReasonTexts
	     * @enum {string}
	     * @readonly
	     * @property {string} [STATUS_CODE_NOT_PROVIDED="Reason not provided"] The call's reason text has not been provided.
	     * @property {string} [ENDED_BY_LOCAL="Ended by local user"] The call has been ended locally.
	     * @property {string} [REJECTED_BY_LOCAL="Rejected by local user"] The call has been rejected by local user.
	     * @property {string} [IGNORED_BY_LOCAL="Ignored by local user"] The call has been ignored by local user.
	     * @property {string} [RESPONDED_FROM_ANOTHER_DEVICE="Responded from another device"] The call has been answered on another device.
	     * @property {string} [SESSION_COMPLETED="Session completed"] The call session is complete.
	     */
	    this.LOCAL_REASON_TEXTS = {
	        STATUS_CODE_NOT_PROVIDED: "Reason not provided",
	        ENDED_BY_LOCAL: "Ended by local user",
	        REJECTED_BY_LOCAL: "Rejected by local user",
	        IGNORED_BY_LOCAL: "Ignored by local user",
	        RESPONDED_FROM_ANOTHER_DEVICE: "Responded from another device",
	        SESSION_COMPLETED: "Session completed"
	    };

	    /**
	     * Type of media initialization errors.
	     *
	     * This is a SPiDR service only member.
	     *
	     * @name fcs.call#MediaErrors
	     * @enum {number}
	     * @since 3.0.0
	     * @readonly
	     * @property {number} [NOT_FOUND=1] No media source available.
	     * @property {number} [NOT_ALLOWED=2] User did not allow media use.
	     * @property {number} [OPTIONS=3] Missing or wrong use of options.
	     * @property {number} [WRONG_VERSION=4] The version of the plugin is not supported.
	     * @property {number} [NOT_INITIALIZED=5] The media is not initialized.
	     * @property {number} [NEW_VERSION_WARNING=6] New plugin version is available.
	     * @property {number} [INVALID_PARAMETER=7] Invalid parameter.
	     * @property {number} [NO_SCREENSHARING_WARNING=8] Screen sharing is not possible with this browser or the screensharing extension could not be found.
	     */
	    this.MediaErrors = {
	        NOT_FOUND: 1,
	        NOT_ALLOWED: 2,
	        OPTIONS: 3,
	        WRONG_VERSION: 4,
	        NOT_INITIALIZED: 5,
	        NEW_VERSION_WARNING: 6,
	        INVALID_PARAMETER: 7,
	        NO_SCREENSHARING_WARNING: 8
	    };

	    /**
	     * Call a party through a client device using the Click To Call service.
	     * This is a SPiDR service only method.
	     *
	     * @name fcs.call#clickToCall
	     * @function
	     * @since 3.0.0
	     * @param {string} callingParty The caller's address (e.g. SIP) used to establish the call
	     * @param {string} calledParty The callee's address (e.g. SIP) used to establish the call
	     * @param {function} onSuccess The onSuccess() callback to be called
	     * @param {function} onFailure The onFailure({@link fcs#Errors}) callback to be called
	     *
	     * @example
	     * var onSuccess = function(){
	     *    //do something here
	     * };
	     * var onError = function (err) {
	     *   //do something here
	     * };
	     *
	     * fcs.call.clickToCall("user1@test.com", "user2@test.com", onSuccess, onError);
	     */

	    this.clickToCall = function(callingParty, calledParty, onSuccess, onFailure) {
	        var param = {
	            callingParty: callingParty,
	            calledParty: calledParty
	        };
	        param = extend(param, {
	            serviceName: 'spidr'
	        });

	        return _manager.invoke('call', 'clickToCall', param, onSuccess, onFailure);
	    };

	    /**
	     * Provide the user with a routable PSTN number as a result of an IMRN allocation request.
	     * This is a SPiDR service only method.
	     *
	     * @name fcs.call#getIMRN
	     * @function
	     * @param {string} realm The pool of numbers from which IMRN will be allocated
	     * @param {string} source The URI of the individual placing the call
	     * @param {string} destination The URI of the individual receiving the call
	     * @param {function} onSuccess The onSuccess() callback to be called
	     * @param {function} onFailure The onFailure({@link fcs#Errors}) callback to be called
	     */

	    this.getIMRN = function(realm, source, destination, onSuccess, onFailure) {
	        var param = {
	            realm: realm,
	            source: source,
	            destination: destination
	        };
	        param = extend(param, {
	            serviceName: 'spidr'
	        });

	        return _manager.invoke('call', 'getIMRN', param, onSuccess, onFailure);
	    };

	    /**
	     * Return the stream refined by id
	     *
	     * This is a SPiDR service only method.
	     *
	     * @name fcs.call#getStreamById
	     * @function
	     * @param id of the stream
	     */
	    this.getStreamById = function(id) {
	        var param = {
	            streamId: id
	        };
	        param = extend(param, {
	            serviceName: 'spidr'
	        });

	        return _manager.invoke('call', 'getStreamById', param);
	    };

	    /**
	     * Delete selected stream
	     *
	     * This is a SPiDR service only method.
	     *
	     * @name fcs.call#removeStreamById
	     * @function
	     * @param id of the stream
	     */
	    this.removeStreamById = function(id) {
	        var param = {
	            streamId: id
	        };
	        param = extend(param, {
	            serviceName: 'spidr'
	        });

	        _manager.invoke('call', 'removeStreamById', param);
	    };

	    /**
	     * Sets specific audio input for the next call
	     *
	     * This is a SPiDR service only method.
	     *
	     * @name fcs.call#setSelectedMicrophoneId
	     * @function
	     * @param id of the audio input device
	     */
	    this.setSelectedMicrophoneId = function(id) {
	        var param = {
	            microphoneId: id
	        };
	        param = extend(param, {
	            serviceName: 'spidr'
	        });

	        _manager.invoke('call', 'setSelectedMicrophoneId', param);
	    };

	    /**
	     * Sets specific video input for the next call
	     *
	     * This is a SPiDR service only method.
	     *
	     * @name fcs.call#setSelectedCameraId
	     * @function
	     * @param id of the video input device
	     */
	    this.setSelectedCameraId = function(id) {
	        var param = {
	            cameraId: id
	        };
	        param = extend(param, {
	            serviceName: 'spidr'
	        });

	        _manager.invoke('call', 'setSelectedCameraId', param);
	    };

	    /**
	     * Sets specific video input for the next call
	     *
	     * This is a SPiDR service only method.
	     *
	     * @name fcs.call#setSelectedCameraId
	     * @function
	     * @param id of the video input device
	     */
	    this.setSelectedSpeakerId = function(id) {
	        var param = {
	            cameraId: id
	        };
	        param = extend(param, {
	            serviceName: 'spidr'
	        });

	        _manager.invoke('call', 'setSelectedSpeakerId', param);
	    };

	    /**
	     * Returns available video input sources
	     *
	     * This is a SPiDR service only method.
	     *
	     * @name fcs.call#getCameraList
	     * @function
	     * @param onSuccess success callback of getCameraList
	     */
	    this.getCameraList = function(onSuccess) {
	        var param = {};
	        param = extend(param, {
	            onSuccess: onSuccess,
	            serviceName: 'spidr'
	        });

	        return _manager.invoke('call', 'getCameraList', param);
	    };

	    /**
	     * Returns available audio input sources
	     *
	     * This is a SPiDR service only method.
	     *
	     * @name fcs.call#getMicrophoneList
	     * @function
	     * @param onSuccess success callback of getMicrophoneList
	     */
	    this.getMicrophoneList = function(onSuccess) {
	        var param = {};
	        param = extend(param, {
	            onSuccess: onSuccess,
	            serviceName: 'spidr'
	        });

	        return _manager.invoke('call', 'getMicrophoneList', param);
	    };

	    /**
	     * Returns available audio output sources
	     *
	     * This is a SPiDR service only method.
	     *
	     * @name fcs.call#getSpeakerList
	     * @function
	     * @param onSuccess success callback of getSpeakerList
	     */
	    this.getSpeakerList = function(onSuccess) {
	        var param = {};
	        param = extend(param, {
	            onSuccess: onSuccess,
	            serviceName: 'spidr'
	        });

	        return _manager.invoke('call', 'getSpeakerList', param);
	    };

	    /**
	     * Sets specific media device for active call
	     *
	     * This is a SPiDR service only method.
	     *
	     * @name fcs.call#changeDevices
	     * @function
	     * @param {object} contains new device ids and active call object
	     *                var params = {"call":call};
	     *
	     * @param {function} onSuccess The onSuccess() callback to be called
	     * @param {function} onFailure The onFailure({@link fcs#Errors}) callback to be called
	     *
	     * @since 4.0.0
	     * @example
	     * // SPiDR service example is as follows:
	     * // Change Media Devices
	     * // During an active call with selected device id
	     * // This method change media device which called with setSelectedSpeakerId,setSelectedCameraId or setSelectedMicrophoneId
	     *  var params = {"call":call};
	     *  fcs.call.setSelectedCameraId(videoDeviceId);
	     *  fcs.call.setSelectedMicrophoneId(audioDeviceId);
	     *  fcs.call.setSelectedSpeakerId(speakerDeviceId);
	     *
	     *  fcs.call.changeDevices(params,
	     *  function(){
	     *     showInfoMessage("Device change called.");
	     *  },function(){
	     *     showInfoMessage("Device change Failed.");
	     *  });
	     */
	    this.changeDevices = function(params, onSuccess, onFailure) {
	        return _manager.invoke('call', 'changeDevices', params, onSuccess, onFailure);
	    };

	    /**
	     * When an monitor session refreshed notification is received, {@link fcs.call#setOnMonitorSessionRefreshed} handler will be invoked.
	     *
	     * This is an RCC service only method.
	     *
	     * @name fcs.call#setOnMonitorSessionRefreshed
	     * @function
	     * @since 4.1.0
	     * @param {function} callback callback function for on monitor session refreshed
	     *
	     * @example
	     * onSuccess = function () {
	     *   console.log('Start monitor success');
	     *
	     *   fcs.call.setOnMonitorSessionRefreshed(
	     *       function () {
	     *           console.log('Received monitor session refreshed.');
	     *       });
	     * }
	     *
	     * onFailure = function () {
	     *   console.log('Start monitor failure');
	     * }
	     *
	     * fcs.call.startMonitorDevice(deviceID, onSuccess, onFailure);
	     *
	     */
	    this.setOnMonitorSessionRefreshed = function(callback) {
	        var param = {
	            callback: callback
	        };

	        param = extend(param, {
	            serviceName: 'rcc'
	        });

	        return _manager.invoke('call', 'setOnMonitorSessionRefreshed', param);
	    };

	    /**
	     * When an monitor session refreshed notification is received, {@link fcs.call#setOnMonitorSessionTerminated} handler will be invoked.
	     *
	     * This is an RCC service only method.
	     *
	     * @name fcs.call#setOnMonitorSessionTerminated
	     * @function
	     * @since 4.1.0
	     * @param {function} callback callback function for on monitor session terminated
	     *
	     * @example
	     * onSuccess = function () {
	     *   console.log('Start monitor success');
	     *
	     *   fcs.call.setOnMonitorSessionTerminated(
	     *       function () {
	     *           console.log('Received monitor session terminated.');
	     *       });
	     * }
	     *
	     * onFailure = function () {
	     *   console.log('Start monitor failure');
	     * }
	     *
	     * fcs.call.startMonitorDevice(deviceID, onSuccess, onFailure);
	     *
	     */
	    this.setOnMonitorSessionTerminated = function(callback) {
	        var param = {
	            callback: callback
	        };

	        param = extend(param, {
	            serviceName: 'rcc'
	        });

	        return _manager.invoke('call', 'setOnMonitorSessionTerminated', param);
	    };

	    /**
	     * When an incoming call is received, {@link fcs.call#event:onReceived} handler will be invoked.
	     *
	     * This is a SPiDR and RCC service class.
	     * Available for SPiDR since 3.0.0, and for RCC since 3.1.1.
	     *
	     * @name fcs.call#IncomingCall
	     * @class
	     * @augments fcs.call.Call
	     * @param {String} callid Unique identifier for the call
	     * @param {Object} opts options
	     * @param {String} callee Called party information. This is an RCC service parameter.
	     * @param {String} caller Calling party information. This is an RCC service parameter.
	     * @version 4.2.0
	     */
	    this.IncomingCall = function() {

	        /**
	         * Sets the handler for listening local video stream ready event.
	         *
	         * This is a SPiDR service only event.
	         *
	         * @name fcs.call#IncomingCall#onLocalStreamAdded
	         * @function
	         * @since 3.0.0.1
	         *
	         **/

	        /**
	         * Sets the handler for listening remote video stream ready event.
	         *
	         * This is a SPiDR service only event.
	         *
	         * @name fcs.call#IncomingCall#onStreamAdded
	         *
	         * @function
	         * @since 2.0.0
	         * @param {?String} streamUrl remote video streamUrl
	         *
	         **/

	        /**
	         *
	         * This is a SPiDR service only member.
	         *
	         * @name fcs.call#IncomingCall#calleeNumber
	         * @field
	         * @since 3.0.0
	         * @type {String}
	         *
	         * @example
	         *
	         * When an incoming call is received, {@link fcs.call#event:onReceived} handler will be invoked.
	         *
	         * var incomingCall = {};
	         * fcs.call.onReceived = function(call) {
	         *    incomingCall = call;
	         * };
	         *
	         * incomingCall.calleeNumber;
	         */

	        /**
	         *
	         * This is a SPiDR service only member.
	         *
	         * @name fcs.call#IncomingCall#callerNumber
	         * @field
	         * @since 3.0.0
	         * @type {String}
	         *
	         * @example
	         *
	         * When an incoming call is received, {@link fcs.call#event:onReceived} handler will be invoked.
	         *
	         * var incomingCall = {};
	         * fcs.call.onReceived = function(call) {
	         *    incomingCall = call;
	         * };
	         *
	         * incomingCall.callerNumber;
	         */

	        /**
	         *
	         * This is a SPiDR service only member.
	         *
	         * @name fcs.call#IncomingCall#callerName
	         * @field
	         * @since 3.0.0
	         * @type {String}
	         *
	         * @example
	         *
	         * When an incoming call is received, {@link fcs.call#event:onReceived} handler will be invoked.
	         *
	         * var incomingCall = {};
	         * fcs.call.onReceived = function(call) {
	         *    incomingCall = call;
	         * };
	         *
	         * incomingCall.callerName;
	         */

	        /**
	         *
	         * This is a SPiDR service only member.
	         *
	         * @name fcs.call#IncomingCall#primaryContact
	         * @field
	         * @since 3.0.0
	         * @type {String}
	         *
	         * @example
	         *
	         * When an incoming call is received, {@link fcs.call#event:onReceived} handler will be invoked.
	         *
	         * var incomingCall = {};
	         * fcs.call.onReceived = function(call) {
	         *    incomingCall = call;
	         * };
	         *
	         * incomingCall.primaryContact;
	         */

	        /**
	         * Puts the speaker into mute.
	         * This is a SPiDR service only method.
	         *
	         * @name fcs.call#IncomingCall#mute
	         * @function
	         * @since 3.0.0
	         *
	         * @example
	         *
	         * When an incoming call is received, {@link fcs.call#event:onReceived} handler will be invoked.
	         *
	         * var incomingCall = {};
	         * fcs.call.onReceived = function(call) {
	         *    incomingCall = call;
	         * };
	         *
	         * incomingCall.mute();
	         */

	        /**
	         * Puts the speaker into unmute.
	         * This is a SPiDR service only method.
	         *
	         * @name fcs.call#IncomingCall#unmute
	         * @function
	         * @since 3.0.0
	         *
	         * @example
	         *
	         * When an incoming call is received, {@link fcs.call#event:onReceived} handler will be invoked.
	         *
	         * var incomingCall = {};
	         * fcs.call.onReceived = function(call) {
	         *    incomingCall = call;
	         * };
	         *
	         * incomingCall.unmute();
	         */

	        /**
	         * Answers the call.
	         *
	         * This is a SPiDR and RCC service method.
	         *
	         * @name fcs.call#IncomingCall#answer
	         * @function
	         * @param {function} onSuccess The onSuccess() callback function to be called. In RCC, success callback is triggered when answered event is received.
	         * @param {function} onFailure The onFailure({@link fcs#Errors}) callback function to be called. In RCC, failure call back is triggered when end or failed event is received before answered event, or there is a state failure.
	         * @param {boolean} [isVideoEnabled] Start call with video or not. This is a SPiDR service only parameter.
	         * @param {String} [videoQuality] Video quality. This is a SPiDR service only parameter.
	         *
	         * @example
	         * // SPiDR service example is as follows:
	         * // @since 3.0.0
	         * // When an incoming call is received, {@link fcs.call#event:onReceived} handler will be invoked.
	         *
	         * var incomingCall = {};
	         * fcs.call.onReceived = function(call) {
	         *    incomingCall = call;
	         * };
	         *
	         * var onSuccess = function(){
	         *    console.log('Answer call success!');
	         * };
	         * var onError = function (err) {
	         *   console.log('Answer call failure!');
	         * };
	         *
	         * incomingCall.answer(onSuccess, onFailure, true, "1280x720");
	         *
	         * // RCC service example is as follows:
	         * // @since 3.1.1
	         * fcs.call.onReceived = function(call) {
	         *    incomingCall = call;
	         * };
	         *
	         * incomingCall.answer(
	         *  // onSuccess callback
	         *  function () {
	         *      console.log('Answer call success!');
	         *  },
	         *  // onFailure callback
	         *  function () {
	         *      console.log('Answer call failure!');
	         *  });
	         */

	        /**
	         * Rejects the call.
	         * This is a SPiDR service only method.
	         *
	         * @name fcs.call#IncomingCall#reject
	         * @function
	         * @since 3.0.0
	         * @param {function} onSuccess The onSuccess() callback function to be called
	         * @param {function} onFailure The onFailure({@link fcs#Errors}) callback function to be called
	         *
	         * @example
	         *
	         * When an incoming call is received, {@link fcs.call#event:onReceived} handler will be invoked.
	         *
	         * var incomingCall = {};
	         * fcs.call.onReceived = function(call) {
	         *    incomingCall = call;
	         * };
	         *
	         * var onSuccess = function(){
	         *    //do something here
	         * };
	         * var onError = function (err) {
	         *   //do something here
	         * };
	         *
	         * incomingCall.reject(onSuccess, onFailure);
	         */

	        /**
	         * Ignores the call. Client will not send any rest request for this one. Ignore is on client side only.
	         * This is a SPiDR service only method.
	         *
	         * @name fcs.call#IncomingCall#ignore
	         * @function
	         * @since 3.0.0
	         * @param {function} onSuccess The onSuccess() callback function to be called
	         * @param {function} onFailure The onFailure({@link fcs#Errors}) callback function to be called
	         *
	         * @example
	         *
	         * When an incoming call is received, {@link fcs.call#event:onReceived} handler will be invoked.
	         *
	         * var incomingCall = {};
	         * fcs.call.onReceived = function(call) {
	         *    incomingCall = call;
	         * };
	         *
	         * var onSuccess = function(){
	         *    //do something here
	         * };
	         * var onError = function (err) {
	         *   //do something here
	         * };
	         *
	         * incomingCall.ignore(onSuccess, onFailure);
	         */

	        /**
	         * Forwards the call.
	         *
	         * This is a SPiDR and RCC service method.
	         *
	         * @name fcs.call#IncomingCall#forward
	         * @function
	         * @param {string} address The address where the call is transferred (e.g. SIP URI)
	         * @param {function} onSuccess The onSuccess() callback function to be called
	         * @param {function} onFailure The onFailure({@link fcs#Errors}) callback function to be called
	         *
	         * @example
	         * // Available since 3.0.0 for SPiDR service, and since 3.1.1 for RCC service.
	         * // When an incoming call is received, {@link fcs.call#event:onReceived} handler will be invoked.
	         *
	         * var incomingCall = {};
	         * fcs.call.onReceived = function(call) {
	         *    incomingCall = call;
	         * };
	         *
	         * var onSuccess = function(){
	         *    console.log('Forward call success!');
	         * };
	         * var onError = function (err) {
	         *   console.log('Forward call failure!');
	         * };
	         *
	         * incomingCall.forward("user1@test.com", onSuccess, onFailure);
	         */

	        /**
	         *
	         * Checks the incoming call if it has reject option.
	         * This is a SPiDR service only method.
	         *
	         * @name fcs.call#IncomingCall#canReject
	         * @function
	         * @since 3.0.0
	         * @returns {Boolean}
	         *
	         * @example
	         *
	         * When an incoming call is received, {@link fcs.call#event:onReceived} handler will be invoked.
	         *
	         * var incomingCall = {};
	         * fcs.call.onReceived = function(call) {
	         *    incomingCall = call;
	         * };
	         *
	         * incomingCall.canReject();
	         */

	        /**
	         *
	         * Checks the incoming call if it has forward option.
	         *
	         * This is a SPiDR and RCC service method.
	         *
	         * @name fcs.call#IncomingCall#canForward
	         * @function
	         * @returns {Boolean}
	         *
	         * @example
	         * // Available since 3.0.0 for SPiDR service, and since 3.1.1 for RCC service.
	         * // When an incoming call is received, {@link fcs.call#event:onReceived} handler will be invoked.
	         *
	         * var incomingCall = {};
	         * fcs.call.onReceived = function(call) {
	         *    incomingCall = call;
	         * };
	         *
	         * incomingCall.canForward();
	         */

	        /**
	         * Checks the incoming call if it has answer option.
	         *
	         * This is a SPiDR and RCC service method.
	         *
	         * @name fcs.call#IncomingCall#canAnswer
	         * @function
	         * @returns {Boolean}
	         *
	         * @example
	         * // Available since 3.0.0 for SPiDR service, and since 3.1.1 for RCC service.
	         * // When an incoming call is received, {@link fcs.call#event:onReceived} handler will be invoked.
	         *
	         * var incomingCall = {};
	         * fcs.call.onReceived = function(call) {
	         *    incomingCall = call;
	         * };
	         *
	         * incomingCall.canAnswer();
	         */

	        /**
	         * Are we able to send video.
	         * Ex: Client may try to send video but video cam can be unplugged. Returns false in that case.
	         * This is a SPiDR service only method.
	         *
	         * @name fcs.call#IncomingCall#canSendVideo
	         * @function
	         * @since 3.0.0
	         * @returns {Boolean}
	         *
	         * @example
	         *
	         * When an incoming call is received, {@link fcs.call#event:onReceived} handler will be invoked.
	         *
	         * var incomingCall = {};
	         * fcs.call.onReceived = function(call) {
	         *    incomingCall = call;
	         * };
	         *
	         * incomingCall.canSendVideo();
	         */

	        /**
	         * Are we able to send video. Checks the incoming SDP.
	         * This is a SPiDR service only method.
	         *
	         * @name fcs.call#IncomingCall#canReceiveVideo
	         * @function
	         * @since 3.0.0
	         * @returns {Boolean}
	         *
	         * @example
	         *
	         * When an incoming call is received, {@link fcs.call#event:onReceived} handler will be invoked.
	         *
	         * var incomingCall = {};
	         * fcs.call.onReceived = function(call) {
	         *    incomingCall = call;
	         * };
	         *
	         * incomingCall.canReceiveVideo();
	         */

	        /**
	         * Returns hold state of call.
	         *
	         * This is a SPiDR and RCC service method.
	         *
	         * @name fcs.call#IncomingCall#getHoldState
	         * @function
	         * @returns {@link fcs.HoldStates} or undefined if call has not been put
	         * on hold.
	         *
	         * @example
	         * // Available since 3.0.4 for SPiDR service, and since 3.1.1 for RCC service.
	         * // When an incoming call is received, {@link fcs.call#event:onReceived} handler will be invoked.
	         *
	         * var incomingCall = {};
	         * fcs.call.onReceived = function(call) {
	         *    incomingCall = call;
	         * };
	         *
	         * incomingCall.getHoldState();
	         */

	        /**
	         * Gets called party.
	         *
	         * This is an RCC service method.
	         *
	         * @name fcs.call#IncomingCall#getCalledParty
	         * @function
	         * @returns {calledParty} string describing the called party
	         *
	         * @example
	         * // Available since 3.1.0 for RCC service.
	         *
	         *   fcs.call.onReceived = onCallReceived;
	         *   function onCallReceived(call) {
	         *       console.log("Called party: " + call.getCalledParty());
	         *   }
	         */

	        /**
	         * Gets calling party.
	         *
	         * This is an RCC service method.
	         *
	         * @name fcs.call#IncomingCall#getCallingParty
	         * @function
	         * @returns {callingParty} string describing the calling party
	         *
	         * @example
	         * // Available since 3.1.0 for RCC service.
	         *
	         *   fcs.call.onReceived = onCallReceived;
	         *   function onCallReceived(call) {
	         *       console.log("Calling party: " + call.getCallingParty());
	         *   }
	         */


	        /**
	         * Gets call id.
	         *
	         * This is a SPiDR and RCC service method.
	         *
	         * @name fcs.call#IncomingCall#getId
	         * @function
	         * @returns {id} Unique identifier for the call
	         *
	         * @example
	         * // Available since 3.0.0 for SPiDR service, and since 3.1.1 for RCC service.
	         * // When an incoming call is received, {@link fcs.call#event:onReceived} handler will be invoked.
	         *
	         * var incomingCall = {};
	         * fcs.call.onReceived = function(call) {
	         *    incomingCall = call;
	         * };
	         *
	         * incomingCall.getId();
	         */

	        /**
	         * End the call.
	         *
	         * This is a SPiDR and RCC service method.
	         *
	         * `Starting with the SPiDR 4.0.0 JSL API this method fires fcs.call.States.ENDED state.`
	         *
	         * @name fcs.call#IncomingCall#end
	         * @function
	         * @param {function} onSuccess The onSuccess() callback function to be called
	         * @param {function} onFailure The onFailure({@link fcs#Errors}) callback function to be called
	         *
	         * @example
	         * // Available since 3.0.0 for SPiDR service, and since 3.1.1 for RCC service.
	         * // When an incoming call is received, {@link fcs.call#event:onReceived} handler will be invoked.
	         *
	         * var incomingCall = {};
	         * fcs.call.onReceived = function(call) {
	         *    incomingCall = call;
	         * };
	         *
	         * incomingCall.end(
	         *   // onSuccess callback
	         *   function () {
	         *       console.log('Call is ended!');
	         *   },
	         *   // onFailure callback
	         *   function () {
	         *       console.log('Call could not be ended!');
	         *   });
	         */

	        /**
	         * Holds the call.
	         *
	         * This is a SPiDR and RCC service method.
	         *
	         * @name fcs.call#IncomingCall#hold
	         * @function
	         * @param {function} onSuccess The onSuccess() callback function to be called
	         * @param {function} onFailure The onFailure({@link fcs#Errors}) callback function to be called
	         *
	         * @example
	         * // Available since 3.0.0 for SPiDR service, and since 3.1.1 for RCC service.
	         * // When an incoming call is received, {@link fcs.call#event:onReceived} handler will be invoked.
	         *
	         * var incomingCall = {};
	         * fcs.call.onReceived = function(call) {
	         *    incomingCall = call;
	         * };
	         *
	         * var onSuccess = function(){
	         *    console.log('Call is held!');
	         * };
	         * var onFailure = function(err){
	         *    console.log('Call could not be held!');
	         * };
	         *
	         * incomingCall.hold(onSuccess, onFailure);
	         */

	        /**
	         * Resume the call.
	         *
	         * This is a SPiDR and RCC service method.
	         *
	         * @name fcs.call#IncomingCall#unhold
	         * @function
	         * @param {function} onSuccess The onSuccess() callback function to be called
	         * @param {function} onFailure The onFailure({@link fcs#Errors}) callback function to be called
	         *
	         * @example
	         * // Available since 3.0.0 for SPiDR service, and since 3.1.1 for RCC service.
	         * // When an incoming call is received, {@link fcs.call#event:onReceived} handler will be invoked.
	         *
	         * var incomingCall = {};
	         * fcs.call.onReceived = function(call) {
	         *    incomingCall = call;
	         * };
	         *
	         * var onSuccess = function(){
	         *    console.log('Call is retrieved!');
	         * };
	         * var onFailure = function(err){
	         *    console.log('Call could not be retrieved!');
	         * };
	         *
	         * incomingCall.unhold(onSuccess, onFailure);
	         */

	        /**
	         * Get WebRTC Statistics
	         *
	         * This is a SPiDR service method.
	         *
	         * @name fcs.call#IncomingCall#getWebRtcStats
	         * @function
	         * @param {function} onSuccess The onSuccess() callback function to be called
	         * @param {function} onFailure The onFailure({@link fcs#Errors}) callback function to be called
	         *
	         * @example
	         * // Available since 4.0.0 for SPiDR service.
	         * // When an incoming call is received, {@link fcs.call#event:onReceived} handler will be invoked.
	         *
	         * var incomingCall = {};
	         * fcs.call.onReceived = function(call) {
	         *    incomingCall = call;
	         * };
	         *
	         * incomingCall.getWebRtcStats(function(stats) {
	         *          // Stats returned successfully
	         *          logger.debug("Audio Packets Lost: " + stats.audio.packetsLost);
	         *      },
	         *      function(error) {
	         *          // Error occured
	         *          logger.error("getWebRtcStats failed: " + error);
	         *      }
	         * );
	         */

	        /**
	         * Get Native WebRTC Statistics
	         *
	         * This is a SPiDR service method.
	         *
	         * @name fcs.call#IncomingCall#getNativeWebRtcStats
	         * @function
	         * @param {function} onSuccess The onSuccess() callback function to be called
	         * @param {function} onFailure The onFailure({@link fcs#Errors}) callback function to be called
	         *
	         * @example
	         * // Available since 4.0.0 for SPiDR service.
	         * // When an incoming call is received, {@link fcs.call#event:onReceived} handler will be invoked.
	         *
	         * var incomingCall = {};
	         * fcs.call.onReceived = function(call) {
	         *    incomingCall = call;
	         * };
	         *
	         * incomingCall.getNativeWebRtcStats(function(results) {
	         *          // Stats returned successfully
	         *          logger.debug("getNativeWebRtcStats returned successfully: " + results);
	         *      },
	         *      function(error) {
	         *          // Error occured
	         *          logger.error("getNativeWebRtcStats failed: " + error);
	         *      }
	         *   );
	         */

	        /**
	         * Start WebRtc Statistics Timer
	         *
	         * This is a SPiDR service method.
	         *
	         * @name fcs.call#IncomingCall#startWebRtcStatsTimer
	         * @function
	         * @param {string} interval The interval is a parameter that determines how many seconds if necessary turning statistics(e.g. 10 seconds)
	         * @param {function} onSuccess The onSuccess() callback function to be called
	         * @param {function} onFailure The onFailure({@link fcs#Errors}) callback function to be called
	         *
	         * @example
	         * // Available since 4.0.0 for SPiDR service.
	         * // When an incoming call is received, {@link fcs.call#event:onReceived} handler will be invoked.
	         *
	         * var incomingCall = {};
	         * fcs.call.onReceived = function(call) {
	         *    incomingCall = call;
	         * };
	         *
	         * incomingCall.startWebRtcStatsTimer(interval,
	         *      function(stats) {
	         *          // Stats returned successfully
	         *          logger.debug("Audio Packets Lost: " + stats.audio.packetsLost);
	         *      },
	         *      function(error) {
	         *          // Error occured
	         *          logger.error("startWebRtcStatsTimer failed: " + error);
	         *      }
	         *   );
	         */

	        /**
	         * Stop WebRtc Statistics Timer
	         *
	         * This is a SPiDR service method.
	         *
	         * @name fcs.call#IncomingCall#stopWebRtcStatsTimer
	         * @function
	         *
	         * @example
	         * // Available since 4.0.0 for SPiDR service.
	         * // When an incoming call is received, {@link fcs.call#event:onReceived} handler will be invoked.
	         *
	         * var incomingCall = {};
	         * fcs.call.onReceived = function(call) {
	         *    incomingCall = call;
	         * };
	         *
	         * incomingCall.stopWebRtcStatsTimer();
	         */

	        /**
	         * Directly transfers the existing call to another recipient.
	         *
	         * This is a SPiDR and RCC service method.
	         *
	         * @name fcs.call#IncomingCall#directTransfer
	         * @function
	         * @param {string} address The address where the call is transferred (e.g. SIP URI)
	         * @param {function} onSuccess The onSuccess() callback function to be called
	         * @param {function} onFailure The onFailure({@link fcs#Errors}) callback function to be called
	         *
	         * @example
	         * // Available since 3.0.0 for SPiDR service, and since 3.1.1 for RCC service.
	         * // When an incoming call is received, {@link fcs.call#event:onReceived} handler will be invoked.
	         *
	         * var incomingCall = {};
	         * fcs.call.onReceived = function(call) {
	         *    incomingCall = call;
	         * };
	         *
	         * var onSuccess = function(){
	         *    console.log('Call is transferred!');
	         * };
	         * var onFailure = function(err){
	         *    console.log('Call could not be transferred!');
	         * };
	         *
	         * incomingCall.directTransfer("user@domain.com", onSuccess, onFailure);
	         */

	        /**
	         * Transfers an existing call to another existing call.
	         *
	         *
	         * @name fcs.call#IncomingCall#consultativeTransfer
	         * @function
	         * @since 3.1.1
	         * @param {string} transferredCallId The id of call which will be transferred into the current(incoming) call
	         * @param {function} onSuccess The onSuccess() callback function to be called
	         * @param {function} onFailure The onFailure({@link fcs#Errors}) callback function to be called
	         *
	         * @example
	         *
	         * // When an outgoing call is received, {@link fcs.call.event:onOutgoingCall} handler will be invoked.
	         *
	         * var outgoingCall = {};
	         * fcs.call.onOutgoingCall = function(call) {
	         *    outgoingCall = call;
	         * };
	         *
	         * // When an incoming call is received, {@link fcs.call#event:onReceived} handler will be invoked.
	         *
	         * var incomingCall = {};
	         * fcs.call.onReceived = function(call) {
	         *    incomingCall = call;
	         * };
	         *
	         * incomingCall.consultativeTransfer(outgoingCall.getId(), onSuccess, onFailure);
	         */

	        /**
	         * Stop the video for this call after the call is established.
	         * This is a SPiDR service only method.
	         *
	         * @name fcs.call#IncomingCall#videoStop
	         * @function
	         * @since 3.0.0
	         * @param {function} onSuccess The onSuccess() callback function to be called
	         * @param {function} onFailure The onFailure({@link fcs#Errors}) callback function to be called
	         *
	         * @example
	         *
	         * When an incoming call is received, {@link fcs.call#event:onReceived} handler will be invoked.
	         *
	         * var incomingCall = {};
	         * fcs.call.onReceived = function(call) {
	         *    incomingCall = call;
	         * };
	         *
	         * var onSuccess = function(){
	         *    //do something here
	         * };
	         * var onFailure = function(err){
	         *    //do something here
	         * };
	         *
	         * incomingCall.videoStop(onSuccess, onFailure);
	         */

	        /**
	         * Start the video for this call after the call is established.
	         * This is a SPiDR service only method.
	         *
	         * @name fcs.call#IncomingCall#videoStart
	         * @function
	         * @since 3.0.0
	         * @param {function} onSuccess The onSuccess() callback function to be called
	         * @param {function} onFailure The onFailure() callback function to be called
	         * @param {string} [videoQuality] Sets the quality of video, this parameter will be passed to getUserMedia()
	         *                  if the video source is allowed before, this parameter will not be used
	         *
	         * @example
	         *
	         * When an incoming call is received, {@link fcs.call#event:onReceived} handler will be invoked.
	         *
	         * var incomingCall = {};
	         * fcs.call.onReceived = function(call) {
	         *    incomingCall = call;
	         * };
	         *
	         * var onSuccess = function(){
	         *    //do something here
	         * };
	         * var onFailure = function(err){
	         *    //do something here
	         * };
	         *
	         * incomingCall.videoStart(onSuccess, onFailure);
	         */

	        /**
	         * Join 2 calls.
	         * You need two different calls to establish this functionality.<br>
	         *
	         * In SPiDR implementation: in order to join two calls both calls must
	         * be put into hold state first.<br>
	         *
	         * In RCC implementation: in order to join two calls one call must
	         * be in local hold state, and the other one must be in answered state. <br>
	         *
	         * If not call servers will not handle your request.
	         *
	         * This is a SPiDR and RCC service method.
	         *
	         * @name fcs.call#IncomingCall#join
	         * @function
	         * @param {fcs.call#Call} anotherCall Call that we want the current call to be joined to.
	         * @param {function} onSuccess The onSuccess({@link fcs.call#Call}) to be called when the call have been joined provide the joined call as parameter
	         * @param {function} [onFailure] The onFailure() to be called when media could not be join
	         * @param {boolean} [isVideoEnabled] In order to join video calls set this to true. This is a SPiDR service only parameter.
	         * @param {string} [videoQuality] Sets the quality of video. This is a SPiDR service only parameter.
	         *
	         * @example
	         * // Available since 3.0.0 for SPiDR service, and since 3.1.1 for RCC service.
	         * // When an incoming call is received, {@link fcs.call#event:onReceived} handler will be invoked.
	         *
	         * var incomingCall = {};
	         * fcs.call.onReceived = function(call) {
	         *    incomingCall = call;
	         * };
	         *
	         * // And another {@link fcs.call#OutgoingCall} or {@link fcs.call#IncomingCall} is required which is going to be joined.
	         * var anotherCall; // assume this is previosuly created.
	         *
	         * var joinOnSuccess = function(joinedCall){
	         *    joinedCall // newly created.
	         *    console.log('Join success!');
	         * };
	         * var joinOnFailure = function(){
	         *    console.log('Join failure!');
	         * };
	         *
	         * incomingCall.join(anotherCall, joinOnSuccess, joinOnFailure, isVideoEnabled, videoQuality);
	         *
	         * // When join() is successfuly completed, joinOnSuccess({@link fcs.call#OutgoingCall}) will be invoked.
	         */

	        /**
	         * Send Dual-tone multi-frequency signaling.
	         * This is a SPiDR service only method.
	         *
	         * @name fcs.call#IncomingCall#sendDTMF
	         * @function
	         * @since 3.0.0
	         * @param {String} tone Tone to be send as dtmf.
	         *
	         * @example
	         *
	         * When an incoming call is received, {@link fcs.call#event:onReceived} handler will be invoked.
	         *
	         * var incomingCall = {};
	         * fcs.call.onReceived = function(call) {
	         *    incomingCall = call;
	         * };
	         *
	         * incomingCall.sendDTMF("0");
	         */

	        /**
	         * Force the plugin to send a IntraFrame
	         * Only used by PLUGIN.
	         * This needs to be called when sending video.
	         * Solves video freeze issue.
	         * This is a SPiDR service only method.
	         *
	         * @name fcs.call#IncomingCall#sendIntraFrame
	         * @function
	         * @since 3.0.0
	         *
	         * @example
	         *
	         * When an incoming call is received, {@link fcs.call#event:onReceived} handler will be invoked.
	         *
	         * var incomingCall = {};
	         * fcs.call.onReceived = function(call) {
	         *    incomingCall = call;
	         * };
	         *
	         * incomingCall.sendIntraFrame();
	         */

	        /**
	         * Force the plugin to send a BlackFrame
	         * Only used by PLUGIN.
	         * Some of the SBC's(Session Border Controllers) do not establish one way video.
	         * audio only side has to send a blackFrame in order to see the incoming video.
	         * This is a SPiDR service only method.
	         *
	         * @name fcs.call#IncomingCall#sendBlackFrame
	         * @function
	         * @since 3.0.0
	         *
	         * @example
	         *
	         * When an incoming call is received, {@link fcs.call#event:onReceived} handler will be invoked.
	         *
	         * var incomingCall = {};
	         * fcs.call.onReceived = function(call) {
	         *    incomingCall = call;
	         * };
	         *
	         * incomingCall.sendBlackFrame();
	         */

	        /**
	         * Force the plugin to refresh video renderer
	         * with this call's remote video stream
	         * Only used by PLUGIN.
	         * This is a SPiDR service only method.
	         *
	         * @name fcs.call#IncomingCall#refreshVideoRenderer
	         * @function
	         * @since 3.0.0
	         *
	         * @example
	         *
	         * When an incoming call is received, {@link fcs.call#event:onReceived} handler will be invoked.
	         *
	         * var incomingCall = {};
	         * fcs.call.onReceived = function(call) {
	         *    incomingCall = call;
	         * };
	         *
	         * incomingCall.refreshVideoRenderer();
	         */

	        /**
	         * Returns the call is a join call or not
	         * Do not use this function if you really dont need it.
	         * This will be handled by the framework.
	         * This is a SPiDR service only method.
	         *
	         * @name fcs.call#IncomingCall#getJoin
	         * @function
	         * @since 3.0.0
	         * @returns {Boolean} isJoin
	         *
	         * @example
	         *
	         * When an incoming call is received, {@link fcs.call#event:onReceived} handler will be invoked.
	         *
	         * var incomingCall = {};
	         * fcs.call.onReceived = function(call) {
	         *    incomingCall = call;
	         * };
	         *
	         * incomingCall.getJoin();
	         */

	        /**
	         * Marks the call as a join call or not
	         * Do not use this function if you really dont need it.
	         * This will be handled by the framework.
	         * This is a SPiDR service only method.
	         *
	         * @name fcs.call#IncomingCall#setJoin
	         * @function
	         * @since 3.0.0
	         * @param {String} join
	         *
	         * @example
	         *
	         * When an incoming call is received, {@link fcs.call#event:onReceived} handler will be invoked.
	         *
	         * var incomingCall = {};
	         * fcs.call.onReceived = function(call) {
	         *    incomingCall = call;
	         * };
	         *
	         * incomingCall.setJoin(true);
	         */

	        /**
	         * Returns the button is a disabled or not
	         * You may want to disable your buttons while waiting for a response.
	         * Ex: this will prevent clicking multiple times for hold button until first hold response is not recieved.
	         * This is a SPiDR service only method.
	         *
	         * @name fcs.call#IncomingCall#getButtonDisabler
	         * @function
	         * @since 3.0.0
	         * @returns {Boolean} buttonDisabler
	         *
	         * @example
	         *
	         * When an incoming call is received, {@link fcs.call#event:onReceived} handler will be invoked.
	         *
	         * var incomingCall = {};
	         * fcs.call.onReceived = function(call) {
	         *    incomingCall = call;
	         * };
	         *
	         * incomingCall.getButtonDisabler();
	         */

	        /**
	         * Disable the button after waiting 4000 milliseconds.
	         * You may want to disable your buttons while waiting for a response.
	         * Ex: this will prevent clicking multiple times for hold button until first hold response is not recieved.
	         * This is a SPiDR service only method.
	         *
	         * @name fcs.call#IncomingCall#setButtonDisabler
	         * @function
	         * @since 3.0.0
	         * @param {Boolean} disable
	         *
	         * @example
	         *
	         * When an incoming call is received, {@link fcs.call#event:onReceived} handler will be invoked.
	         *
	         * var incomingCall = {};
	         * fcs.call.onReceived = function(call) {
	         *    incomingCall = call;
	         * };
	         *
	         * incomingCall.setButtonDisabler(true);
	         */

	        /**
	         * Clears the timer set with fcs.call#IncomingCall#setButtonDisabler.
	         * You may want to disable your buttons while waiting for a response.
	         * Ex: this will prevent clicking multiple times for hold button until first hold response is not recieved.
	         * This is a SPiDR service only method.
	         *
	         * @name fcs.call#IncomingCall#clearBtnTimeout
	         * @function
	         * @since 3.0.0
	         *
	         * @example
	         *
	         * When an incoming call is received, {@link fcs.call#event:onReceived} handler will be invoked.
	         *
	         * var incomingCall = {};
	         * fcs.call.onReceived = function(call) {
	         *    incomingCall = call;
	         * };
	         *
	         * incomingCall.clearBtnTimeout();
	         */


	        /**
	         * Long call audit
	         * Creates a timer after call is established.
	         * This timer sends a "PUT" request to server.
	         * This will continue until one request fails.
	         * Handled by framework. You dont need to call this function.
	         * This is a SPiDR service only method.
	         *
	         * @name fcs.call#IncomingCall#setAuditTimer
	         * @function
	         * @since 3.0.0
	         * @param {String} audit
	         *
	         * @example
	         *
	         * When an incoming call is received, {@link fcs.call#event:onReceived} handler will be invoked.
	         * incomingCall.setAuditTimer(audit);
	         */


	        /**
	         * Clears the long call audit prior to clearing all call resources.
	         * Handled by framework. you dont need to call this function.
	         * This is a SPiDR service only method.
	         *
	         * @name fcs.call#IncomingCall#clearAuditTimer
	         * @function
	         * @since 3.0.0
	         *
	         * @example
	         *
	         * When an incoming call is received, {@link fcs.call#event:onReceived} handler will be invoked.
	         */

	        /**
	         * @deprecated DO NOT USE, use isVideoNegotiationAvailable instead
	         * Returns video negotation availability.
	         *
	         * This is a SPiDR service only method.
	         *
	         * @name fcs.call#IncomingCall#isVideoNegotationAvailable
	         * @function
	         * @since 3.0.1
	         * @param {String} id Unique identifier for the call
	         * @example
	         * When an incoming call is received, {@link fcs.call#event:onReceived} handler will be invoked.
	         *
	         * var incomingCall = {};
	         * fcs.call.onReceived = function(call) {
	         *    incomingCall = call;
	         * };
	         *
	         * incomingCall.isVideoNegotationAvailable();
	         */

	        /**
	         * Returns video negotiation availability.
	         *
	         * This is a SPiDR service only method.
	         *
	         * @name fcs.call#IncomingCall#isVideoNegotiationAvailable
	         * @function
	         * @since 3.1.0
	         * @example
	         * When an incoming call is received, {@link fcs.call#event:onReceived} handler will be invoked.
	         *
	         * var incomingCall = {};
	         * fcs.call.onReceived = function(call) {
	         *    incomingCall = call;
	         * };
	         *
	         * incomingCall.isVideoNegotiationAvailable();
	         */
	    };

	    /**
	     * This class is used to represent an outgoing call.
	     *
	     * This is a SPiDR and RCC service class.
	     * Available for SPiDR since 3.0.0, and for RCC since 3.1.1.
	     *
	     * @name fcs.call#OutgoingCall
	     * @class
	     * @augments fcs.call.Call
	     * @param {String} callid Unique identifier for the call
	     * @param {String} callee Called party information. This is an RCC service parameter. Exists in received calls. Does not exist in rcc client started calls.
	     * @param {String} caller Calling party information. This is an RCC service parameter. Exists in received calls. Does not exist in rcc client started calls.
	     * @version 4.2.0
	     */
	    this.OutgoingCall = function() {

	        /**
	         * Sets the handler for listening local video stream ready event.
	         *
	         * This is a SPiDR service only event.
	         *
	         * @name fcs.call#OutgoingCall#onLocalStreamAdded
	         * @function
	         * @since 3.0.0.1
	         *
	         **/

	        /**
	         * Sets the handler for listening remote video stream ready event.
	         *
	         * This is a SPiDR service only event.
	         *
	         * @name fcs.call#OutgoingCall#onStreamAdded
	         *
	         * @function
	         * @since 2.0.0
	         * @param {?String} streamUrl remote video streamUrl
	         *
	         **/

	        /**
	         * Are we able to send video.
	         * Ex: Client may try to send video but video cam can be unplugged. Returns false in that case.
	         *
	         * This is a SPiDR service only method.
	         *
	         * @name fcs.call#OutgoingCall#canSendVideo
	         * @function
	         * @since 3.0.0
	         * @returns {Boolean}
	         *
	         * @example
	         *
	         * A previously created {@link fcs.call#OutgoingCall} is required. {@see {@link fcs.call#startCall}} for more details.
	         *
	         * var outgoingCall = {};
	         * fcs.call.startCall(..., ..., ..., onSuccess(outgoingCall), ..., ...);
	         * outgoingCall.canSend();
	         */

	        /**
	         * Are we able to send video. Checks the incoming SDP.
	         * This is a SPiDR service only method.
	         *
	         * @name fcs.call#OutgoingCall#canReceiveVideo
	         * @function
	         * @since 3.0.0
	         * @returns {Boolean}
	         *
	         * @example
	         *
	         * A previously created {@link fcs.call#OutgoingCall} is required. {@see {@link fcs.call#startCall}} for more details.
	         *
	         * var outgoingCall = {};
	         * fcs.call.startCall(..., ..., ..., onSuccess(outgoingCall), ..., ...);
	         * outgoingCall.canReceiveVideo();
	         */

	        /**
	         * Returns hold state of call.
	         *
	         * This is a SPiDR and RCC service method.
	         *
	         * @name fcs.call#OutgoingCall#getHoldState
	         * @function
	         * @returns {@link fcs.HoldStates} or undefined if call has not been put
	         * on hold.
	         *
	         * @example
	         * // Available since 3.0.4 for SPiDR service, and since 3.1.1 for RCC service.
	         * // When an outgoingCall call is received, {@link fcs.call#event:onReceived} handler will be invoked.
	         *
	         * var outgoingCall = {};
	         * fcs.call.startCall(..., ..., ..., onSuccess(outgoingCall), ..., ...);
	         *
	         * outgoingCall.getHoldState();
	         */


	        /**
	         * Gets called party.
	         *
	         * This is an RCC service method. This paremeter exists in received calls. Does not exist in rcc client started calls.
	         *
	         * @name fcs.call#OutgoingCall#getCalledParty
	         * @function
	         * @returns {calledParty} string describing the called party
	         *
	         * @example
	         * // Available since 3.1.0 for RCC service.
	         *
	         *   fcs.call.onOutgoingCall = onOutgoingCall;
	         *   function onOutgoingCall(call) {
	         *       console.log("Called party: " + call.getCalledParty());
	         *   }
	         */

	        /**
	         * Gets calling party.
	         *
	         * This is an RCC service method. This paremeter exists in received calls. Does not exist in rcc client started calls.
	         *
	         * @name fcs.call#OutgoingCall#getCallingParty
	         * @function
	         * @returns {callingParty} string describing the calling party
	         *
	         * @example
	         * // Available since 3.1.0 for RCC service.
	         *
	         *   fcs.call.onOutgoingCall = onOutgoingCall;
	         *   function onOutgoingCall(call) {
	         *       console.log("Calling party: " + call.getCallingParty());
	         *   }
	         */


	        /**
	         * Gets call id.
	         *
	         * This is a SPiDR and RCC service method.
	         *
	         * @name fcs.call#OutgoingCall#getId
	         * @function
	         * @returns {id} Unique identifier for the call
	         *
	         * @example
	         * // Available since 3.0.0 for SPiDR service, and since 3.1.1 for RCC service.
	         * // A previously created {@link fcs.call#OutgoingCall} is required. {@see {@link fcs.call#startCall}} for more details.
	         *
	         * var outgoingCall = {};
	         * fcs.call.startCall(..., ..., ..., onSuccess(outgoingCall), ..., ...);
	         * outgoingCall.getId();
	         */

	        /**
	         * Force the plugin to send a IntraFrame.
	         * This is a SPiDR service only method.
	         *
	         * @name fcs.call#OutgoingCall#sendIntraFrame
	         * @function
	         * @since 3.0.0
	         *
	         * @example
	         *
	         * A previously created {@link fcs.call#OutgoingCall} is required. {@see {@link fcs.call#startCall}} for more details.
	         *
	         * var outgoingCall = {};
	         * fcs.call.startCall(..., ..., ..., onSuccess(outgoingCall), ..., ...);
	         * outgoingCall.sendIntraFrame();
	         */

	        /**
	         * Force the plugin to send a BlackFrame.
	         * This is a SPiDR service only method.
	         *
	         * @name fcs.call#OutgoingCall#sendBlackFrame
	         * @function
	         * @since 3.0.0
	         *
	         * @example
	         *
	         * A previously created {@link fcs.call#OutgoingCall} is required. {@see {@link fcs.call#startCall}} for more details.
	         *
	         * var outgoingCall = {};
	         * fcs.call.startCall(..., ..., ..., onSuccess(outgoingCall), ..., ...);
	         * outgoingCall.sendBlackFrame();
	         */

	        /**
	         * Force the plugin to refresh video renderer
	         * with this call's remote video stream.
	         * This is a SPiDR service only method.
	         *
	         * @name fcs.call#OutgoingCall#refreshVideoRenderer
	         * @function
	         * @since 3.0.0
	         *
	         * @example
	         *
	         * A previously created {@link fcs.call#OutgoingCall} is required. {@see {@link fcs.call#startCall}} for more details.
	         *
	         * var outgoingCall = {};
	         * fcs.call.startCall(..., ..., ..., onSuccess(outgoingCall), ..., ...);
	         * outgoingCall.refreshVideoRenderer();
	         */

	        /**
	         * Puts the speaker into mute.
	         * This is a SPiDR service only method.
	         *
	         * @name fcs.call#OutgoingCall#mute
	         * @function
	         * @since 3.0.0
	         *
	         * @example
	         *
	         * A previously created {@link fcs.call#OutgoingCall} is required. {@see {@link fcs.call#startCall}} for more details.
	         *
	         * var outgoingCall = {};
	         * fcs.call.startCall(..., ..., ..., onSuccess(outgoingCall), ..., ...);
	         * outgoingCall.mute();
	         */

	        /**
	         * Puts the speaker into unmute.
	         * This is a SPiDR service only method.
	         *
	         * @name fcs.call#OutgoingCall#unmute
	         * @function
	         * @since 3.0.0
	         *
	         * @example
	         *
	         * A previously created {@link fcs.call#OutgoingCall} is required. {@see {@link fcs.call#startCall}} for more details.
	         *
	         * var outgoingCall = {};
	         * fcs.call.startCall(..., ..., ..., onSuccess(outgoingCall), ..., ...);
	         * outgoingCall.unmute();
	         */

	        /**
	         * End the call.
	         *
	         * `Starting with the SPiDR 4.0.0 JSL API this method fires fcs.call.States.ENDED state.`
	         *
	         * This is a SPiDR and RCC service method.
	         *
	         * @name fcs.call#OutgoingCall#end
	         * @param {function} onSuccess The onSuccess() callback function to be called
	         * @param {function} onFailure The onFailure({@link fcs#Errors}) callback function to be called
	         * @function
	         *
	         * @example
	         * // Available since 3.0.0 for SPiDR service, and since 3.1.1 for RCC service.
	         * // A previously created {@link fcs.call#OutgoingCall} is required. {@see {@link fcs.call#startCall}} for more details.
	         *
	         * var outgoingCall = {};
	         * fcs.call.startCall(..., ..., ..., onSuccess(outgoingCall), ..., ...);
	         *
	         * outgoingCall.end(
	         *   // onSuccess callback
	         *   function () {
	         *       console.log('Call is ended!');
	         *   },
	         *   // onFailure callback
	         *   function () {
	         *       console.log('Call could not be ended!');
	         *   });
	         */

	        /**
	         * Holds the call.
	         *
	         * This is a SPiDR and RCC service method.
	         *
	         * @name fcs.call#OutgoingCall#hold
	         * @function
	         * @param {function} onSuccess The onSuccess() callback function to be called
	         * @param {function} onFailure The onFailure({@link fcs#Errors}) callback function to be called
	         *
	         * @example
	         * // Available since 3.0.0 for SPiDR service, and since 3.1.1 for RCC service.
	         * // A previously created {@link fcs.call#OutgoingCall} is required. {@see {@link fcs.call#startCall}} for more details.
	         *
	         * var outgoingCall = {};
	         * fcs.call.startCall(..., ..., ..., onSuccess(outgoingCall), ..., ...);
	         *
	         * var holdCallOnSuccess = function(){
	         *    console.log('Call is held!');
	         * };
	         * var holdCallOnFailure = function(err){
	         *    console.log('Call could not be held!');
	         * };
	         *
	         * outgoingCall.hold(holdCallOnSuccess, holdCallOnFailure);
	         */

	        /**
	         * Resume the call.
	         *
	         * This is a SPiDR and RCC service method.
	         *
	         * @name fcs.call#OutgoingCall#unhold
	         * @function
	         * @param {function} onSuccess The onSuccess() callback function to be called
	         * @param {function} onFailure The onFailure({@link fcs#Errors}) callback function to be called
	         *
	         * @example
	         * // Available since 3.0.0 for SPiDR service, and since 3.1.1 for RCC service.
	         * // A previously created {@link fcs.call#OutgoingCall} is required. {@see {@link fcs.call#startCall}} for more details.
	         *
	         * var outgoingCall = {};
	         * fcs.call.startCall(..., ..., ..., onSuccess(outgoingCall), ..., ...);
	         *
	         * var unholdCallOnSuccess = function(){
	         *    console.log('Call is retrieved!');
	         * };
	         * var unholdCallOnFailure = function(err){
	         *    console.log('Call could not be retrieved!');
	         * };
	         *
	         * outgoingCall.unhold(unholdCallOnSuccess, unholdCallOnFailure);
	         */

	        /**
	         * Get WebRTC Statistics
	         *
	         * This is a SPiDR service method.
	         *
	         * @name fcs.call#OutgoingCall#getWebRtcStats
	         * @function
	         * @param {function} onSuccess The onSuccess() callback function to be called
	         * @param {function} onFailure The onFailure({@link fcs#Errors}) callback function to be called
	         *
	         * @example
	         * // Available since 4.0.0 for SPiDR service.
	         * // A previously created {@link fcs.call#OutgoingCall} is required. {@see {@link fcs.call#startCall}} for more details.
	         *
	         * var outgoingCall = {};
	         * fcs.call.startCall(..., ..., ..., onSuccess(outgoingCall), ..., ...);
	         *
	         * outgoingCall.getWebRtcStats(function(stats) {
	         *          // Stats returned successfully
	         *          logger.debug("Audio Packets Lost: " + stats.audio.packetsLost);
	         *      },
	         *      function(error) {
	         *          // Error occured
	         *          logger.error("getWebRtcStats failed: " + error);
	         *      }
	         * );
	         */

	        /**
	         * Get Native WebRTC Statistics
	         *
	         * This is a SPiDR service method.
	         *
	         * @name fcs.call#OutgoingCall#getNativeWebRtcStats
	         * @function
	         * @param {function} onSuccess The onSuccess() callback function to be called
	         * @param {function} onFailure The onFailure({@link fcs#Errors}) callback function to be called
	         *
	         * @example
	         * // Available since 4.0.0 for SPiDR service.
	         * // A previously created {@link fcs.call#OutgoingCall} is required. {@see {@link fcs.call#startCall}} for more details.
	         *
	         * var outgoingCall = {};
	         * fcs.call.startCall(..., ..., ..., onSuccess(outgoingCall), ..., ...);
	         *
	         *  outgoingCall.getNativeWebRtcStats(function(results) {
	         *          // Stats returned successfully
	         *          logger.debug("getNativeWebRtcStats returned successfully: " + results);
	         *      },
	         *      function(error) {
	         *          // Error occured
	         *          logger.error("getNativeWebRtcStats failed: " + error);
	         *      }
	         *   );
	         */

	        /**
	         * Start WebRtc Statistics Timer
	         *
	         * This is a SPiDR service method.
	         *
	         * @name fcs.call#OutgoingCall#startWebRtcStatsTimer
	         * @function
	         * @param {string} interval The interval is a parameter that determines how many seconds if necessary turning statistics(e.g. 10 seconds)
	         * @param {function} onSuccess The onSuccess() callback function to be called
	         * @param {function} onFailure The onFailure({@link fcs#Errors}) callback function to be called
	         *
	         * @example
	         * // Available since 4.0.0 for SPiDR service.
	         * // A previously created {@link fcs.call#OutgoingCall} is required. {@see {@link fcs.call#startCall}} for more details.
	         *
	         * var outgoingCall = {};
	         * fcs.call.startCall(..., ..., ..., onSuccess(outgoingCall), ..., ...);
	         *
	         *  outgoingCall.startWebRtcStatsTimer(interval,
	         *      function(stats) {
	         *          // Stats returned successfully
	         *          logger.debug("Audio Packets Lost: " + stats.audio.packetsLost);
	         *      },
	         *      function(error) {
	         *          // Error occured
	         *          logger.error("startWebRtcStatsTimer failed: " + error);
	         *      }
	         *   );
	         */

	        /**
	         * Stop WebRtc Statistics Timer
	         *
	         * This is a SPiDR service method.
	         *
	         * @name fcs.call#OutgoingCall#stopWebRtcStatsTimer
	         * @function
	         *
	         * @example
	         * // Available since 4.0.0 for SPiDR service.
	         * // A previously created {@link fcs.call#OutgoingCall} is required. {@see {@link fcs.call#startCall}} for more details.
	         *
	         * var outgoingCall = {};
	         * fcs.call.startCall(..., ..., ..., onSuccess(outgoingCall), ..., ...);
	         *
	         * outgoingCall.stopWebRtcStatsTimer();
	         */

	        /**
	         * Directly transfers the existing call to another recipient.
	         *
	         * This is a SPiDR and RCC service method.
	         *
	         * @name fcs.call#OutgoingCall#directTransfer
	         * @function
	         * @param {string} address The address where the call is transferred (e.g. SIP URI)
	         * @param {function} onSuccess The onSuccess() callback function to be called
	         * @param {function} onFailure The onFailure({@link fcs#Errors}) callback function to be called
	         *
	         * @example
	         * // Available since 3.0.0 for SPiDR service, and since 3.1.1 for RCC service.
	         * // A previously created {@link fcs.call#OutgoingCall} is required. {@see {@link fcs.call#startCall}} for more details.
	         *
	         * var outgoingCall = {};
	         * fcs.call.startCall(..., ..., ..., onSuccess(outgoingCall), ..., ...);
	         *
	         * var onSuccess = function(){
	         *    console.log('Call is transferred!');
	         * };
	         * var onFailure = function(err){
	         *    console.log('Call could not be transferred!');
	         * };
	         *
	         * outgoingCall.directTransfer("user@domain.com", onSuccess, onFailure);
	         */

	        /**
	         * Transfers an existing call to another existing call.
	         *
	         * This is an RCC service only method.
	         *
	         * @name fcs.call#OutgoingCall#consultativeTransfer
	         * @function
	         * @since 3.1.1
	         * @param {string} transferredCallId The id of call which will be transferred into the current(outgoing) call
	         * @param {function} onSuccess The onSuccess() callback function to be called
	         * @param {function} onFailure The onFailure({@link fcs#Errors}) callback function to be called
	         *
	         * @example
	         *
	         * // When an incoming call is received, {@link fcs.call#event:onReceived} handler will be invoked.
	         *
	         * var incomingCall = {};
	         * fcs.call.onReceived = function(call) {
	         *    incomingCall = call;
	         * };
	         *
	         * // When an outgoing call is received, {@link fcs.call.event:onOutgoingCall} handler will be invoked.
	         *
	         * var outgoingCall = {};
	         * fcs.call.onOutgoingCall = function(call) {
	         *    outgoingCall = call;
	         * };
	         *
	         * outgoingCall.consultativeTransfer(incomingCall.getId(), onSuccess, onFailure);
	         */

	        /**
	         * Stop the video for this call after the call is established.
	         * This is a SPiDR service only method.
	         *
	         * @name fcs.call#OutgoingCall#videoStop
	         * @function
	         * @since 3.0.0
	         * @param {function} [onSuccess] The onSuccess() to be called when the video is stopped<br />
	         * function()
	         * @param {function} [onFailure] The onFailure() to be called when the video could not be stopped<br />
	         * function()
	         *
	         * @example
	         *
	         * A previously created {@link fcs.call#OutgoingCall} is required. {@see {@link fcs.call#startCall}} for more details.
	         *
	         * var outgoingCall = {};
	         * fcs.call.startCall(..., ..., ..., onSuccess(outgoingCall), ..., ...);
	         *
	         * var videoStopOnSuccess = function(){
	         *    //do something here
	         * };
	         * var videoStopOnFailure = function(){
	         *    //do something here
	         * };
	         *
	         * outgoingCall.videoStop(videoStopOnSuccess, videoStopOnFailure);
	         */

	        /**
	         * Start the video for this call after the call is established.
	         * This is a SPiDR service only method.
	         *
	         * @name fcs.call#OutgoingCall#videoStart
	         * @function
	         * @since 3.0.0
	         * @param {function} [onSuccess] The onSuccess() to be called when the video is started
	         * @param {function} [onFailure] The onFailure() to be called when the video could not be started
	         * @param {string} [videoQuality] Sets the quality of video, this parameter will be passed to getUserMedia()
	         *                  if the video source is allowed before, this parameter will not be used
	         *
	         * @example
	         *
	         * A previously created {@link fcs.call#OutgoingCall} is required. {@see {@link fcs.call#startCall}} for more details.
	         *
	         * var outgoingCall = {};
	         * fcs.call.startCall(..., ..., ..., onSuccess(outgoingCall), ..., ...);
	         *
	         * var videoStartOnSuccess = function(){
	         *    //do something here
	         * };
	         * var videoStartOnFailure = function(){
	         *    //do something here
	         * };
	         *
	         * outgoingCall.videoStart(videoStopOnSuccess, videoStopOnFailure);
	         */

	        /**
	         * Join 2 calls.
	         * You need two different calls to establish this functionality.<br>
	         *
	         * In SPiDR implementation: in order to join two calls both calls must
	         * be put into hold state first.<br>
	         *
	         * In RCC implementation: in order to join two calls one call must
	         * be in local hold state, and the other one must be in answered state. <br>
	         *
	         * If not call servers will not handle your request.
	         *
	         * This is a SPiDR and RCC service method.
	         *
	         * @name fcs.call#OutgoingCall#join
	         * @function
	         * @param {fcs.call#Call} anotherCall Call that we want the current call to be joined to.
	         * @param {function} onSuccess The onSuccess({@link fcs.call#OutgoingCall}) to be called when the call have been joined provide the joined call as parameter
	         * @param {function} [onFailure] The onFailure() to be called when media could not be join
	         * @param {boolean} [isVideoEnabled] In order to join video calls set this to true. This is a SPiDR service only parameter.
	         * @param {string} [videoQuality] Sets the quality of video. This is a SPiDR service only parameter.
	         *
	         * @example
	         * // Available since 3.0.0 for SPiDR service, and since 3.1.1 for RCC service.
	         * // A previously created {@link fcs.call#OutgoingCall} is required. {@see {@link fcs.call#startCall}} for more details.
	         *
	         * var outgoingCall = {};
	         * fcs.call.startCall(..., ..., ..., onSuccess(outgoingCall), ..., ...);
	         *
	         * // And another {@link fcs.call#OutgoingCall} or {@link fcs.call#IncomingCall} is required which is going to be joined.
	         * var anotherCall; // assume this is previosuly created.
	         *
	         * var joinOnSuccess = function(joinedCall){
	         *    joinedCall // newly created.
	         *    console.log('Join success!');
	         * };
	         * var joinOnFailure = function(){
	         *    console.log('Join failure!');
	         * };
	         *
	         * outgoingCall.join(anotherCall, joinOnSuccess, joinOnFailure, isVideoEnabled, videoQuality);
	         *
	         * // When join() is successfuly completed, joinOnSuccess({@link fcs.call#OutgoingCall}) will be invoked.
	         */

	        /**
	         * Send Dual-tone multi-frequency signaling.
	         * This is a SPiDR service only method.
	         *
	         * @name fcs.call#OutgoingCall#sendDTMF
	         * @function
	         * @since 3.0.0
	         * @param {String} tone Tone to be send as dtmf.
	         *
	         * @example
	         *
	         * A previously created {@link fcs.call#OutgoingCall} is required. {@see {@link fcs.call#startCall}} for more details.
	         *
	         * var outgoingCall = {};
	         * fcs.call.startCall(..., ..., ..., onSuccess(outgoingCall), ..., ...);
	         *
	         * var videoStartOnSuccess = function(){
	         *    //do something here
	         * };
	         * var videoStartOnFailure = function(){
	         *    //do something here
	         * };
	         *
	         * outgoingCall.sendDTMF("0");
	         */

	        /**
	         * Returns the call is a join call or not
	         * Do not use this function if you really dont need it.
	         * This will be handled by the framework.
	         * This is a SPiDR service only method.
	         *
	         * @name fcs.call#OutgoingCall#getJoin
	         * @function
	         * @since 3.0.0
	         * @returns {Boolean} isJoin
	         *
	         * @example
	         *
	         * A previously created {@link fcs.call#OutgoingCall} is required. {@see {@link fcs.call#startCall}} for more details.
	         *
	         * var outgoingCall = {};
	         * fcs.call.startCall(..., ..., ..., onSuccess(outgoingCall), ..., ...);
	         *
	         * var videoStartOnSuccess = function(){
	         *    //do something here
	         * };
	         * var videoStartOnFailure = function(){
	         *    //do something here
	         * };
	         *
	         * outgoingCall.getJoin();
	         *
	         * This method will return true if the outgoingCall is a previously joined call {@see {@link fcs.call#OutgoingCall#join}}.
	         */

	        /**
	         * Marks the call as a join call or not
	         * Do not use this function if you really dont need it.
	         * This will be handled by the framework.
	         * This is a SPiDR service only method.
	         *
	         * @name fcs.call#OutgoingCall#setJoin
	         * @function
	         * @since 3.0.0
	         * @param {String} join
	         *
	         * @example
	         *
	         * When an outgoing call is received, {@link fcs.call#event:onReceived} handler will be invoked.
	         *
	         * var outgoingCall = {};
	         * fcs.call.onReceived = function(call) {
	         *    outgoingCall = call;
	         * };
	         *
	         * outgoingCall.setJoin(true);
	         */

	        /**
	         * Returns the button is a disabled or not
	         * You may want to disable your buttons while waiting for a response.
	         * Ex: this will prevent clicking multiple times for hold button until first hold response is not recieved.
	         * This is a SPiDR service only method.
	         *
	         * @name fcs.call#OutgoingCall#getButtonDisabler
	         * @function
	         * @since 3.0.0
	         * @returns {Boolean} buttonDisabler
	         *
	         * @example
	         *
	         * When an outgoing call is received, {@link fcs.call#event:onReceived} handler will be invoked.
	         *
	         * var outgoingCall = {};
	         * fcs.call.onReceived = function(call) {
	         *    outgoingCall = call;
	         * };
	         *
	         * outgoingCall.getButtonDisabler();
	         */

	        /**
	         * Clears the timer set with fcs.call#IncomingCall#setButtonDisabler.
	         * You may want to disable your buttons while waiting for a response.
	         * Ex: this will prevent clicking multiple times for hold button until first hold response is not recieved.
	         * This is a SPiDR service only method.
	         *
	         * @name fcs.call#OutgoingCall#clearBtnTimeout
	         * @function
	         * @since 3.0.0
	         * @param {bool} disable
	         *
	         * @example
	         *
	         * When an outgoing call is received, {@link fcs.call#event:onReceived} handler will be invoked.
	         *
	         * var outgoingCall = {};
	         * fcs.call.onReceived = function(call) {
	         *    outgoingCall = call;
	         * };
	         *
	         * outgoingCall.clearBtnTimeout();
	         */

	        /**
	         * Clears the timer set with fcs.call#IncomingCall#setButtonDisabler.
	         * You may want to disable your buttons while waiting for a response.
	         * Ex: this will prevent clicking multiple times for hold button until first hold response is not recieved.
	         * This is a SPiDR service only method.
	         *
	         * @name fcs.call#OutgoingCall#clearBtnTimeout
	         * @function
	         * @since 3.0.0
	         *
	         * @example
	         *
	         * When an outgoing call is received, {@link fcs.call#event:onReceived} handler will be invoked.
	         *
	         * var outgoingCall = {};
	         * fcs.call.onReceived = function(call) {
	         *    outgoingCall = call;
	         * };
	         *
	         * outgoingcall.clearBtnTimeout();
	         */

	        /**
	         * Long call audit
	         * Creates a timer after call is established.
	         * This timer sends a "PUT" request to server.
	         * This will continue until one request fails.
	         * Handled by framework. You dont need to call this function.
	         * This is a SPiDR service only method.
	         *
	         * @name fcs.call#OutgoingCall#setAuditTimer
	         * @function
	         * @since 3.0.0
	         * @param {function} audit
	         *
	         * @example
	         *
	         * When an incoming call is received, {@link fcs.call#event:onReceived} handler will be invoked.
	         * incomingCall.setAuditTimer(audit);
	         */


	        /**
	         * Clears the long call audit prior to clearing all call resources.
	         * Handled by framework. you dont need to call this function.
	         * This is a SPiDR service only method.
	         *
	         * @name fcs.call#OutgoingCall#clearAuditTimer
	         * @function
	         * @since 3.0.0
	         *
	         * @example
	         *
	         * When an outgoing call is received, {@link fcs.call#event:onReceived} handler will be invoked.
	         */

	        /**
	         * @deprecated DO NOT USE, use isVideoNegotiationAvailable instead
	         * Returns video negotation availability.
	         * This is a SPiDR service only method.
	         *
	         * @name fcs.call#OutgoingCall#isVideoNegotationAvailable
	         * @function
	         * @since 3.0.1
	         * @param {String} id Unique identifier for the call
	         * @example
	         * A previously created {@link fcs.call#OutgoingCall} is required. {@see {@link fcs.call#startCall}} for more details.
	         *
	         * var outgoingCall = {};
	         * fcs.call.startCall(..., ..., ..., onSuccess(outgoingCall), ..., ...);
	         * outgoingCall.isVideoNegotationAvailable(id);
	         */

	        /**
	         * Returns video negotiation availability.
	         * This is a SPiDR service only method.
	         *
	         * @name fcs.call#OutgoingCall#isVideoNegotiationAvailable
	         * @function
	         * @since 3.1.0
	         * @example
	         * A previously created {@link fcs.call#OutgoingCall} is required. {@see {@link fcs.call#startCall}} for more details.
	         *
	         * var outgoingCall = {};
	         * fcs.call.startCall(..., ..., ..., onSuccess(outgoingCall), ..., ...);
	         * outgoingCall.isVideoNegotiationAvailable();
	         */
	    };
	};

	//@{fcs-jsl-prod}
	var Call = function(manager) {
	    return new CallImpl(manager || callManager);
	};

	fcs.call = new Call(serviceInvokeManager);
	//@{fcs-jsl-prod}

	/**
	 * Handles receiving of custom messages (Custom).
	 *
	 * @name custom
	 * @namespace
	 * @memberOf fcs
	 *
	 * @version 4.2.0
	 * @since 3.0.0
	 */
	var Custom = function() {

	    /**
	     * Called on receipt of an instant message
	     *
	     * @name fcs.custom#onReceived
	     * @event
	     * @param {fcs.custom#Message} custom Message received
	     * @since 3.0.0
	     * @example
	     * var messageReceived = function(msg){
	     *    // do something here
	     * };
	     *
	     * fcs.custom.onReceived = messageReceived;
	     */

	};


	var CustomImpl = function() {
	    this.onReceived = null;
	};

	//@{fcs-jsl-prod}
	CustomImpl.prototype = new Custom();
	fcs.custom = new CustomImpl();

	NotificationCallBacks.custom = function(data) {
	    utils.callFunctionIfExist(fcs.custom.onReceived, data);
	};
	//@{fcs-jsl-prod}


	var PRESENCE_URL = "/presence",
	    PRESENCE_WATCHER_URL = "/presenceWatcher",
	    REQUEST_TYPE_WATCH = "watch",
	    REQUEST_TYPE_SUBSCRIPTION = "subscription",
	    REQUEST_TYPE_WATCHERAUTHORIZATION = "watcherAuthorization",
	    REQUEST_TYPE_STOP_WATCH = "stopwatch",
	    REQUEST_TYPE_GET = "get",
	    PRESENCE_WATCHER_REQUEST_URLS = {
	        ALLOWED_USERS: '/allowedusers',
	        BANNED_USERS: '/blockedusers',
	        SHOWOFFLINE_USERS: '/politeblockedusers'
	    },
	    PRESENCE_WATCHER_LIST_UPDATE_TYPE = {
	        ADD: "add",
	        DELETE: "delete"
	    },
	    PRESENCE_STATE = {
	        CONNECTED: 0,
	        UNAVAILABLE: 1,
	        AWAY: 2,
	        OUT_TO_LUNCH: 3,
	        BUSY: 4,
	        ON_VACATION: 5,
	        BE_RIGHT_BACK: 6,
	        ON_THE_PHONE: 7,
	        ACTIVE: 8,
	        INACTIVE: 9,
	        PENDING: 10,
	        OFFLINE: 11,
	        CONNECTEDNOTE: 12,
	        UNAVAILABLENOTE: 13
	    },
	    STATUS_OPEN = "open",
	    STATUS_CLOSED = "closed",
	    ACTIVITY_UNKNOWN = "unknown",
	    ACTIVITY_AWAY = "away",
	    ACTIVITY_LUNCH = "lunch",
	    ACTIVITY_BUSY = "busy",
	    ACTIVITY_VACATION = "vacation",
	    ACTIVITY_ON_THE_PHONE = "on-the-phone",
	    ACTIVITY_OTHER = "other",
	    NOTE_BE_RIGHT_BACK = "Be Right Back",
	    NOTE_OFFLINE = "Offline",
	    USERINPUT_ACTIVE = "active",
	    USERINPUT_INACTIVE = "inactive";

	var PresenceStateParser = function() {

	    var stateRequest = [];

	    stateRequest[PRESENCE_STATE.CONNECTED] = {
	        status: STATUS_OPEN,
	        activity: ACTIVITY_UNKNOWN
	    };
	    stateRequest[PRESENCE_STATE.UNAVAILABLE] = {
	        status: STATUS_CLOSED,
	        activity: ACTIVITY_UNKNOWN
	    };
	    stateRequest[PRESENCE_STATE.AWAY] = {
	        status: STATUS_OPEN,
	        activity: ACTIVITY_AWAY
	    };
	    stateRequest[PRESENCE_STATE.OUT_TO_LUNCH] = {
	        status: STATUS_OPEN,
	        activity: ACTIVITY_LUNCH
	    };
	    stateRequest[PRESENCE_STATE.BUSY] = {
	        status: STATUS_CLOSED,
	        activity: ACTIVITY_BUSY
	    };
	    stateRequest[PRESENCE_STATE.ON_VACATION] = {
	        status: STATUS_CLOSED,
	        activity: ACTIVITY_VACATION
	    };
	    stateRequest[PRESENCE_STATE.BE_RIGHT_BACK] = {
	        status: STATUS_OPEN,
	        activity: ACTIVITY_OTHER,
	        note: NOTE_BE_RIGHT_BACK
	    };
	    stateRequest[PRESENCE_STATE.ON_THE_PHONE] = {
	        status: STATUS_OPEN,
	        activity: ACTIVITY_ON_THE_PHONE
	    };
	    stateRequest[PRESENCE_STATE.ACTIVE] = {
	        status: STATUS_OPEN,
	        activity: ACTIVITY_UNKNOWN,
	        userInput: USERINPUT_ACTIVE
	    };
	    stateRequest[PRESENCE_STATE.INACTIVE] = {
	        status: STATUS_CLOSED,
	        activity: ACTIVITY_UNKNOWN,
	        userInput: USERINPUT_INACTIVE
	    };
	    stateRequest[PRESENCE_STATE.OFFLINE] = {
	        status: STATUS_CLOSED,
	        activity: ACTIVITY_OTHER,
	        note: NOTE_OFFLINE
	    };
	    stateRequest[PRESENCE_STATE.CONNECTEDNOTE] = {
	        status: STATUS_OPEN,
	        activity: ACTIVITY_OTHER
	    };
	    stateRequest[PRESENCE_STATE.UNAVAILABLENOTE] = {
	        status: STATUS_CLOSED,
	        activity: ACTIVITY_OTHER
	    };

	    this.getRequestObject = function(presenceState) {
	        var state = stateRequest[presenceState];

	        if (state) {
	            return state;
	        } else {
	            throw new Error("Invalid Presence State");
	        }
	    };

	    this.getState = function(presence) {
	        switch (presence.userInput) {
	            case USERINPUT_ACTIVE:
	                return PRESENCE_STATE.ACTIVE;
	            case USERINPUT_INACTIVE:
	                return PRESENCE_STATE.INACTIVE;
	        }

	        switch (presence.note) {
	            case NOTE_BE_RIGHT_BACK:
	                return PRESENCE_STATE.BE_RIGHT_BACK;
	            case NOTE_OFFLINE:
	                return PRESENCE_STATE.OFFLINE;
	        }
	        if (presence.note) {
	            if (presence.status === STATUS_OPEN) {
	                return PRESENCE_STATE.CONNECTEDNOTE;
	            } else {
	                return PRESENCE_STATE.UNAVAILABLENOTE;
	            }
	        }

	        switch (presence.activity) {
	            case ACTIVITY_AWAY:
	                return PRESENCE_STATE.AWAY;
	            case ACTIVITY_LUNCH:
	                return PRESENCE_STATE.OUT_TO_LUNCH;
	            case ACTIVITY_BUSY:
	                return PRESENCE_STATE.BUSY;
	            case ACTIVITY_VACATION:
	                return PRESENCE_STATE.ON_VACATION;
	            case ACTIVITY_ON_THE_PHONE:
	                return PRESENCE_STATE.ON_THE_PHONE;
	            case ACTIVITY_UNKNOWN:
	                if (presence.status === STATUS_OPEN) {
	                    return PRESENCE_STATE.CONNECTED;
	                } else {
	                    return PRESENCE_STATE.UNAVAILABLE;
	                }
	        }
	        return PRESENCE_STATE.CONNECTED;
	    };
	};

	var presenceStateParser;

	var presenceWatcherUpdatePendingListNotifyCallback;

	var PresenceServiceImpl = function(_server, _logManager, _presenceStateParser, _fcs) {
	    var logger = _logManager.getLogger("presenceService");

	    this.onReceived = null;

	    this.update = function(presenceState, onSuccess, onFailure) {

	        _server.sendPostRequest({
	                "url": getWAMUrl(1, PRESENCE_URL),
	                "data": {
	                    "presenceRequest": _presenceStateParser.getRequestObject(presenceState)
	                }
	            },
	            onSuccess,
	            onFailure
	        );

	    };

	    function makeRequest(watchedUserList, onSuccess, onFailure, action) {
	        var data = {
	            "presenceWatcherRequest": {
	                "userList": watchedUserList,
	                "action": action
	            }
	        };
	        _server.sendPostRequest({
	                "url": getWAMUrl(1, PRESENCE_WATCHER_URL),
	                "data": data
	            },
	            onSuccess,
	            onFailure
	        );
	    }

	    this.watch = function(watchedUserList, onSuccess, onFailure) {
	        logger.info("subscribe presence status of users:", watchedUserList);
	        makeRequest(watchedUserList, function(result) {
	            if (onSuccess && typeof onSuccess === 'function') {
	                onSuccess(result.presenceWatcherResponse.expiryValue);
	            }
	        }, onFailure, REQUEST_TYPE_WATCH);
	    };

	    this.stopwatch = function(watchedUserList, onSuccess, onFailure) {
	        makeRequest(watchedUserList, onSuccess, onFailure, REQUEST_TYPE_STOP_WATCH);
	    };


	    this.retrieve = function(watchedUserList, onSuccess, onFailure) {
	        makeRequest(watchedUserList, onSuccess, onFailure, REQUEST_TYPE_GET);
	    };

	    function makeRemoveFromListRequest(user, urlSuffix, onSuccess, onFailure) {
	        if (user) {
	            var data = {
	                "presenceWatcherRequest": {
	                    "user": user,
	                    "action": PRESENCE_WATCHER_LIST_UPDATE_TYPE.DELETE
	                }
	            };
	            _server.sendPutRequest({
	                "url": getWAMUrl(1, PRESENCE_WATCHER_URL + urlSuffix),
	                "data": data
	            }, onSuccess, function(e) {
	                onFailure(e);
	            });
	        } else {
	            onFailure(_fcs.Errors.INVALID_PARAMETER);
	        }
	    }

	    function makeAddToListRequest(userList, urlSuffix, onSuccess, onFailure) {
	        if (userList && userList.length > 0) {
	            var data = {
	                "presenceWatcherRequest": {
	                    "userList": userList,
	                    "action": PRESENCE_WATCHER_LIST_UPDATE_TYPE.ADD
	                }
	            };
	            _server.sendPutRequest({
	                "url": getWAMUrl(1, PRESENCE_WATCHER_URL + urlSuffix),
	                "data": data
	            }, onSuccess, function(e) {
	                onFailure(e);
	            });
	        } else {
	            onFailure(_fcs.Errors.INVALID_PARAMETER);
	        }
	    }

	    function makeGetListRequest(urlSuffix, onSuccess, onFailure) {
	        _server.sendGetRequest({
	            "url": getWAMUrl(1, PRESENCE_WATCHER_URL + urlSuffix)
	        }, function(data) {
	            onSuccess(data.presenceWatcherResponse.presenceWatcherEntries);
	        }, function(e) {
	            onFailure(e);
	        });
	    }


	    this.authWatchers = function(onSuccess, onFailure, notifyCallback) {
	        presenceWatcherUpdatePendingListNotifyCallback = notifyCallback;
	        var data = {
	            "presenceWatcherRequest": {
	                "action": REQUEST_TYPE_WATCHERAUTHORIZATION
	            }
	        };
	        _server.sendPostRequest({
	                "url": getWAMUrl(1, PRESENCE_WATCHER_URL),
	                "data": data
	            },
	            onSuccess,
	            onFailure
	        );
	    };

	    this.getAllowedList = function(onSuccess, onFailure) {
	        makeGetListRequest(PRESENCE_WATCHER_REQUEST_URLS.ALLOWED_USERS, onSuccess, onFailure);
	    };
	    this.getBannedList = function(onSuccess, onFailure) {
	        makeGetListRequest(PRESENCE_WATCHER_REQUEST_URLS.BANNED_USERS, onSuccess, onFailure);
	    };

	    this.getShowOfflineList = function(onSuccess, onFailure) {
	        makeGetListRequest(PRESENCE_WATCHER_REQUEST_URLS.SHOWOFFLINE_USERS, onSuccess, onFailure);
	    };


	    this.removeFromBannedList = function(user, onSuccess, onFailure) {
	        makeRemoveFromListRequest(user, PRESENCE_WATCHER_REQUEST_URLS.BANNED_USERS, onSuccess, onFailure);
	    };

	    this.removeFromAllowedList = function(user, onSuccess, onFailure) {
	        makeRemoveFromListRequest(user, PRESENCE_WATCHER_REQUEST_URLS.ALLOWED_USERS, onSuccess, onFailure);
	    };

	    this.removeFromShowOfflineList = function(user, onSuccess, onFailure) {
	        makeRemoveFromListRequest(user, PRESENCE_WATCHER_REQUEST_URLS.SHOWOFFLINE_USERS, onSuccess, onFailure);
	    };


	    this.addToBannedList = function(userList, onSuccess, onFailure) {
	        makeAddToListRequest(userList, PRESENCE_WATCHER_REQUEST_URLS.BANNED_USERS, onSuccess, onFailure);
	    };

	    this.addToAllowedList = function(userList, onSuccess, onFailure) {
	        makeAddToListRequest(userList, PRESENCE_WATCHER_REQUEST_URLS.ALLOWED_USERS, onSuccess, onFailure);
	    };

	    this.addToShowOfflineList = function(userList, onSuccess, onFailure) {
	        makeAddToListRequest(userList, PRESENCE_WATCHER_REQUEST_URLS.SHOWOFFLINE_USERS, onSuccess, onFailure);
	    };
	};

	//@{fcs-jsl-prod}
	presenceStateParser = new PresenceStateParser();

	var presenceService = new PresenceServiceImpl(server, logManager, presenceStateParser, fcs);

	/*
	 * In order to find the users presence client receives 3 parameters from WAM
	 * status, activity, note and userInput.
	 * status is received in every presence notification and can have two parameters: open and closed
	 * For activity and note there can be only one of them in the presence notification.
	 * userInput comes with activity but userInput is the  one that decides presence.
	 * Presence is decided according to status and activity/note combination
	 */
	NotificationCallBacks.presenceWatcher = function(data) {
	    if (!fcs.notification.isAnonymous()) {
	        var presence = new fcs.presence.UpdateEvent(),
	            presenceParams = data.presenceWatcherNotificationParams;

	        presence.name = utils.getProperty(presenceParams, 'name');
	        presence.type = utils.getProperty(presenceParams, 'type');
	        presence.status = utils.getProperty(presenceParams, 'status');
	        presence.activity = utils.getProperty(presenceParams, 'activity');
	        presence.note = utils.getProperty(presenceParams, 'note');
	        presence.userInput = utils.getProperty(presenceParams, 'userInput');

	        presence.state = presenceStateParser.getState(presence);

	        fcs.logManager.getLogger("presenceService").info("presence received: ", presence);
	        utils.callFunctionIfExist(fcs.presence.onReceived, presence);

	    }
	};
	NotificationCallBacks.presenceWatcherPending = function(data) {
	    fcs.logManager.getLogger("presenceService").info("pending list received: ", data.presenceWatcherAuthorizationEntry);
	    data.presenceWatcherAuthorizationEntry.statusCode = data.statusCode;
	    utils.callFunctionIfExist(presenceWatcherUpdatePendingListNotifyCallback, data.presenceWatcherAuthorizationEntry);
	};
	//@{fcs-jsl-prod}


	var PresenceManagerImpl = function(_service, _fcs, _logManager, _globalBroadcaster, _utils) {
	    var self = this,
	        logger = _logManager.getLogger("presenceMng"),
	        watchedUserList = [],
	        storePendingList = new Map(),
	        presenceExtendInterval = null,
	        presenceWatcherExtendInterval = null,
	        presenceAuthWatcherSuccess = null,
	        presenceAuthWatcherFailure = null,
	        setAuthWatcherService = false;

	    self.Failures = {
	        SERVICE_FAILURE: 0
	    };

	    function getUserListToWatch(userList) {
	        var i, userListDelta = [];

	        for (i in userList) {
	            if (userList.hasOwnProperty(i) && watchedUserList.indexOf(userList[i]) === -1) {
	                userListDelta.push(userList[i]);
	            }
	        }

	        return userListDelta;
	    }

	    function getUserListToStopWatch(userList) {
	        var i, userListDelta = [];

	        for (i in userList) {
	            if (userList.hasOwnProperty(i) && watchedUserList.indexOf(userList[i]) !== -1) {
	                userListDelta.push(userList[i]);
	            }
	        }

	        return userListDelta;
	    }

	    function removeUsersFromWacthedUserList(userList) {
	        var i, indexToRemove;

	        for (i in userList) {
	            if (userList.hasOwnProperty(i)) {
	                indexToRemove = watchedUserList.indexOf(userList[i]);
	                watchedUserList.splice(indexToRemove, 1);
	            }
	        }
	    }

	    self.update = _service.update;

	    function clearPresenceSubscriptionExtendIntervalAndWacthedUserList() {
	        clearInterval(presenceExtendInterval);
	        presenceExtendInterval = null;
	        watchedUserList = [];
	        //PWA cache clear
	        setAuthWatcherService = false;
	        clearInterval(presenceWatcherExtendInterval);
	        presenceWatcherExtendInterval = null;
	        storePendingList.clear();
	    }

	    function onConnectionLost() {
	        //PWA cache clear
	        clearInterval(presenceWatcherExtendInterval);
	        presenceWatcherExtendInterval = null;
	        storePendingList.clear();
	    }

	    function onConnectionReEstablished() {
	        if (setAuthWatcherService) {
	            _service.authWatchers(function() {
	                logger.info("auth watcher ext. subs. success");
	            }, function(e) {
	                logger.error("auth watcher ext. subs. fail", e);
	            });
	        }
	    }

	    function setUpPresenceSubsriptionExtendInterval(expiryValue) {
	        if (!presenceExtendInterval) {
	            presenceExtendInterval = setInterval(function() {
	                sendWatchRequest(watchedUserList, undefined, function(err) {
	                    logger.error("presence svc. ext. subs. fail", err);
	                    _utils.callFunctionIfExist(_fcs.presence.onFailure, self.Failures.SERVICE_FAILURE);
	                });
	            }, (expiryValue * 1000) / 2);
	        }
	    }

	    function sendWatchRequest(userList, onSuccess, onFailure) {
	        if (userList.length > 0) {
	            _service.watch(userList, function(expiryValue) {
	                setUpPresenceSubsriptionExtendInterval(expiryValue);
	                _utils.callFunctionIfExist(onSuccess);
	            }, function(err) {
	                clearPresenceSubscriptionExtendIntervalAndWacthedUserList();
	                _utils.callFunctionIfExist(onFailure, err);
	            });
	        }
	    }

	    self.watch = function(userList, onSuccess, onFailure) {
	        var userListToWatch;

	        if (!Array.isArray(userList) || userList.length === 0) {
	            _utils.callFunctionIfExist(onFailure, _fcs.Errors.INVALID_PARAMETER);
	            return;
	        }

	        if (watchedUserList.length > 0) {
	            // there are some users previously watched

	            // identify delta between userList and watchedUserList
	            userListToWatch = getUserListToWatch(userList);

	            if (userListToWatch.length === 0) {
	                // provided userList is already watched
	                _utils.callFunctionIfExist(onSuccess);
	                return;
	            }
	            // send watch request to delta
	            // add delta to watchedUserLists
	            // do not initiate extend interval

	            watchedUserList = watchedUserList.concat(userListToWatch);
	        } else {
	            // initial watch request
	            watchedUserList = userListToWatch = userList;
	        }

	        sendWatchRequest(userListToWatch, onSuccess, onFailure);
	    };

	    self.stopwatch = function(userList, onSuccess, onFailure) {
	        var userListToStop;

	        if (!Array.isArray(userList) || userList.length === 0) {
	            _utils.callFunctionIfExist(onFailure, _fcs.Errors.INVALID_PARAMETER);
	            return;
	        }

	        if (watchedUserList.length === 0) {
	            _utils.callFunctionIfExist(onSuccess);
	            return;
	        }

	        userListToStop = getUserListToStopWatch(userList);

	        if (userListToStop.length === 0) {
	            _utils.callFunctionIfExist(onSuccess);
	            return;
	        }

	        _service.stopwatch(userListToStop, function() {
	            removeUsersFromWacthedUserList(userListToStop);

	            if (watchedUserList.length === 0) {
	                clearPresenceSubscriptionExtendIntervalAndWacthedUserList();
	            }
	            _utils.callFunctionIfExist(onSuccess);
	        }, function(err) {
	            _utils.callFunctionIfExist(onFailure, err);
	        });
	    };

	    self.retrieve = _service.retrieve;

	    function presenceServiceOnSubscriptionStartedHandler() {
	        sendWatchRequest(watchedUserList);
	    }

	    function removeUserFromPendingList(updatedUser) {
	        logger.info(updatedUser.watcherAddress + ' remove from store pending list');
	        storePendingList.remove(updatedUser.watcherAddress);
	    }

	    function addUserToPendingList(updatedUser) {
	        logger.info(updatedUser.watcherAddress + ' add to store pending list');
	        storePendingList.add(updatedUser.watcherAddress, updatedUser);
	    }

	    function triggerOnAuthPendingListUpdate(addObject, removeObject) {
	        if (addObject.enabled) {
	            _utils.callFunctionIfExist(_fcs.presence.onAuthPendingListUpdate, {
	                action: "add",
	                updatedUser: addObject.users
	            });
	        }
	        if (removeObject.enabled) {
	            _utils.callFunctionIfExist(_fcs.presence.onAuthPendingListUpdate, {
	                action: "remove",
	                updatedUser: removeObject.users
	            });
	        }
	    }

	    function addPendigListToMap(pendingNotifyData) {
	        if (pendingNotifyData.statusCode !== 0) {
	            clearInterval(presenceWatcherExtendInterval);
	            _utils.callFunctionIfExist(presenceAuthWatcherFailure, _fcs.Errors.AUTH);
	            presenceAuthWatcherFailure = null;
	            presenceAuthWatcherSuccess = null;
	            return;
	        }
	        _utils.callFunctionIfExist(presenceAuthWatcherSuccess);
	        presenceAuthWatcherSuccess = null;
	        presenceAuthWatcherFailure = null;
	        var pendingList = pendingNotifyData.pendingList;
	        // max 10 cycles
	        var addAction = {
	                enabled: false,
	                users: []
	            },
	            removeAction = {
	                enabled: false,
	                users: []
	            };
	        for (var i = 0; i < pendingList.length; i++) {
	            if (storePendingList.get(pendingList[i].watcherAddress)) {
	                if (storePendingList.get(pendingList[i].watcherAddress).status !== pendingList[i].status) {
	                    removeAction.enabled = true;
	                    removeAction.users.push(pendingList[i]);
	                    removeUserFromPendingList(pendingList[i]);
	                }
	            } else {
	                if (pendingList[i].status === 'pending') {
	                    addAction.enabled = true;
	                    addAction.users.push(pendingList[i]);
	                    addUserToPendingList(pendingList[i]);
	                }
	            }
	        }
	        if (addAction.enabled || removeAction.enabled) {
	            triggerOnAuthPendingListUpdate(addAction, removeAction);
	        }
	    }

	    function setPresenceWatcherExtendTimer(expiryTime) {
	        clearInterval(presenceWatcherExtendInterval);
	        presenceWatcherExtendInterval = setInterval(function() {
	            _service.authWatchers(function() {
	                logger.info("auth watcher ext. subs. success");
	            }, function(e) {
	                logger.error("auth watcher ext. subs. fail", e);
	            });
	        }, expiryTime / 2 * 1000);
	    }


	    self.authWatchers = function(onSuccess, onFailure) {
	        presenceAuthWatcherSuccess = onSuccess;
	        presenceAuthWatcherFailure = onFailure;
	        setAuthWatcherService = true;
	        _service.authWatchers(function(data) {
	            setPresenceWatcherExtendTimer(data.presenceWatcherResponse.expiryValue);
	            logger.info("auth watcher subs. success");
	        }, function(e) {
	            _utils.callFunctionIfExist(presenceAuthWatcherFailure, e);
	            presenceAuthWatcherFailure = null;
	            presenceAuthWatcherSuccess = null;
	            logger.error("auth watcher  subs. fail", e);
	        }, addPendigListToMap);
	    };

	    self.getPendingList = function(onSuccess) {
	        var returnData = [],
	            storeData = storePendingList.entries();
	        for (var i in storeData) {
	            if (storeData.hasOwnProperty(i)) {
	                returnData.push(storeData[i]);
	            }
	        }
	        _utils.callFunctionIfExist(onSuccess, returnData);
	    };

	    self.getAllowedList = _service.getAllowedList;

	    self.getBannedList = _service.getBannedList;

	    self.getShowOfflineList = _service.getShowOfflineList;


	    self.addToAllowedList = _service.addToAllowedList;

	    self.addToBannedList = _service.addToBannedList;

	    self.addToShowOfflineList = _service.addToShowOfflineList;


	    self.removeFromBannedList = _service.removeFromBannedList;

	    self.removeFromAllowedList = _service.removeFromAllowedList;

	    self.removeFromShowOfflineList = _service.removeFromShowOfflineList;

	    _globalBroadcaster.subscribe(CONSTANTS.EVENT.DEVICE_SUBSCRIPTION_STARTED,
	        presenceServiceOnSubscriptionStartedHandler);

	    _globalBroadcaster.subscribe(CONSTANTS.EVENT.DEVICE_SUBSCRIPTION_ENDED,
	        clearPresenceSubscriptionExtendIntervalAndWacthedUserList);

	    _globalBroadcaster.subscribe(CONSTANTS.EVENT.CONNECTION_LOST,
	        onConnectionLost);

	    _globalBroadcaster.subscribe(CONSTANTS.EVENT.CONNECTION_REESTABLISHED,
	        onConnectionReEstablished);
	};

	//@{fcs-jsl-prod}
	var presenceManager = new PresenceManagerImpl(presenceService, fcs, logManager, globalBroadcaster, utils);
	//@{fcs-jsl-prod}



	/**
	 * Groups presence related resources (Presence Update, Presence Watcher)
	 *
	 * @name presence
	 * @namespace
	 * @memberOf fcs
	 *
	 * @version 4.2.0
	 * @since 3.0.0
	 */
	var PresenceImpl = function(_manager) {

	    /**
	     * States for presences update requests.
	     *
	     * @name fcs.presence#State
	     * @enum {number}
	     * @since 3.0.0
	     * @readonly
	     * @property {number} [CONNECTED=0] The user is currently online
	     * @property {number} [UNAVAILABLE=1] The user is currently unavailable
	     * @property {number} [AWAY=2] The user is currently away
	     * @property {number} [OUT_TO_LUNCH=3] The user is currently out for lunch
	     * @property {number} [BUSY=4] The user is currently busy
	     * @property {number} [ON_VACATION=5] The user is currently on vacation
	     * @property {number} [BE_RIGHT_BACK=6] The user will be right back
	     * @property {number} [ON_THE_PHONE=7] The user is on the phone
	     * @property {number} [ACTIVE=8] The user is currently active
	     * @property {number} [INACTIVE=9] The user is currently inactive
	     * @property {number} [PENDING=10] Waiting for user authorization
	     * @property {number} [OFFLINE=11] The user is currently offline
	     * @property {number} [CONNECTEDNOTE=12] The user is connected and defined a note
	     * @property {number} [UNAVAILABLENOTE=13] The user is unavailable and defined a note
	     */
	    this.State = {
	        CONNECTED: 0,
	        UNAVAILABLE: 1,
	        AWAY: 2,
	        OUT_TO_LUNCH: 3,
	        BUSY: 4,
	        ON_VACATION: 5,
	        BE_RIGHT_BACK: 6,
	        ON_THE_PHONE: 7,
	        ACTIVE: 8,
	        INACTIVE: 9,
	        PENDING: 10,
	        OFFLINE: 11,
	        CONNECTEDNOTE: 12,
	        UNAVAILABLENOTE: 13
	    };

	    /**
	     * Sends the user's updated status and activity to the server.
	     *
	     * @name fcs.presence#update
	     * @function
	     * @param {fcs.presence#State} presenceState The user's presence state
	     * @param {function} onSuccess The onSuccess() callback to be called
	     * @param {function} onFailure The onFailure({@link fcs#Errors}) callback to be called
	     * @since 3.0.0
	     * @example
	     * var onSuccess = function(){
	     *    //do something here
	     * };
	     * var onError = function (err) {
	     *   //do something here
	     * };
	     *
	     * fcs.presence.update(fcs.presence.State.BE_RIGHT_BACK, onSuccess, onError );
	     */
	    this.update = function(presenceState, onSuccess, onFailure) {
	        _manager.update(presenceState, onSuccess, onFailure);
	    };

	    /**
	     * Starts watching the presence status of users in the provided user list.
	     *
	     * @name fcs.presence#watch
	     * @function
	     * @param {Array.<String>} watchedUserList list of users whose status is to be watched<br />
	     * If userList is an empty array or not an array, the onFailure callback to be called<br />
	     * with {@link fcs#Errors}#INVALID_PARAMETER
	     * @param {function} onSuccess The onSuccess() callback to be called
	     * @param {function} onFailure The onFailure({@link fcs#Errors}) callback to be called
	     * @since 3.0.0
	     * @example
	     * var onSuccess = function(){
	     *    //do something here
	     * };
	     * var onError = function (err) {
	     *   //do something here
	     * };
	     *
	     * fcs.presence.watch(["user1", "user2"], onSuccess, onError );
	     */
	    this.watch = function(watchedUserList, onSuccess, onFailure) {
	        _manager.watch(watchedUserList, onSuccess, onFailure);
	    };

	    /**
	     * Stops watching the presence status of the users in the provided user list.
	     *
	     * @name fcs.presence#stopwatch
	     * @function
	     * @param {Array.<String>} userList list of users whose status is to be unwatched<br />
	     * If userList is an empty array or not an array, the onFailure callback to be called<br />
	     * with {@link fcs#Errors}#INVALID_PARAMETER
	     * @param {function} onSuccess The onSuccess() callback to be called
	     * @param {function} onFailure The onFailure({@link fcs#Errors}) callback to be called
	     * @since 3.0.0
	     * @example
	     * var onSuccess = function(){
	     *    //do something here
	     * };
	     * var onError = function (err) {
	     *   //do something here
	     * };
	     *
	     * fcs.presence.stopwatch(["user1", "user2"], onSuccess, onError );
	     */
	    this.stopwatch = function(userList, onSuccess, onFailure) {
	        _manager.stopwatch(userList, onSuccess, onFailure);
	    };

	    /**
	     * Sends a request to receive a notification for the presence status of the users in the provided user list.<br />
	     * For each user in the provided list, {@link fcs.presence.event:onReceived} handler will be invoked.
	     *
	     * @name fcs.presence#retrieve
	     * @function
	     * @param {Array.<String>} userList list of users whose status is to be retrieved
	     * @param {function} onSuccess The onSuccess() callback to be called
	     * @param {function} onFailure The onFailure({@link fcs#Errors}) callback to be called
	     * @since 3.0.0
	     * @example
	     * var onSuccess = function(){
	     *    //do something here
	     * };
	     * var onError = function (err) {
	     *   //do something here
	     * };
	     *
	     * fcs.presence.retrieve(["user1", "user2"], onSuccess, onError );
	     */
	    this.retrieve = function(watchedUserList, onSuccess, onFailure) {
	        _manager.retrieve(watchedUserList, onSuccess, onFailure);
	    };

	    /**
	     * Handler called for when receiving a presence notification
	     *
	     * @name fcs.presence#onReceived
	     * @event
	     * @param {fcs.presence#UpdateEvent} event The presence update event
	     * @since 3.0.0
	     * @example
	     *
	     * fcs.presence.onReceived = function(presence) {
	     *     window.console.log("Presence of user: " + presence.name + " has changed to: " + presence.state);
	     * };
	     */

	    /**
	     * Failures for presence service
	     *
	     * @name fcs.presence#Failures
	     * @enum {number}
	     * @since 3.1.0
	     * @readonly
	     * @property {number} [SERVICE_FAILURE=0] Presence service failure<br />
	     * Presence service interrupted unexpectedly, please contact to your system administrator
	     */
	    this.Failures = _manager.Failures;

	    /**
	     * Represents a presence change event
	     *
	     * @name fcs.presence#UpdateEvent
	     * @class
	     * @version 4.2.0
	     * @since 3.0.0
	     */
	    this.UpdateEvent = function() {};
	    /**
	     * User name of the contact whose presence has changed.
	     *
	     * @name fcs.presence#UpdateEvent#name
	     * @field
	     * @type {String}
	     * @since 3.0.0
	     */

	    /**
	     * The presence state of the user.
	     *
	     * @name fcs.presence#UpdateEvent#state
	     * @field
	     * @type {fcs.presence#State}
	     * @since 3.0.0
	     */

	    /**
	     * The type of network for this presence.
	     *
	     * @name fcs.presence#UpdateEvent#type
	     * @field
	     * @type {String}
	     * @since 3.0.0
	     */

	    /**
	     *Subscibe to presence watcher list.<br />
	     *
	     * @name fcs.presence#authWatchers
	     * @function
	     * @param {function} onSuccess The onSuccess() callback to be called
	     * @param {function} onFailure The onFailure({@link fcs#Errors}) callback to be called
	     * @since 4.0.1
	     * @example
	     *      fcs.presence.authWatchers(function(){
	     *            window.console.log("Subscribe for presence watcher list success.");
	     *      },function(errorCode){
	     *            window.console.log("Subscribe for presence watcher list failure! Error code : " errorCode);
	     *      });
	     */

	    this.authWatchers = function(onSuccess, onFailure) {
	        _manager.authWatchers(onSuccess, onFailure);
	    };

	    /**
	     * Get Pending List.<br />
	     *
	     * @name fcs.presence#getPendingList
	     * @function
	     * @param {function} onSuccess The onSuccess(userList<Array>) callback to be called
	     * @since 4.0.1
	     * @example
	     *      fcs.presence.getPandingList(function(pendingList){
	     *            window.console.log("Pending List : " pendingList);
	     *      },function(errorCode){
	     *            window.console.log("Get pending list request failure! Error code : " errorCode);
	     *      });
	     */


	    this.getPendingList = function(onSuccess) {
	        _manager.getPendingList(onSuccess);
	    };

	    /**
	     * Get Allowed List.<br />
	     *
	     * @name fcs.presence#getAllowedList
	     * @function
	     * @param {function} onSuccess The onSuccess(userList<Array>) callback to be called
	     * @since 4.0.1
	     * @example
	     *      fcs.presence.getAllowedList(function(pendingList){
	     *            window.console.log("Allowed List : " pendingList);
	     *      });
	     */

	    this.getAllowedList = function(onSuccess, onFailure) {
	        _manager.getAllowedList(onSuccess, onFailure);
	    };

	    /**
	     * Get Banned List.<br />
	     *
	     * @name fcs.presence#getBannedList
	     * @function
	     * @param {function} onSuccess The onSuccess(userList<Array>) callback to be called
	     * @param {function} onFailure The onFailure({@link fcs#Errors}) callback to be called
	     * @since 4.0.1
	     * @example
	     *      fcs.presence.getBannedList(function(pendingList){
	     *            window.console.log("Banned List : " pendingList);
	     *      },function(errorCode){
	     *            window.console.log("Get banned list request failure! Error code : " errorCode);
	     *      });
	     */

	    this.getBannedList = function(onSuccess, onFailure) {
	        _manager.getBannedList(onSuccess, onFailure);
	    };

	    /**
	     * Get Show Offline List.<br />
	     *
	     * @name fcs.presence#getShowOfflineList
	     * @function
	     * @param {function} onSuccess The onSuccess(userList<Array>.) callback to be called
	     * @param {function} onFailure The onFailure({@link fcs#Errors}) callback to be called
	     * @since 4.0.1
	     * @example
	     *      fcs.presence.getShowOfflineList(function(pendingList){
	     *            window.console.log("ShowOffline List : " pendingList);
	     *      },function(errorCode){
	     *            window.console.log("Get show offline list request failure! Error code : " errorCode);
	     *      });
	     */

	    this.getShowOfflineList = function(onSuccess, onFailure) {
	        _manager.getShowOfflineList(onSuccess, onFailure);
	    };

	    /**
	     * Users add to allowed list <br />
	     *
	     * @name fcs.presence#addToAllowedList
	     * @function
	     * @param {Array.<String>} userList The list of users to move
	     * @param {function} onSuccess The onSuccess() callback to be called
	     * @param {function} onFailure The onFailure({@link fcs#Errors}) callback to be called
	     * @since 4.0.1
	     * @example
	     *      var userList = ["demo@demo.com",demo1@demo.com];
	     *
	     *      fcs.presence.addToAllowedList(userList,function(){
	     *            window.console.log("Add action success");
	     *      },function(errorCode){
	     *            window.console.log("Add action failure! Error code : " errorCode);
	     *      });
	     */

	    this.addToAllowedList = function(userList, onSuccess, onFailure) {
	        _manager.addToAllowedList(userList, onSuccess, onFailure);
	    };


	    /**
	     * Users add to banned list <br />
	     *
	     * @name fcs.presence#addToBannedList
	     * @function
	     * @param {Array.<String>} userList The list of users to move
	     * @param {function} onSuccess The onSuccess() callback to be called
	     * @param {function} onFailure The onFailure({@link fcs#Errors}) callback to be called
	     * @since 4.0.1
	     * @example
	     *      var userList = ["demo@demo.com",demo1@demo.com];
	     *
	     *      fcs.presence.addToBannedList(userList,function(){
	     *            window.console.log("Add action success");
	     *      },function(errorCode){
	     *            window.console.log("Add action failure! Error code : " errorCode);
	     *      });
	     */

	    this.addToBannedList = function(userList, onSuccess, onFailure) {
	        _manager.addToBannedList(userList, onSuccess, onFailure);
	    };

	    /**
	     * Users add to show offline list <br />
	     *
	     * @name fcs.presence#addToShowOfflineList
	     * @function
	     * @param {Array.<String>} userList The list of users to move
	     * @param {function} onSuccess The onSuccess() callback to be called
	     * @param {function} onFailure The onFailure({@link fcs#Errors}) callback to be called
	     * @since 4.0.1
	     * @example
	     *      var userList = ["demo@demo.com",demo1@demo.com];
	     *
	     *      fcs.presence.addToShowOfflineList(userList,function(){
	     *            window.console.log("Add action success");
	     *      },function(errorCode){
	     *            window.console.log("Add action failure! Error code : " errorCode);
	     *      });
	     */

	    this.addToShowOfflineList = function(userList, onSuccess, onFailure) {
	        _manager.addToShowOfflineList(userList, onSuccess, onFailure);
	    };

	    /**
	     * User remove from allowed list <br />
	     *
	     * @name fcs.presence#removeFromAllowedList
	     * @function
	     * @param {String} user The user to remove
	     * @param {function} onSuccess The onSuccess() callback to be called
	     * @param {function} onFailure The onFailure({@link fcs#Errors}) callback to be called
	     * @since 4.0.1
	     * @example
	     *      var user = "demo@demo.com";
	     *
	     *      fcs.presence.removeFromAllowedList(user,function(){
	     *            window.console.log("Remove action success");
	     *      },function(errorCode){
	     *            window.console.log("Remove action failure! Error code : " errorCode);
	     *      });
	     */

	    this.removeFromAllowedList = function(user, onSuccess, onFailure) {
	        _manager.removeFromAllowedList(user, onSuccess, onFailure);
	    };

	    /**
	     * User remove from show offline list <br />
	     *
	     * @name fcs.presence#removeFromShowOfflineList
	     * @function
	     * @param {String} user The user to remove
	     * @param {function} onSuccess The onSuccess() callback to be called
	     * @param {function} onFailure The onFailure({@link fcs#Errors}) callback to be called
	     * @since 4.0.1
	     * @example
	     *      var userList = "demo@demo.com";
	     *
	     *      fcs.presence.removeFromShowOfflineList(user,function(){
	     *            window.console.log("Remove action success");
	     *      },function(errorCode){
	     *            window.console.log("Remove action failure! Error code : " errorCode);
	     *      });
	     */

	    this.removeFromShowOfflineList = function(user, onSuccess, onFailure) {
	        _manager.removeFromShowOfflineList(user, onSuccess, onFailure);
	    };

	    /**
	     * User remove from banned list <br />
	     *
	     * @name fcs.presence#removeFromBannedList
	     * @function
	     * @param {String} user The user to remove
	     * @param {function} onSuccess The onSuccess() callback to be called
	     * @param {function} onFailure The onFailure({@link fcs#Errors}) callback to be called
	     * @since 4.0.1
	     * @example
	     *      var userList = "demo@demo.com";
	     *
	     *      fcs.presence.removeFromBannedList(user,function(){
	     *            window.console.log("Remove action success");
	     *      },function(errorCode){
	     *            window.console.log("Remove action failure! Error code : " errorCode);
	     *      });
	     */

	    this.removeFromBannedList = function(user, onSuccess, onFailure) {
	        _manager.removeFromBannedList(user, onSuccess, onFailure);
	    };

	    /**
	     * Handler called for when receiving a update list notification
	     *
	     * @name fcs.presence#onAuthPendingListUpdate
	     * @event
	     * @param {fcs.presence#onAuthPendingListUpdate} event The pending list update event
	     * @since 4.0.1
	     * @example
	     *
	     * fcs.presence.onAuthPendingListUpdate = function(updatedData) {
	     *     window.console.log("Updated Users" + updatedData.updatedUsers);
	     *     window.console.log("Update Action" + updatedData.action);
	     */
	};

	//@{fcs-jsl-prod}
	fcs.presence = new PresenceImpl(presenceManager);
	//@{fcs-jsl-prod}

	// Return the fcs module.
	return fcs;

	}));


/***/ },
/* 2 */
/***/ function(module, exports, __webpack_require__) {

	/* WEBPACK VAR INJECTION */(function(setImmediate) {/**@license MIT-promiscuous-Ruben Verborgh*/
	(function (func, obj) {
	  // Type checking utility function
	  function is(type, item) { return (typeof item)[0] == type; }

	  // Creates a promise, calling callback(resolve, reject), ignoring other parameters.
	  function Promise(callback, handler) {
	    // The `handler` variable points to the function that will
	    // 1) handle a .then(resolved, rejected) call
	    // 2) handle a resolve or reject call (if the first argument === `is`)
	    // Before 2), `handler` holds a queue of callbacks.
	    // After 2), `handler` is a finalized .then handler.
	    handler = function pendingHandler(resolved, rejected, value, queue, then, i) {
	      queue = pendingHandler.q;

	      // Case 1) handle a .then(resolved, rejected) call
	      if (resolved != is) {
	        return Promise(function (resolve, reject) {
	          queue.push({ p: this, r: resolve, j: reject, 1: resolved, 0: rejected });
	        });
	      }

	      // Case 2) handle a resolve or reject call
	      // (`resolved` === `is` acts as a sentinel)
	      // The actual function signature is
	      // .re[ject|solve](<is>, success, value)

	      // Check if the value is a promise and try to obtain its `then` method
	      if (value && (is(func, value) | is(obj, value))) {
	        try { then = value.then; }
	        catch (reason) { rejected = 0; value = reason; }
	      }
	      // If the value is a promise, take over its state
	      if (is(func, then)) {
	        function valueHandler(resolved) {
	          return function (value) { then && (then = 0, pendingHandler(is, resolved, value)); };
	        }
	        try { then.call(value, valueHandler(1), rejected = valueHandler(0)); }
	        catch (reason) { rejected(reason); }
	      }
	      // The value is not a promise; handle resolve/reject
	      else {
	        // Replace this handler with a finalized resolved/rejected handler
	        handler = function (Resolved, Rejected) {
	          // If the Resolved or Rejected parameter is not a function,
	          // return the original promise (now stored in the `callback` variable)
	          if (!is(func, (Resolved = rejected ? Resolved : Rejected)))
	            return callback;
	          // Otherwise, return a finalized promise, transforming the value with the function
	          return Promise(function (resolve, reject) { finalize(this, resolve, reject, value, Resolved); });
	        };
	        // Resolve/reject pending callbacks
	        i = 0;
	        while (i < queue.length) {
	          then = queue[i++];
	          // If no callback, just resolve/reject the promise
	          if (!is(func, resolved = then[rejected]))
	            (rejected ? then.r : then.j)(value);
	          // Otherwise, resolve/reject the promise with the result of the callback
	          else
	            finalize(then.p, then.r, then.j, value, resolved);
	        }
	      }
	    };
	    // The queue of pending callbacks; garbage-collected when handler is resolved/rejected
	    handler.q = [];

	    // Create and return the promise (reusing the callback variable)
	    callback.call(callback = { then:  function (resolved, rejected) { return handler(resolved, rejected); },
	                               catch: function (rejected)           { return handler(0,        rejected); } },
	                  function (value)  { handler(is, 1,  value); },
	                  function (reason) { handler(is, 0, reason); });
	    return callback;
	  }

	  // Finalizes the promise by resolving/rejecting it with the transformed value
	  function finalize(promise, resolve, reject, value, transform) {
	    setImmediate(function () {
	      try {
	        // Transform the value through and check whether it's a promise
	        value = transform(value);
	        transform = value && (is(obj, value) | is(func, value)) && value.then;
	        // Return the result if it's not a promise
	        if (!is(func, transform))
	          resolve(value);
	        // If it's a promise, make sure it's not circular
	        else if (value == promise)
	          reject(TypeError());
	        // Take over the promise's state
	        else
	          transform.call(value, resolve, reject);
	      }
	      catch (error) { reject(error); }
	    });
	  }

	  // Export the main module
	  module.exports = Promise;

	  // Creates a resolved promise
	  Promise.resolve = ResolvedPromise;
	  function ResolvedPromise(value) { return Promise(function (resolve) { resolve(value); }); }

	  // Creates a rejected promise
	  Promise.reject = function (reason) { return Promise(function (resolve, reject) { reject(reason); }); };

	  // Transforms an array of promises into a promise for an array
	  Promise.all = function (promises) {
	    return Promise(function (resolve, reject, count, values) {
	      // Array of collected values
	      values = [];
	      // Resolve immediately if there are no promises
	      count = promises.length || resolve(values);
	      // Transform all elements (`map` is shorter than `forEach`)
	      promises.map(function (promise, index) {
	        ResolvedPromise(promise).then(
	          // Store the value and resolve if it was the last
	          function (value) {
	            values[index] = value;
	            --count || resolve(values);
	          },
	          // Reject if one element fails
	          reject);
	      });
	    });
	  };
	})('f', 'o');

	/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(3).setImmediate))

/***/ },
/* 3 */
/***/ function(module, exports, __webpack_require__) {

	/* WEBPACK VAR INJECTION */(function(setImmediate, clearImmediate) {var nextTick = __webpack_require__(4).nextTick;
	var apply = Function.prototype.apply;
	var slice = Array.prototype.slice;
	var immediateIds = {};
	var nextImmediateId = 0;

	// DOM APIs, for completeness

	exports.setTimeout = function() {
	  return new Timeout(apply.call(setTimeout, window, arguments), clearTimeout);
	};
	exports.setInterval = function() {
	  return new Timeout(apply.call(setInterval, window, arguments), clearInterval);
	};
	exports.clearTimeout =
	exports.clearInterval = function(timeout) { timeout.close(); };

	function Timeout(id, clearFn) {
	  this._id = id;
	  this._clearFn = clearFn;
	}
	Timeout.prototype.unref = Timeout.prototype.ref = function() {};
	Timeout.prototype.close = function() {
	  this._clearFn.call(window, this._id);
	};

	// Does not start the time, just sets up the members needed.
	exports.enroll = function(item, msecs) {
	  clearTimeout(item._idleTimeoutId);
	  item._idleTimeout = msecs;
	};

	exports.unenroll = function(item) {
	  clearTimeout(item._idleTimeoutId);
	  item._idleTimeout = -1;
	};

	exports._unrefActive = exports.active = function(item) {
	  clearTimeout(item._idleTimeoutId);

	  var msecs = item._idleTimeout;
	  if (msecs >= 0) {
	    item._idleTimeoutId = setTimeout(function onTimeout() {
	      if (item._onTimeout)
	        item._onTimeout();
	    }, msecs);
	  }
	};

	// That's not how node.js implements it but the exposed api is the same.
	exports.setImmediate = typeof setImmediate === "function" ? setImmediate : function(fn) {
	  var id = nextImmediateId++;
	  var args = arguments.length < 2 ? false : slice.call(arguments, 1);

	  immediateIds[id] = true;

	  nextTick(function onNextTick() {
	    if (immediateIds[id]) {
	      // fn.call() is faster so we optimize for the common use-case
	      // @see http://jsperf.com/call-apply-segu
	      if (args) {
	        fn.apply(null, args);
	      } else {
	        fn.call(null);
	      }
	      // Prevent ids from leaking
	      exports.clearImmediate(id);
	    }
	  });

	  return id;
	};

	exports.clearImmediate = typeof clearImmediate === "function" ? clearImmediate : function(id) {
	  delete immediateIds[id];
	};
	/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(3).setImmediate, __webpack_require__(3).clearImmediate))

/***/ },
/* 4 */
/***/ function(module, exports) {

	// shim for using process in browser

	var process = module.exports = {};

	// cached from whatever global is present so that test runners that stub it
	// don't break things.  But we need to wrap it in a try catch in case it is
	// wrapped in strict mode code which doesn't define any globals.  It's inside a
	// function because try/catches deoptimize in certain engines.

	var cachedSetTimeout;
	var cachedClearTimeout;

	(function () {
	  try {
	    cachedSetTimeout = setTimeout;
	  } catch (e) {
	    cachedSetTimeout = function () {
	      throw new Error('setTimeout is not defined');
	    }
	  }
	  try {
	    cachedClearTimeout = clearTimeout;
	  } catch (e) {
	    cachedClearTimeout = function () {
	      throw new Error('clearTimeout is not defined');
	    }
	  }
	} ())
	var queue = [];
	var draining = false;
	var currentQueue;
	var queueIndex = -1;

	function cleanUpNextTick() {
	    if (!draining || !currentQueue) {
	        return;
	    }
	    draining = false;
	    if (currentQueue.length) {
	        queue = currentQueue.concat(queue);
	    } else {
	        queueIndex = -1;
	    }
	    if (queue.length) {
	        drainQueue();
	    }
	}

	function drainQueue() {
	    if (draining) {
	        return;
	    }
	    var timeout = cachedSetTimeout(cleanUpNextTick);
	    draining = true;

	    var len = queue.length;
	    while(len) {
	        currentQueue = queue;
	        queue = [];
	        while (++queueIndex < len) {
	            if (currentQueue) {
	                currentQueue[queueIndex].run();
	            }
	        }
	        queueIndex = -1;
	        len = queue.length;
	    }
	    currentQueue = null;
	    draining = false;
	    cachedClearTimeout(timeout);
	}

	process.nextTick = function (fun) {
	    var args = new Array(arguments.length - 1);
	    if (arguments.length > 1) {
	        for (var i = 1; i < arguments.length; i++) {
	            args[i - 1] = arguments[i];
	        }
	    }
	    queue.push(new Item(fun, args));
	    if (queue.length === 1 && !draining) {
	        cachedSetTimeout(drainQueue, 0);
	    }
	};

	// v8 likes predictible objects
	function Item(fun, array) {
	    this.fun = fun;
	    this.array = array;
	}
	Item.prototype.run = function () {
	    this.fun.apply(null, this.array);
	};
	process.title = 'browser';
	process.browser = true;
	process.env = {};
	process.argv = [];
	process.version = ''; // empty string to avoid regexp issues
	process.versions = {};

	function noop() {}

	process.on = noop;
	process.addListener = noop;
	process.once = noop;
	process.off = noop;
	process.removeListener = noop;
	process.removeAllListeners = noop;
	process.emit = noop;

	process.binding = function (name) {
	    throw new Error('process.binding is not supported');
	};

	process.cwd = function () { return '/' };
	process.chdir = function (dir) {
	    throw new Error('process.chdir is not supported');
	};
	process.umask = function() { return 0; };


/***/ }
/******/ ])
});
;